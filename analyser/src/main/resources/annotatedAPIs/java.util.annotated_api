/*
 * e2immu-annot: annotations for effective and eventual immutability
 * Copyright 2020, Bart Naudts, https://www.e2immu.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * -------
 *
 * The content of this file reflects a part of the public API
 * of the Java SDK. The only intended contribution of the
 * e2immu-annot project is to annotate some of the the publicly accessible
 * classes, methods and fields. The fact that this file resembles the Java
 * syntax is only done to facilitate the description and storage of the association
 * between annotations and the publicly accessible API elements of the Java SDK.
 */
package java.util;

import org.e2immu.annotation.*;

import java.lang.annotation.ElementType;
import java.util.function.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public interface Iterator<T> {
    void forEachRemaining(Consumer<? super T> action);

    boolean hasNext();

    T next();

    void remove();
}

@Container
// this is not in line with the JDK, but we will block null keys!
public interface Collection<E> extends Iterable<E> {

    // at least one element...
    @Size(min = 1)
    boolean add(@NotNull E e);

    // we have at least the amount of elements in the collection argument
    @Independent
    boolean addAll(@Size(copyMin = true) @NotNull1 Collection<? extends E> collection);

    @NotModified
    boolean contains(@NotNull Object object);

    @NotModified
    boolean containsAll(@NotNull1 Collection<?> c);

    // there is a "default forEach" in Iterable, but here we can guarantee that consumer is @NotNull1 (its
    // arguments will not be null either)
    void forEach(@NotNull1 Consumer<? super E> action);

    @NotModified
    @Size(equals = 0)
    boolean isEmpty();

    boolean remove(@NotNull Object object);

    @Independent
    boolean removeAll(@NotNull1 Collection<?> c);

    @NotModified
    @Size(min = 0)
    int size();

    @NotNull1
    @NotModified
    @Size(copy = true)
    Stream<E> stream();

    @NotNull1
    @NotModified
    @Size(copy = true)
    Object[] toArray();

    @NotNull1
    @Independent
    @NotModified
    <T> T[] toArray(@Output @NotNull1 T[] a);

    @NotNull1
    @Independent
    @NotModified
    @Size(copy = true)
    <T> T[] toArray(@NotNull IntFunction<T[]> generator);
}

@Container
// this is not in line with the JDK, but we will block null keys!
public interface List<E> extends Collection<E> {

    @Size(min = 1)
    boolean add(@NotNull E e);

    @Independent
    boolean addAll(@Size(copyMin = true) @NotNull1 Collection<? extends E> collection);

    @NotModified
    boolean contains(@NotNull Object object);

    @NotModified
    boolean containsAll(@NotNull1 Collection<?> c);

    @NotModified
    @Size(equals = 0)
    boolean isEmpty();

    @NotNull1
    Iterator<E> iterator();

    @NotModified
    @NotNull
    E get(int index);

    @NotModified
    @NotNull1
    @E2Container
    @Size(equals = 0)
    static <EE> List<EE> of();

    boolean remove(@NotNull Object object);

    @Independent
    boolean removeAll(@NotNull1 Collection<?> c);

    @NotModified
    @Size(min = 0)
    int size();

    @NotModified
    @NotNull1
    List<E> subList(int fromIndex, int toIndex);

    @NotNull1
    @NotModified
    @Size(copy = true)
    Object[] toArray();

    @NotNull1
    @Independent
    @NotModified
    @Size(copy = true)
    <T> T[] toArray(@NotNull1 @Output T[] a);
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys!
public interface Set<E> extends Collection<E> {

    @NotNull1
    Iterator<E> iterator();

    @NotNull1
    @NotModified
    @E2Container
    @Size(equals = 0)
    static <E> Set<E> of() {
    }

    @NotNull1
    @NotModified
    @E2Container
    @Size(equals = 1)
    static <E> Set<E> of(E e1) {
    }

    @NotNull1
    @NotModified
    @E2Container
    @Size(equals = 2)
    static <E> Set<E> of(E e1, E e2) {
    }

    @NotNull1
    @NotModified
    @E2Container
    @Size(equals = 3)
    static <E> Set<E> of(E e1, E e2, E e3) {
    }
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys and values!
public interface Map<K, V> {

    static interface Entry<K, V> {

        @NotNull
        @NotModified
        K getKey();

        @NotNull
        @NotModified
        V getValue();

    }

    @Size(equals = 0)
    void clear();

    @NotModified
    boolean containsKey(Object key);

    @NotModified
    boolean containsValue(Object value);

    @NotNull
    V computeIfAbsent(K key, @NotNull Function<? super K, ? extends V> mappingFunction);

    @NotNull
    @NotModified
    @Size(copy = true)
    Collection<V> values();

    @NotModified
    @Size(min = 0)
    int size();

    @NotModified
    @Size(equals = 0)
    boolean isEmpty();

    @NotModified
    V get(Object key);

    @Size(min = 1)
    V put(K k, V v);

    V remove(Object key);

    @Independent
    void putAll(@Size(copyMin = true) Map<? extends K, ? extends V> m);

    @NotModified
    void forEach(BiConsumer<? super K,â€‹ ?super V>action);

    @NotModified
    @NotNull
    @Size(copy = true)
    Set<Map.Entry<K, V>> entrySet();

    @NotModified
    @NotNull
    @Size(copy = true)
    Set<K> keySet();
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys and values!
public class HashSet<E> implements Set<E> {
    @Size(equals = 0)
    public HashSet() {
    }

    // IMPORTANT NOTE: the @Size(copy = true) assumes that equals() behaves in a similar way
    @Independent
    public HashSet(@Size(copy = true) Collection<? extends E> c) {
    }

    @Size(min = 1)
    public boolean add(E e) {
    }

    @Size(equals = 0)
    public void clear() {
    }

    @NotModified
    public boolean contains(Object o) {
    }

    @NotModified
    @Size(equals = 0)
    public boolean isEmpty() {
    }

    @NotNull
    public Iterator<E> iterator() {
    }

    public boolean remove(Object o) {
    }

    @NotModified
    @Size(min = 0)
    public int size() {
    }
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys!
public class ArrayList<E> implements List<E> {
    @Size(equals = 0)
    public ArrayList() {
    }

    @Size(equals = 0)
    public ArrayList(int size) {
    }

    @NotNull
    Iterator<E> iterator();
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys!
public class LinkedList<E> implements List<E> {
    @Size(equals = 0)
    public LinkedList() {
    }

    @Independent
    public LinkedList(@Size(copy = true) Collection<? extends E> c) {
    }

    @Size(min = 1)
    public boolean add(E e) {
    }

    @Independent
    public boolean addAll(@Size(copyMin = true) Collection<? extends E> c) {
    }

    @NotModified
    public boolean contains(Object o) {
    }

    @NotModified
    @Size(min = 0)
    public int size() {
    }
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys and values!
public class HashMap<K, V> implements Map<K, V> {
    @Size(equals = 0)
    public HashMap() {
    }

    // IMPORTANT NOTE: The @Size(copy) here assumes that the equals methods behave similarly
    @Independent
    public HashMap(@Size(copy = true) Map<? extends K, ? extends V> map) {
    }

    @Size(equals = 0)
    public void clear() {
    }

    @NotModified
    @Size(equals = 0)
    public boolean isEmpty() {
    }

    @Size(min = 1)
    public V put(K key, V value) {
    }

    @Independent
    public void putAll(@Size(copyMin = true) Map<? extends K, ? extends V> map) {
    }
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys!
public class Vector<E> implements List<E> {

    @Size(min = 1)
    public void add(int index, E element) {
    }

    @NotModified
    int capacity() {
    }
}

@Container
@NotNull(where = ElementType.PARAMETER)
// this is not in line with the JDK, but we will block null keys!
public class Stack<E> extends Vector<E> {
    @Size(equals = 0)
    public Stack() {
    }

    @NotModified
    @Size(equals = 0)
    public boolean empty() {
    }

    @NotNull
    @NotModified
    public E peek() {
    }

    @NotNull
    public E pop() {
    }

    @Identity
    @NotNull // could be implied
    @Size(min = 1)
    public E push(E item) {
    }

    @NotModified
    int search(Object o) {
    }
}

@UtilityClass
public class Objects {
    @NotNull
    @NotModified
    @Identity
    public static <T> T requireNonNull(@NotNull T t) {
    }

    @NotNull
    @NotModified
    @Identity
    public static <T> T requireNonNull(@NotNull T t, String message) {
    }

    @NotModified
    public static int hashCode(@NotModified Object object) {
    }

    @NotModified
    public static int hash(@NotModified Object... values) {
    }

    @NotModified
    public static boolean equals(@NotModified Object left, @NotModified Object right) {
    }
}

@FunctionalInterface
// again this goes against the API, but we want to raise problems when comparing with null
public interface Comparator<T> {
    int compare(T o1, T o2);

    static <U> Comparator<U> comparingInt(@NotNull ToIntFunction<? super U> keyExtractor);
}

@E1Container
public class Optional<T> {
    @Independent
    @NotNull
    @Size(equals = 0)
    static <T> Optional<T> empty() {
    }

    @NotNull
    @Size(equals = 1)
    static <T> Optional<T> of(@NotNull T t) {
    }

    @NotNull
    @Size(min = 0)
    static <T> Optional<T> ofNullable(T t) {
    }

    @NotNull
    T get() {
    }

    T orElse(T other) {
    }

    @NotNull
    T orElseThrow() {
    }

    @NotNull
    <X extends Throwable> T orElseThrow(@NotNull Supplier<? extends X> exceptionSupplier) {
    }

    @Size(equals = 0)
    boolean isEmpty() {
    }

    @Size(equals = 1)
    boolean isPresent() {
    }

}

@UtilityClass
public class Arrays {
    @NotNull
    static IntStream stream(@Size(copy = true) @NotNull int[] array) {
    }
}
