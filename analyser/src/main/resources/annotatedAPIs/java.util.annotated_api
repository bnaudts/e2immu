/*
 * e2immu-annot: annotations for effective and eventual immutability
 * Copyright 2020, Bart Naudts, https://www.e2immu.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * -------
 *
 * The content of this file reflects a part of the public API
 * of the Java SDK. The only intended contribution of the
 * e2immu-annot project is to annotate some of the the publicly accessible
 * classes, methods and fields. The fact that this file resembles the Java
 * syntax is only done to facilitate the description and storage of the association
 * between annotations and the publicly accessible API elements of the Java SDK.
 */
package java.util;

import org.e2immu.annotation.*;

import java.util.function.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public interface Iterator<T> {
    @NotModified
    default void forEachRemaining(Consumer<? super T> action) {
    }

    boolean hasNext();

    T next();

    void remove();
}

@Container
// this is not in line with the JDK, but we will block null keys!
public interface Collection<E> extends Iterable<E> {

    static boolean add$Modification$Size(int i, int j, E e) { return contains(e) ? i == j : !contains(e) || j==0 ? i == j+1: i >= j && i <= j+1; }
    static boolean add$Value$Size(int i, int j, E e, boolean retVal) { return contains(e) ? false : !contains(e) || j==0 ? true: retVal; }
    boolean add$Postcondition(E e) { return contains(e); }
    boolean add(@NotNull E e);

    static int addAll$Modification$Size(int i, int j, Collection<? extends E> c) { return i >= j && i <= j + c.size(); }
    boolean addAll$Postcondition(Collection<? extends E> c) { return c.stream().allMatch(e -> contains(e)); }
    @Independent
    boolean addAll(@NotNull1 Collection<? extends E> collection);

    static int clear$Modification$Size(int i, int j) { return i==0; }
    boolean clear$Erase(Object any) { return !contains(any); } // should remove all contains
    @Modified
    void clear();

    static boolean contains$Value$Size(int i, boolean retVal) { return i == 0 ? false: retVal; }
    @NotModified
    boolean contains(@NotNull Object object);

    static boolean containsAll$Value$Size(int i, boolean retVal) { return i==0 ? false: retVal; }
    @NotModified
    boolean containsAll(@NotNull1 Collection<?> c);

    // there is a "default forEach" in Iterable, but here we can guarantee that consumer is @NotNull1 (its
    // arguments will not be null either)
    void forEach(@NotNull1 Consumer<? super E> action);

    boolean isEmpty$Value$Size(int i, boolean retVal) { return i==0; }
    @NotModified
    boolean isEmpty();

    boolean remove$Modification$Size(int i, int j) { return i <= j && i >= j -1; }
    boolean remove$Value$Size(int i, Object object, boolean retVal) { return i==0 ? false: retVal; }
    boolean remove$Postcondition(Object object) { return !contains(object); }
    boolean remove(@NotNull Object object);

    boolean removeAll$Modification$Size(int i, int j, Collection<?> c) { return i >= j - c.size() && i <= j; }
    boolean removeAll$Value$Size(int i, Collection<?> c, boolean retVal) { return i==0 || c.size()==0 ? false: retVal; }
    @Independent
    boolean removeAll(@NotNull1 Collection<?> c);

    boolean retainAll$Modification$Size(int i, int j, Collection<?> c) { return i <= c.size() && i <= j; }
    boolean retainAll$Value$Size(int i, Collection<?> c, boolean retVal) { return i==0 || c.size()==0 ? false: retVal; }
    @Independent
    boolean retainAll(@NotNull1 Collection<?> c);

    boolean size$Invariant$Size(int i) { return i >= 0; }
    void size$Aspect$Size() {}
    @NotModified
    int size();

    int stream$Transfer$Size(int i) { return i; }
    @NotNull1
    @NotModified
    Stream<E> stream();

    int toArray$Transfer$Size(int i) { return i; }
    @NotNull1
    @NotModified
    Object[] toArray();

    int toArray$Transfer$Size(int i) { return i; }
    @NotNull1
    @Independent
    @NotModified
    <T> T[] toArray(@Independent @NotNull1 T[] a);

    int toArray$Transfer$Size(int i) { return i; }
    @NotNull1
    @Independent
    @NotModified
    <T> T[] toArray(@NotNull IntFunction<T[]> generator);
}

@Container
// this is not in line with the JDK, but we will block null keys!
public interface List<E> extends Collection<E> {

    boolean add(@NotNull E e);

    @Independent
    boolean addAll(@NotNull1 Collection<? extends E> collection);

    @NotModified
    boolean contains(@NotNull Object object);

    @NotModified
    boolean containsAll(@NotNull1 Collection<?> c);

    @NotModified
    boolean isEmpty();

    @NotNull1
    Iterator<E> iterator();

    static boolean get$Precondition$Size(int size, int index) { return index < size; }
    @NotModified
    @NotNull
    E get(int index);

    static int of$Transfer$Size() { return 0; }
    @NotModified
    @NotNull1
    @E2Container
    static <EE> List<EE> of();

    static int of$Transfer$Size() { return 1; }
    static <F> boolean of$Postcondition(F e1) { return contains(e1); }
    @NotModified
    @NotNull1
    @E2Container
    static <F> List<F> of(@NotNull F e1);

    static int of$Transfer$Size() { return 2; }
    @NotModified
    @NotNull1
    @E2Container
    static <G> List<G> of(@NotNull G e1, @NotNull G e2);

    static int of$Transfer$Size() { return 3; }
    @NotModified
    @NotNull1
    @E2Container
    static <H> List<H> of(@NotNull H e1, @NotNull H e2, @NotNull H e3);

    boolean remove(@NotNull Object object);

    @Independent
    boolean removeAll(@NotNull1 Collection<?> c);

    @NotModified
    int size();

    @NotModified
    @NotNull1
    List<E> subList(int fromIndex, int toIndex);

    @NotNull1
    @NotModified
    Object[] toArray();

    @NotNull1
    @Independent
    @NotModified
    <T> T[] toArray(@NotNull1 @Independent T[] a);
}

@Container
// this is not in line with the JDK, but we will block null keys!
public interface Set<E> extends Collection<E> {

    @NotNull1
    Iterator<E> iterator();

    @NotNull1
    @NotModified
    @E2Container
    static <E> Set<E> of() {
    }

    @NotNull1
    @NotModified
    @E2Container
    static <E> Set<E> of(@NotNull E e1) {
    }

    @NotNull1
    @NotModified
    @E2Container
    static <E> Set<E> of(@NotNull E e1, @NotNull E e2) {
    }

    @NotNull1
    @NotModified
    @E2Container
    static <E> Set<E> of(@NotNull E e1, @NotNull E e2, @NotNull E e3) {
    }
}

@Container
// this is not in line with the JDK, but we will block null keys and values!
public interface Map<K, V> {

    static interface Entry<K, V> {

        @NotNull
        @NotModified
        K getKey();

        @NotNull
        @NotModified
        V getValue();

    }

    void clear();

    @NotModified
    boolean containsKey(@NotNull Object key);

    @NotModified
    boolean containsValue(@NotNull Object value);

    @NotNull
    V computeIfAbsent(@NotNull K key, @NotNull Function<? super K, ? extends V> mappingFunction);

    @NotNull
    @NotModified
    Collection<V> values();

    @NotModified
    int size();

    @NotModified
    boolean isEmpty();

    @NotModified
    V get(@NotNull Object key);

    V put(@NotNull K k, @NotNull V v);

    V remove(@NotNull Object key);

    @Independent
    void putAll(@NotNull Map<? extends K, ? extends V> m);

    @NotModified
    void forEach(@NotNull BiConsumer<? super K, ? super V> action);

    @NotModified
    @NotNull
    Set<Map.Entry<K, V>> entrySet();

    @NotModified
    @NotNull
    Set<K> keySet();
}

@Container
// this is not in line with the JDK, but we will block null keys and values!
public class HashSet<E> implements Set<E> {
    static int HashSet$Modification$Size() { return 0; }
    public HashSet() {
    }

    static int HashSet$Modification$Size(Collection<? extends E> c) { return c.size(); }
    boolean HashSet$Postcondition(Collection<? extends E> c) { return c.stream().allMatch(e -> contains(e)); }
    @Independent
    public HashSet(@NotNull Collection<? extends E> c) {
    }
    
    public boolean add(@NotNull E e) {
    }
    
    public void clear() {
    }

    @NotModified
    public boolean contains(@NotNull Object o) {
    }

    @NotModified
    public boolean isEmpty() {
    }

    @NotNull
    public Iterator<E> iterator() {
    }

    public boolean remove(@NotNull Object o) {
    }

    @NotModified
    public int size() {
    }
}

@Container
// this is not in line with the JDK, but we will block null keys!
public class ArrayList<E> implements List<E> {
    public ArrayList() {
    }
    
    public ArrayList(int size) {
    }

    @NotNull
    Iterator<E> iterator();
}

@Container
// this is not in line with the JDK, but we will block null keys!
public class LinkedList<E> implements List<E> {
    public LinkedList() {
    }

    @Independent
    public LinkedList(@NotNull Collection<? extends E> c) {
    }

    public boolean add(@NotNull E e) {
    }

    @Independent
    public boolean addAll(@NotNull Collection<? extends E> c) {
    }

    @NotModified
    public boolean contains(@NotNull Object o) {
    }

    @NotModified
    public int size() {
    }
}

@Container
// this is not in line with the JDK, but we will block null keys and values!
public class HashMap<K, V> implements Map<K, V> {
    public HashMap() {
    }

    @Independent
    public HashMap(@NotNull Map<? extends K, ? extends V> map) {
    }

    public void clear() {
    }

    @NotModified
    public boolean isEmpty() {
    }

    public V put(@NotNull K key, @NotNull V value) {
    }

    @Independent
    public void putAll(@NotNull Map<? extends K, ? extends V> map) {
    }
}

@Container
// this is not in line with the JDK, but we will block null keys!
public class Vector<E> implements List<E> {

    public void add(int index, @NotNull E element) {
    }

    @NotModified
    int capacity() {
    }
}

@Container
// this is not in line with the JDK, but we will block null keys!
public class Stack<E> extends Vector<E> {
    public Stack() {
    }

    @NotModified
    public boolean empty() {
    }

    @NotNull
    @NotModified
    public E peek() {
    }

    @NotNull
    public E pop() {
    }

    @Identity
    @NotNull // could be implied
    public E push(@NotNull E item) {
    }

    @NotModified
    int search(@NotNull Object o) {
    }
}

@UtilityClass
@Container
public class Objects {
    @NotNull
    @NotModified
    @Identity
    public static <T> T requireNonNull(@NotNull T t) {
    }

    @NotNull
    @NotModified
    @Identity
    public static <T> T requireNonNull(@NotNull T t, String message) {
    }

    @NotNull
    @NotModified
    public static <T> T requireNonNullElse(T obj, T defaultObj) {
    }

    @NotModified
    public static int hashCode(Object object) {
    }

    @NotModified
    public static int hash(Object... values) {
    }

    @NotModified
    public static boolean equals(Object left, Object right) {
    }
}

@FunctionalInterface
// again this goes against the API, but we want to raise problems when comparing with null
public interface Comparator<T> {

    int compare$Value(T o1, T o2, int retVal) { return o1.equals(o2) || o2.equals(o1) ? 0: retVal; }
    int compare(@NotModified T o1, @NotModified T o2);

    static <U> Comparator<U> comparingInt(@NotNull ToIntFunction<? super U> keyExtractor);
}

@E1Container
public class Optional<T> {
    @Independent
    @NotNull
    static <T> Optional<T> empty() {
    }

    @NotNull
    static <T> Optional<T> of(@NotNull T t) {
    }

    @NotNull
    static <T> Optional<T> ofNullable(T t) {
    }

    @NotNull
    T get() {
    }

    T orElse(T other) {
    }

    @NotNull
    T orElseThrow() {
    }

    @NotNull
    <X extends Throwable> T orElseThrow(@NotNull Supplier<? extends X> exceptionSupplier) {
    }

    boolean isEmpty() {
    }

    boolean isPresent() {
    }

}

@UtilityClass
public class Arrays {
    @NotNull
    static IntStream stream(@NotNull int[] array) {
    }
}

@UtilityClass
public class Collections {

    static <T> boolean addAll(@NotNull @Modified Collection<? super T> c,
                              @NotModified T... elements);
}