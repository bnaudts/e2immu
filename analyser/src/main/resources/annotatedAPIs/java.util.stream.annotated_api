package java.util.stream;

import org.e2immu.annotation.*;

import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.*;

public interface Collector<T, A, R> {
    @NotNull1
    Supplier<A> supplier();

    @NotNull
    BiConsumer<A, T> accumulator();

    @NotNull1
    BinaryOperator<A> combiner();

    @NotNull1
    Function<A, R> finisher();
}

@UtilityClass
@Container
public class Collectors {
    @NotNull1
    static Collector<CharSequence, ?, String> joining();

    @NotNull1
    static Collector<CharSequence, ?, String> joining(@NotNull CharSequence delimiter);

    @NotNull1
    static <T> Collector<T, ?, Set<T>> toSet();

    @NotNull1
    static <T> Collector<T, ?, List<T>> toList();
}

@E2Container
public interface IntStream {
    @Size(min = 0)
    long count();

    int sum();

    @Size(copy = true)
    @NotNull
    IntStream sorted();
}

@E2Container
public interface Stream<T> {

    @Size(equals = 0)
    @NotNull
    static <T> Stream<T> empty();

    @Size(equals = 1)
    @NotNull
    static <T> Stream<T> of(@NotNull T t);

    @NotNull
    static <T> Stream<T> of(@NotNull @Size(copy = true) T... t);

    @Size(min = 0)
    long count();

    @Size(copy = true)
    @NotNull
    <R> Stream<R> map(@NotNull Function<? super T, ? extends R> mapper);

    @NotNull
    <R, A> R collect(@NotNull Collector<? super T, A, R> collector);

    @NotNull
    Stream<T> filter(@NotNull Predicate<? super T> predicate);

    @NotNull
    @Size(copy = true)
    IntStream mapToInt(@NotNull ToIntFunction<? super T> mapper);

    @NotNull
    Optional<T> min(@NotNull Comparator<? super T> comparator);

    @NotNull
    @Size(copy = true)
    Stream<T> sorted();

    @NotNull
    Optional<T> findAny();

    @NotNull
    Optional<T> findFirst();
}
