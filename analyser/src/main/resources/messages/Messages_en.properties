#
# e2immu: a static code analyser for effective and eventual immutability
# Copyright 2020-2021, Bart Naudts, https://www.e2immu.org
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details. You should have received a copy of the GNU Lesser General Public
# License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

ANNOTATION_ABSENT=Annotation missing
ANNOTATION_UNEXPECTEDLY_PRESENT=Annotation should be absent
ASSERT_EVALUATES_TO_CONSTANT_FALSE=Condition in 'assert' is always false
ASSERT_EVALUATES_TO_CONSTANT_TRUE=Condition in 'assert' is always true
ASSIGNMENT_TO_CURRENT_VALUE=Assignment to current value
ASSIGNMENT_TO_FIELD_OUTSIDE_TYPE=Assigning to field outside the type
ASSIGNMENT_TO_SELF=Assigning a variable to itself
CALLING_MODIFYING_METHOD_ON_E2IMMU=Calling modifying method on level 2 immutable type
CIRCULAR_TYPE_DEPENDENCY=Detected circular type dependency: this affects modification computations
CONDITION_EVALUATES_TO_CONSTANT_ENN=Condition in 'if' or 'switch' statement evaluates to constant (implied via @NotNull on field)
CONDITION_EVALUATES_TO_CONSTANT=Condition in 'if' or 'switch' statement evaluates to constant
CONTRADICTING_ANNOTATIONS=Contradicting annotations
DIVISION_BY_ZERO=Division by zero
DUPLICATE_MARK_CONDITION=Duplicate mark precondition
EMPTY_LOOP=Empty loop
EVENTUAL_AFTER_REQUIRED=Calling a method requiring @Only(after) on an object in state @Only(before)
EVENTUAL_BEFORE_REQUIRED=Calling a method requiring @Only(before) on an object in state @Only(after)
FINALIZER_METHOD_CALLED_ON_FIELD_NOT_IN_FINALIZER=Finalizer method can only be called on a field in a finalizer method
FINALIZER_METHOD_CALLED_ON_PARAMETER=Finalizer method cannot be called on a parameter
IGNORING_RESULT_OF_METHOD_CALL=Ignoring result of method call
INCOMPATIBLE_IMMUTABILITY_CONTRACT_AFTER_NOT_EE1=Incompatible immutability contract: Contracted to be @E2Immutable after the mark, formal type is not (eventually) @E1Immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_AFTER_NOT_EE2=Incompatible immutability contract: Contracted to be @E2Immutable after the mark, formal type is not (eventually) @E2Immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_BEFORE_NOT_EE1=Incompatible immutability contract: Contracted to be @E1Immutable @BeforeMark, formal type is not eventually @E1Immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_BEFORE_NOT_EE2=Incompatible immutability contract: Contracted to be @E2Immutable @BeforeMark, formal type is not eventually @E2Immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_BEFORE_NOT_EVENTUALLY_IMMUTABLE=Incompatible immutability contract: Contracted to be @BeforeMark, formal type is not eventually immutable
INCOMPATIBLE_PRECONDITION=Incompatible preconditions
INLINE_CONDITION_EVALUATES_TO_CONSTANT=Inline conditional evaluates to constant
METHOD_SHOULD_BE_MARKED_STATIC=Method should be marked 'static'
MODIFICATION_NOT_ALLOWED=Illegal modification suspected
NON_PRIVATE_FIELD_NOT_FINAL=Non-private field is not effectively final (@Final)
NULL_POINTER_EXCEPTION=Null pointer exception
ONLY_WRONG_MARK_LABEL=@Only annotation, wrong mark label
OVERWRITING_PREVIOUS_ASSIGNMENT=Overwriting previous assignment
PARAMETER_SHOULD_NOT_BE_ASSIGNED_TO=Parameter should not be assigned to
PART_OF_EXPRESSION_EVALUATES_TO_CONSTANT=Part of short-circuit expression evaluates to constant
POTENTIAL_NULL_POINTER_EXCEPTION=Potential null pointer exception
PRECONDITION_ABSENT=Precondition missing
PRIVATE_FIELD_NOT_READ=Private field not read outside constructors
TRIVIAL_CASES_IN_SWITCH=Trivial cases in switch
TYPES_WITH_FINALIZER_ONLY_EFFECTIVELY_FINAL=Fields of types with a @Finalizer method can only be assigned to fields that are effectively final (@Final)
UNNECESSARY_FIELD_INITIALIZER=Unnecessary field initializer
UNNECESSARY_METHOD_CALL=Unnecessary method call
UNREACHABLE_STATEMENT=Unreachable statement
UNUSED_LOCAL_VARIABLE=Unused local variable
UNUSED_LOOP_VARIABLE=Unused loop variable
UNUSED_PARAMETER=Unused parameter
USELESS_ASSIGNMENT=Useless assignment
WORSE_THAN_IMPLEMENTED_INTERFACE=Property value worse than specified in implemented interface
WORSE_THAN_OVERRIDDEN_METHOD_PARAMETER=Property value worse than overridden method's parameter
WORSE_THAN_OVERRIDDEN_METHOD=Property value worse than overridden method
WRONG_ANNOTATION_PARAMETER=Wrong annotation parameter
WRONG_PRECONDITION=Wrong precondition
