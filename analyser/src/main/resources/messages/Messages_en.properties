#
# e2immu: a static code analyser for effective and eventual immutability
# Copyright 2020-2021, Bart Naudts, https://www.e2immu.org
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details. You should have received a copy of the GNU Lesser General Public
# License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
ANNOTATION_ABSENT=Annotation missing
ANNOTATION_UNEXPECTEDLY_PRESENT=Annotation should be absent
ASSERT_EVALUATES_TO_CONSTANT_FALSE=Condition in 'assert' is always false
ASSERT_EVALUATES_TO_CONSTANT_TRUE=Condition in 'assert' is always true
ASSIGNMENT_TO_CURRENT_VALUE=Assignment to current value
ASSIGNMENT_TO_FIELD_OUTSIDE_TYPE=Assigning to field outside the type
ASSIGNMENT_TO_SELF=Assigning a variable to itself
CALL_CYCLE_NOT_NULL=Not null computation restricted because of call cycle
CALLING_MODIFYING_METHOD_ON_E2IMMU=Calling modifying method on level 2 immutable type
CIRCULAR_TYPE_DEPENDENCY=Detected circular type dependency: this affects modification computations
CONDITION_EVALUATES_TO_CONSTANT_ENN=Condition in 'if' or 'switch' statement evaluates to constant (implied via @NotNull on field)
CONDITION_EVALUATES_TO_CONSTANT=Condition in 'if' or 'switch' statement evaluates to constant
CONTRADICTING_ANNOTATIONS=Contradicting annotations
DIVISION_BY_ZERO=Division by zero
DUPLICATE_MARK_CONDITION=Duplicate mark precondition
EMPTY_LOOP=Empty loop
EVENTUAL_AFTER_REQUIRED=Calling a method requiring @Only(after) on an object in state @Only(before)
EVENTUAL_BEFORE_REQUIRED=Calling a method requiring @Only(before) on an object in state @Only(after)
FIELD_INITIALIZATION_NOT_NULL_CONFLICT=At least one field initialization is in conflict with @NotNull requirements
FINALIZER_METHOD_CALLED_ON_FIELD_NOT_IN_FINALIZER=Finalizer method can only be called on a field in a finalizer method
FINALIZER_METHOD_CALLED_ON_PARAMETER=Finalizer method cannot be called on a parameter
IGNORING_RESULT_OF_METHOD_CALL=Ignoring result of method call
INCOMPATIBLE_IMMUTABILITY_CONTRACT_AFTER=Incompatible immutability contract: Contracted to be immutable after the mark, formal type is not (eventually) immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_BEFORE=Incompatible immutability contract: Contracted to be immutable @BeforeMark, formal type is not eventually immutable
INCOMPATIBLE_IMMUTABILITY_CONTRACT_BEFORE_NOT_EVENTUALLY_IMMUTABLE=Incompatible immutability contract: Contracted to be @BeforeMark, formal type is not eventually immutable
INCOMPATIBLE_PRECONDITION=Incompatible preconditions
INCONSISTENT_INDEPENDENCE_VALUE=Inconsistent independence value for type
INFINITE_LOOP_CONDITION=Infinite loop conditions
INLINE_CONDITION_EVALUATES_TO_CONSTANT=Inline conditional evaluates to constant
INTERRUPT_IN_LOOP=Interrupt exits loop prematurely; the analyser does not correct for this
LOOP_ONCE=Loop executed only once
METHOD_HAS_LOWER_VALUE_FOR_INDEPENDENT=Method override has lower value for @Independent
METHOD_SHOULD_BE_MARKED_STATIC=Method should be marked 'static'
MODIFICATION_NOT_ALLOWED=Illegal modification suspected
NON_PRIVATE_FIELD_NOT_FINAL=Non-private field is not effectively final (@Final)
NULL_POINTER_EXCEPTION=Null pointer exception
ONLY_WRONG_MARK_LABEL=@Only annotation, wrong mark label
OVERWRITING_PREVIOUS_ASSIGNMENT=Overwriting previous assignment
PARAMETER_SHOULD_NOT_BE_ASSIGNED_TO=Parameter should not be assigned to
PART_OF_EXPRESSION_EVALUATES_TO_CONSTANT=Part of short-circuit expression evaluates to constant
POTENTIAL_NULL_POINTER_EXCEPTION=Potential null pointer exception
POTENTIAL_CONTENT_NOT_NULL=Potential content not null problem
PRECONDITION_ABSENT=Precondition missing
PRIVATE_FIELD_NOT_READ=Private field not read outside constructors
TRIVIAL_CASES_IN_SWITCH=Trivial cases in switch
TYPES_WITH_FINALIZER_ONLY_EFFECTIVELY_FINAL=Fields of types with a @Finalizer method can only be assigned to fields that are effectively final (@Final)
TYPE_ANALYSIS_NOT_AVAILABLE=Type analysis not available yet
TYPE_HAS_HIGHER_VALUE_FOR_INDEPENDENT=Type has higher @Independent value than its methods allow
UNNECESSARY_FIELD_INITIALIZER=Unnecessary field initializer
UNNECESSARY_METHOD_CALL=Unnecessary method call
UNREACHABLE_STATEMENT=Unreachable statement
UNUSED_LOCAL_VARIABLE=Unused local variable
UNUSED_LOOP_VARIABLE=Unused loop variable
UNUSED_PARAMETER=Unused parameter
USELESS_ASSIGNMENT=Useless assignment
WORSE_THAN_IMPLEMENTED_INTERFACE=Property value of type worse than specified in implemented interface
WORSE_THAN_OVERRIDDEN_METHOD_PARAMETER=Property value of parameter worse than overridden method's parameter
WORSE_THAN_OVERRIDDEN_METHOD=Property value of method worse than overridden method
WRONG_ANNOTATION_PARAMETER=Wrong annotation parameter
WRONG_PRECONDITION=Wrong precondition
