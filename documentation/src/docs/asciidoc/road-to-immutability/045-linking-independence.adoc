[#linking-and-independence]
== Linking and independence

Let us now elaborate on how we will compute modifications, in a path towards level 2 immutability.
Consider the following example:

.Example 6, field linked to constructor parameter
[source,java]
----
class LinkExample1<X> {
    private final Set<X> set;

    public LinkExample1(Set<X> xs) {
        this.set = xs;
    }

    public void add(X x) {
        set.add(x);
    }
}
----

After construction, an instance of `LinkExample1` contains a reference to the set that was passed as an argument to its constructor.
We say the field `set` links to the parameter `xs` of the constructor.
In this example, this is an expensive way of saying that there is an assignment from one to the other.
However, linking can become more complicated.

The {e2immu} analyser will add modification annotations as follows:

.Example 7, field linked to constructor parameter, with annotations
[source,java]
----
class LinkExample1<X> {
    @Modified
    private final Set<X> set;

    public LinkExample1(@Modified Set<X> xs) {
        this.set = xs;
    }

    @Modified
    public void add(X x) {
        set.add(x);
    }
}
----

As noted above, the parameter `x` of `WithSet.add` is trivially `@NotModified`  because unbound parameter types have no modifying methods that can be called on them.

Linking looks at the underlying object, and not at the variable.
Consider the following alternative `add` method:

.Example 8, alternative add method
[source,java]
----
@Modified
public void add(X x) {
    Set<X> theSet = this.set;
    X theX = x;
    theSet.add(theX);
}
----

Nothing has changed, obviously.

****
Intuitively, linking means that modifying the source object implies that the linked object may be modified too.
Linking does not work on objects that cannot be modified, like primitives or deeply immutable objects such as `java.lang.String`.
****

We will discuss linking formally in <<linking-exposed>>.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that both represent the same object.

The opposite of linking is independence.
While the code analyser will not annotate linking, it will annotate independence with `@Independent` on methods and constructors, and, in one specific case, to parameters.

****
*Definition*: A method returning a real value (not `void`, not `this`) is *independent* when the object returned does not link to any of the fields of the type.
****

The definition for independence on a constructor is very similar:

****
*Definition*: A constructor is *independent* when the fields of the resulting instance do not link to the parameters of the constructor.
****

It follows immediately that:

* empty constructors of top-level types and static sub-types (but not necessarily inner classes, sub types-that are not static) are always independent
* methods that return primitives or deeply immutable objects are independent, since these objects cannot be modified

Examples follow soon, once immutability has been defined in more detail.
We discuss the special case of (in)dependence in the context of functional interfaces in <<functional-interfaces>>.