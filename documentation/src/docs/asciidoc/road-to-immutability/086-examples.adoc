== Examples


=== Trie

As a second example, let's look at the code analyser's implementation of a trie, a real, non-trivial data structure.
We have added the nullability annotations, as defined in the next section, but we removed some duplicate ones to avoid overloading the text.

.Code fragment: The code analyser's Trie type, slightly reduced in size.
[source,java]
----
package org.e2immu.analyser.util;

import com.google.common.collect.ImmutableList;
import org.e2immu.annotation.*;
import java.util.*;
import java.util.function.*;

@E2Container(after = "freeze")
public class Trie<T> extends Freezable {

    private final TrieNode<T> root = new TrieNode<>();
    private boolean frozen;

    @Container // by definition, has no methods
    private static class TrieNode<T> {
        @Nullable @Modified
        List<T> data;

        @Nullable @Modified
        Map<String, TrieNode<T>> map;
    }

    @Nullable @NotModified
    private TrieNode<T> goTo(@NotNull1 String[] strings) { // <1>
        return goTo(strings, strings.length);
    }

    @Nullable @NotModified
    private TrieNode<T> goTo(@NotNull1 String[] strings, int upToPosition) {
        TrieNode<T> node = root;
        for (int i = 0; i < upToPosition; i++) {
            if (node.map == null) return null;
            node = node.map.get(strings[i]);
            if (node == null) return null;
        }
        return node;
    }

    @Nullable @NotModified
    public List<T> get(@NotNull1 String[] strings) {
        TrieNode<T> node = goTo(strings);
        return node == null ? null : List.copyOf(node.data);
    }

    @NotNull @Modified @Only(before = "freeze")
    public List<T> getOrCompute(String[] strings, Function<String[], T> action) {
        if(frozen) throw new UnsupportedOperationException("Already frozen");

        TrieNode<T> node = goTo(strings);
        if (node == null) {
            return add(strings, action.apply(strings)).data;
        }
        if (node.data == null) {
            node.data = new LinkedList<>();
            node.data.add(action.apply(strings));
        }
        return node.data;
    }

    @NotModified
    public void visit(@NotNull1 String[] strings,
                      @NotNull2 BiConsumer<String[], List<T>> visitor) { // <2>
        TrieNode<T> node = goTo(strings);
        if (node == null) return;
        recursivelyVisit(node, new Stack<>(), visitor);
    }

    private static <T> void recursivelyVisit(TrieNode<T> node,
                                             Stack<String> strings,
                                             BiConsumer<String[], List<T>> visitor) {
        if (node.data != null) {
            visitor.accept(strings.toArray(String[]::new), List.copyOf(node.data));
        }
        if (node.map != null) {
            node.map.forEach((s, n) -> {
                strings.push(s);
                recursivelyVisit(n, strings, visitor);
                strings.pop();
            });
        }
    }

    @NotNull @Modified @Only(before = "freeze")
    public void add(@NotNull1 String[] strings, @NotNull T t) {
        if(frozen) throw new UnsupportedOperationException("Already frozen");

        TrieNode<T> node = root;
        for (String s : strings) {
            TrieNode<T> newTrieNode;
            if (node.map == null) {
                node.map = new HashMap<>();
                newTrieNode = new TrieNode<>();
                node.map.put(s, newTrieNode);
            } else {
                newTrieNode = node.map.get(s);
                if (newTrieNode == null) {
                    newTrieNode = new TrieNode<>();
                    node.map.put(s, newTrieNode);
                }
            }
            node = newTrieNode;
        }
        if (node.data == null) node.data = new LinkedList<>();
        node.data.add(Objects.requireNonNull(t));
    }

    @Modified @Mark("freeze")
    public void freeze() {
        if(frozen) throw new UnsupportedOperationException("Already frozen");

        frozen = true; // <3>
    }
}
----
<1> {nn1} here means that `strings` cannot be null, and neither can it hold null elements.
Because the type is a container, the implicit `@NotModified` annotation guarantees that the trie will not write to the array.
<2> {nn2} here means that the `visitor` should not be null, but also that the data offered to the visitor will not be null, and neither will its content.
<3> Once true, there is no way to change `frozen` back to false.
After this state change, the trie object becomes effectively level 2 immutable because the modifying methods cannot be called anymore.

Until the user of this trie calls the `freeze` method, elements can be added via the `add` and `getOrCompute` methods.
Visiting the trie can be done at any time; the `visit` method offers the elements for consumption via the `BiConsumer` parameter.
Verifying that the trie is level 2 immutable, we observe that, after having called `freeze`,

. all fields are `@NotModified`;
. `freeze` is a primitive, so rules 2 and 3 do not apply;
. rules 2 and 3 do apply to `root`, as it is of a type (`TrieNode`) which holds one of the types in the parameters of public methods (`T`).
The field is private, so rule 2 is easily satisfied.
There are no constructors with parameters, so we only have to show that the public non-modifying methods return objects that are independent of the `root` field.
+
Looking at the remaining accessible methods, `get` and `visit`, we observe that the code returns immutable copies of the data, which are independent.
(Note that they are independent _by annotation_ rather than _by definition_: we have manually annotated the `copyOf` method to return a level 2 immutable object, which is independent.)

When freezing a data structure with modifiable sub-structures, there are generally two ways to go about making them independent: turning them into immutable objects at the moment of freezing, or returning copies on-demand.
The user needs to carry out a dynamic code analysis to find out which approach will be most performant.

// leave an empty line!
