== Level 2 immutability

=== Definition

First, what do we want intuitively?
A useful form of immutability, less strong than deeply immutable, but better than level 1 immutability for many situations.
We propose the following:

****
After construction, an immutable type holds a number of objects; the type will not change their content, nor will it exchange them for other objects, or allow others to do so.
The type is not responsible for what others do to the content of the objects it has been given.
****

Technically, level 2 immutability is much harder to define than level 1 immutability.
We identify three rules, on top of the obvious level 1 immutability requirement.
One of these must be observed at all times:

****
*Definition*: the *first rule of level 2 immutability* is that all fields must be {nm}.
****

Our friend the `Pair` satisfies this first rule:

[source,java]
----
@E1Container
public class Pair<K,V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Note that since `K` and `V` are unbound generic types, it is not possible to modify their content from inside `Pair`, since there are no modifying methods one can call on unbound types.

How does it fit the intuitive rule for immutability?
The type `Pair` holds two objects.
The type does not change their content, nor will it exchange these two objects for others, or allow others to do so.
It is clear the users of `Pair` may be able to change the content of the objects they put in the `Pair`.
Summarizing: `Pair` fits the intuitive definition without any problem.

Here is an example which shows the necessity of the first rule more explicitly:

[source,java]
----
@Container
class Point {
    @Variable
    private double x;

    @Variable
    private double y;

    @NotModified
    public double getX() {
        return x;
    }

    @Modified
    public void setX(double x) {
        this.x = x;
    }

    @NotModified
    public double getY() {
        return y;
    }

    @Modified
    public void setY(double y) {
        this.y = y;
    }
}

class Line {
    @Final
    private Point point1;

    @Final
    private Point point2;

    public Line(Point point1, Point point2) {
        this.point1 = point1;
        this.point2 = point2;
    }

    @NotModified
    public Point middle() {
        return new Point((point1.getX() + point2.getX())/2.0,
             (point1.getY()+point2.getY())/2.0);
    }

    @Modified
    public void translateHorizontally(double x) {
        point1.setX(point1.getX() + x); // <1>
        point2.setX(point2.getX() + x);
    }
}
----
<1> Modifying operation on `point1`.

The fields `point1` and `point2` are effectively final.
Without the translation method, the fields would be {nm} as well.
The translation method modifies their content, rendering the type not level 2 immutable.

Assuming a type's goal is to store a number of objects, it is easy to see that a level 1 immutable type cannot hold additional, modifiable state.
It follows that every method call on the container object with the same arguments will render the same result.
(Note that this can be bypassed in Java by using _static_ state, i.e., state specific to the type rather than the object.
Let us ignore that for now.)

In order to hold an arbitrary (or even modestly large) amount of objects, a type has to have 'support data': think an array, a tree structure, buckets for a hash table, etc.
The difference between effectively final fields and the rest of the definition of level 2 immutability is essentially about expressing the immutability of the support data.
After construction, a level 2 immutable type will still hold a fixed number of objects, and the type will not change their content, nor exchange them for other objects, nor allow others to exchange them.

We will introduce two additional rules to the definition of level 2 immutability.
They will only have to be satisfied by _some_ fields; requiring them for all fields results in too strong a definition, and we have seen higher up that there are situations where the first rule is sufficient.
The fields we target with those additional rules are the fields containing the support data.
For now, we try to catch the support data with the following, most likely imperfect rule:

****
If _A_ is the type of a field, and type _B_, which is held by _A_, appears as type of parameter or as return type in non-private methods (directly, or held by a different type _C_), then we need the level 2 immutability rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.

A type _B_ is held by the type _A_ if _B_ is the type of a field in _A_, directly or via generics or arrays, and potentially transitively.
****

Many examples will follow, but it should be clear from the description that types that appear both in fields and in non-private methods, do not need to satisfy rules 2 and 3. This is the case for `Pair`.

We now write rules 2 and 3 as:

****
*Definition: level 2 immutability*: additional rules for support data types.

*Rule 2*: a field is either private, or level 2 immutable itself (by type or dynamic annotation).

*Rule 3*: all constructors and non-private methods are {independent} of the fields of support data types.
****

Rule 2 is there to ensure that the content of the object cannot be modified by means of access to the non-private fields.
Rule 3 ensures that the content of the object cannot be modified externally.

The first rule can be reached _eventually_ if there is one or more methods that effect a transition from the mutable to the immutable state.
This typically means that all methods that assign or modify fields become off-limits after calling this marker method.
Eventuality for rules 2 and 3 seems too far-fetched.
More on this topic in the section on eventual immutability.

Let us go to examples immediately.

.Example with array, v1
[source,java]
----
class ArrayContainer1<T> {
    private final T[] data;
    public ArrayContainer1(T[] ts) {
        this.data = ts;
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

After creation, changes to the source array `ts` are effectively changes to the data array `data`.
This construct fails rule 3, independence.
Here the array of type `T[]` is the support data that holds `T`, which also appears in the return type of the `stream` method, held by `Stream`.

.Example with array, v2, still not OK
[source,java]
----
class ArrayContainer2<T> {
    public final T[] data;
    public ArrayContainer2(T[] ts) {
        this.data = new T[ts.length];
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

Users of this type can modify the content of the array using direct field access!
This construct fails rule 2, which applies for the same reasons as in the previous example.

.Example with array, v3, safe
[source,java]
----
class ArrayContainer3<T> {
    private final T[] data; // <1>
    public ArrayContainer3(T[] ts) {
        this.data = new T[ts.length]; // <2>
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> The array is private, and therefore protected from modification.
<2> The array has been copied, and therefore is independent of the one passed in the parameter.

The independence rule enforces the type to have its own structure rather than someone else's.
Here's the same group of example, now with JDK Collections:

.Example with collection, v1
[source,java]
----
class SetBasedContainer1<T> {
    private final Set<T> data;
    public SetBasedContainer1(Set<T> ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> After creation, changes to the source set are effectively changes to the data.

.Example with collection, v2, still not OK
[source,java]
----
class SetBasedContainer2<T> {
    public final Set<T> data; // <1>
    public SetBasedContainer2(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> Users of this type can modify the content of the set after creation!

.Example with set, v3, safe
[source,java]
----
class SetBasedContainer3<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> The set is private, and therefore protected from external modification.
<2> The set has been copied, and therefore is independent of the one passed in the parameter.

.Example with set, v4, safe
[source,java]
----
class SetBasedContainer4<T> {
    public final ImmutableSet<T> data; // <1>
    public SetBasedContainer4(Set<T> ts) {
        this.data = ImmutableSet.copyOf(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> the data is public, but the `ImmutableSet` is {e2immutable} itself.
<2> Independence guaranteed.

The independence rule 3 is there to ensure that the type does not expose its support data through parameters and return types:

.Example with set, v5, unsafe
[source,java]
----
class SetBasedContainer5<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer5(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Set<T> getSet() {
        return data; // <3>
    }
}
----
<1> No exposure via the field
<2> No exposure via the parameter of the constructor
<3> ... but exposure via the getter.
We could as well have made the field `public final`.

Note that by decomposing all definitions, we observe that requiring all fields to be {final} and {nm} is equivalent to requiring that all non-private fields have the `final` modifier, and that methods that are not part of the construction phase, are {nm}.

The following type is {container}, the field is {final}, but it is not {nm}:

[source,java]
----
class Example2 {
    @Final
    @Modified
    public final Set<T> set = new HashSet<>();

    @Modified
    public void add(T t) { set.add(t); }

    @NotModified
    public Stream<T> stream() { return set.stream(); }
}
----

[#dynamic-type-annotations]
=== Dynamic type annotations

When it is clear a method returns an immutable set, but the formal type is `java.util.Set`, the {e2immutable} annotation can 'travel':

The computations that the analyser needs to track dynamic type annotations, are similar to those it needs to compute eventual immutability.
We introduce them in the next chapter.
