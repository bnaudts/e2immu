[#modification-part2]
== Modification, part 2

=== Indirect modifications

Time for more fine print on modifications.
We need to revisit the situation of non-modifying methods with modifying parameters.
Up to now, a method is only modifying when it assigns to a field, calls a modifying method on one of the fields, or directly calls a modifying method on `this`.
However, there could be indirect modifications, as in:

.Indirect modifications
[source,java]
----
@E2Container
public class ModificationGraphChecks {

    @MutableModifiesArguments
    static class C1 {

        @Variable
        private int i;

        @Modified
        public int incrementAndGet() {
            return ++i;
        }

        @Modified // <1>
        public int useC2(@Modified C2 c2) {
            return i + c2.incrementAndGetWithI();
        }

    }

    @E1Immutable
    static class C2 {

        private final int j;

        @Modified
        private final C1 c1;

        public C2(int j, @Modified C1 c1) {
            this.c1 = c1;
            this.j = j;
        }

        @Modified
        public int incrementAndGetWithI() {
            return c1.incrementAndGet() + j;
        }
    }
}
----
<1> `useC2` does not directly modify `i`, but `incrementAndGetWithI` does so indirectly.

This observation forces us to tighten the definition of a non-modifying method: on top of the definition given above, we have to ensure that none of the modifying methods called on a parameter which is {modified}, none of the modifying methods c, recursively, does not call one of 'our' modifying methods.

These rules are mostly, but not easily, computable when all code is visible.

=== Parameters of abstract and interface types

When the parameter is of an interface type, and no declarations are present, complications arise.
Starting with an example, we realise that the single abstract method in `Consumer` is, in general, modifying, and that it modifies its parameter:

[source,java]
----
@FunctionalInterface
public interface Consumer<T> {
    @Modified
    void accept(@Modified T t);
    // ...
}
----

However, if we now use this consumer in the example of the `forEach` method of `Collection`:

.Possible implementation of forEach
[source,java]
----
default void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

it immediately follows that:

. the parameter `consumer` is {modified}, because `accept`, as modifying method, runs on this object;
. the method `forEach` is {modified}, as `t` is linked to `this` and `t` is modified by `accept`.

The first observation is a problem to make containers, because a container does not allow methods to modify their parameters.
The second problem occurs when creating level 2 immutable types, where the consumers have no means for modifying the fields, even though `accept` claims it does.

There is an obvious need to solve both problems, because semantically, there is little difference between iterating using a `forEach` method, and using a `getStream` as in:

[source,java]
----
default Stream<E> stream() {
    return StreamSupport.stream(spliterator(), false);
}
----

Creating a stream is non-modifying.
The code that pulls from this stream is completely outside the scope of the analysis of the `Collection` type; it is free to modify `E` objects at will.

Firstly, we decide that parameters of abstract and interface types are {nm}.
Modifications they make to the fields of the class can only be made through methods which are already {modified}; this will not change the overall modification status of the type.
As a first consequence, we need not look at indirect modifications (which would be nigh on impossible anyway), implying that abstract and interface type parameters have no impact on the modification status of the method.
Secondly, we do not need to change our definition of containers, which requires parameters that are {nm}.

The second change we make is to align the exposure of fields and parts of the fields' object graph to the unknown code of the interface implementation, with the exposure via return values:

. support data sent into abstract methods will need to be independent of the fields, so that the assumed modifications to the parameter do not impact the fields
. modifications to non-support-data will be ignored.

So in effect, the parameter of the `accept` method is modifying _only_ for support data.
Making the consumer {nm1} forces absence of modifications on the parameters in the implementation; making the consumer {independent} allows support data as arguments while retaining level 2 immutability.
The annotation {nn1} implies that null arguments will cause exceptions; the analyser will warn against them.

Implementing a visitor using the `forEach` method defined as:

.Annotated definition of forEach.
[source,java]
----
@NotModified
default void forEach(@NotModified Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

renders code like:

.Example use of forEach.
[source,java]
----
@SupportData
private Set<T> set;

public void add(T t) { set.add(t); } // T is not support data!

...

@NotModified
public void visit(@NotModified Consumer<T> consumer) {
    set.forEach(consumer);
}

@NotModified
public void copy(@Independent Consumer<Set<T>> consumer) {
    consumer.accept(new HashSet<>(set));
}
----

=== Lambdas

As `forEach` is iterating over the elements of some `Iterable`, the consumer should not make any attempts at modifying the iterable.
Doing so will result in a `ConcurrentModificationException`:

[source,java]
.Modifying the list being iterated over
----
public class ExampleManualSelfModificationOnForEach {

    @Test
    public void testDangerous() {
        List<String> l1 = new ArrayList<>();
        Collections.addAll(l1, "a", "c", "e");
        try {
            print(l1);
            Assert.fail();
        } catch(ConcurrentModificationException cme) {
            // OK
        }
    }

    static void print(List<String> list) {
        list.forEach(l -> {
            System.out.println(l);
            if (l.startsWith("a")) {
                list.add("b"); // <1>
            }
        });
    }
}
----
<1> The offending modifying method.

The {nm} annotation on `forEach` does prevent the `list.add` method to be called, because the lambda block in the first statement of `print` fully declares the code of the consumer.
