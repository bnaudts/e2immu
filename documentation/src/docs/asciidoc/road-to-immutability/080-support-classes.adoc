[#support-classes]
== Support classes

Eventually immutable building blocks.

[#support-flipswitch]
=== FlipSwitch


[#support-setonce]
=== SetOnce


[#support-eventuallyfinal]
=== EventuallyFinal


[#support-lazy]
=== Lazy

`Lazy` implements a lazily-initialized immutable field, of unbound generic type `T`.
As such, it is eventually a level 2 immutable type.

.Code fragment: The code analyser's Lazy type
[source,java]
----
package org.e2immu.analyser.util;

import org.e2immu.annotation.*;
import java.util.Objects;
import java.util.function.Supplier;

@E2Container(after = "get")
public class Lazy<T> {

    @NotNull1
    @NotModified
    private final Supplier<T> supplier;

    @Final(after = "get")
    private volatile T t;

    public Lazy(@NotNull1 @NotModified Supplier<T> supplier) { // <1>
        this.supplier = supplier;
    }

    @NotNull
    @Mark("get", type = CONTRACT) // <2>
    public T get() {
        T localT = t;
        if (localT != null) return localT;

        synchronized (this) {
            if (t == null) {
                t = Objects.requireNonNull(supplier.get()); // <3>
            }
            return t;
        }
    }

    @NotModified
    public boolean hasBeenEvaluated() {
        return t != null;
    }
}
----
<1> Note that {nm1} is irrelevant: suppliers do not take parameters, so they cannot modify them.
The annotation {nm} comes naturally, because `T` is of unbound generic type and `Lazy` cannot change its content.
<2> The `@Mark("xx")` annotation as detected by the analyser currently implies `@Only(before="xx")`.
This cannot be the case here, as users will call the `get` method repeatedly.
For now, the {mark} annotation will have to be added by hand.
<3> Here `t` links to `supplier`, as explained in <<linking-part2>>.
The statement also causes the {nn1} annotation, as defined in <<nullable-section>>.

After calling the marker method `get()`, `t` cannot be assigned anymore, and it becomes {final}.
Because it is of an unbound generic type, it is {nm}, as is the field `supplier`.
Level 2 immutability rules 2 and 3 do not apply for either fields.

[#support-firstthen]
=== FirstThen

[source,java]
----
package org.e2immu.analyser.util;

import org.e2immu.annotation.*;
import java.util.Objects;

@E2Container(after = "mark")
public class FirstThen<S, T> {
    private volatile S first;
    private volatile T then;

    public FirstThen(@NotNull S first) {
        this.first = Objects.requireNonNull(first);
    }

    @NotModified
    public boolean isFirst() {
        return first != null;
    }

    @NotModified
    public boolean isSet() {
        return first == null;
    }

    @Mark("mark")
    public void set(@NotNull T then) {
        Objects.requireNonNull(then);
        synchronized (this) {
            if (first == null) throw new UnsupportedOperationException("Already set");
            this.then = then;
            first = null;
        }
    }

    @NotNull @NotModified @Only(before = "mark")
    public S getFirst() {
        if (first == null)
            throw new UnsupportedOperationException("Then has been set"); // <1>
        S s = first;
        if (s == null) throw new NullPointerException();
        return s;
    }

    @NotNull @NotModified @Only(after = "mark")
    public T get() {
        if (first != null) throw new UnsupportedOperationException("Not yet set"); // <2>
        T t = then;
        if (t == null) throw new NullPointerException();
        return t;
    }

    @Override // <3>
    public boolean equals(@Nullable Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FirstThen<?, ?> firstThen = (FirstThen<?, ?>) o;
        return Objects.equals(first, firstThen.first) &&
                Objects.equals(then, firstThen.then);
    }

    @Override // <3>
    public int hashCode() {
        return Objects.hash(first, then);
    }
}
----
<1> This is a bit convoluted.
The precondition is on the field `first`, and the current implementation of the precondition analyser requires an explicit check on the field.
Because this field is not final, we cannot assume that it is still null after the initial check; therefore, we assign it to a local variable, and do another null check to guarantee that the result that we return is `@NotNull`.

<2> Largely in line with the previous comment: we stick to the precondition on `first`, and have to check `then` to guarantee that the result is `@NotNull`.
<3> The `equals` and `hashCode` methods inherit the {nm} annotation from `java.lang.Object`.

Note that if we were to annotate the methods as contracts, rather than relying on the analyser to detect them, we could have a slightly more efficient implementation.


