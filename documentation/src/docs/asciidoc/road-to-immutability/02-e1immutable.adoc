== Level 1 immutability

Let us start with a definition:

****
*Definition*: We say a field is *effectively final* when it either has the modifier `final`, or it is not assigned to in methods that can be transitively called from non-private (non-constructor) methods.
****

The code analyser annotates with `@Final` in the latter case; there is no point in cluttering with an annotation when the modifier is already there.
It annotates fields that are not effectively final with `@Variable`.

This definition allows effectively final fields to be assigned in methods accessible only from the constructor:

.Example 1, effectively final, but not with the `final` modifier
[source,java]
----
class EffectivelyFinal1 {
    @Final
    private Random random;

    public EffectivelyFinal1() {
        initialize(3L);
    }

    private void initialize(long seed) {
        random = new Random(seed);
    }

    // no methods access initialize()

    public int nextInt() {
        return random.nextInt();
    }
}
----

Obviously, if the same method is also accessible after construction, the field becomes variable:

.Example 2, the method setting the field is accessible after construction
[source,java]
----
class EffectivelyFinal2 {
    @Variable
    private Random random;

    public EffectivelyFinal2() {
        reset();
    }

    public void reset() {
        initialize(3L);
    }

    private void initialize(long seed) {
        random = new Random(seed);
    }

    public int nextInt() {
        return random.nextInt();
    }
}
----

Note that it is perfectly possible to rewrite the first example in such a way that the `final` modifier can be used.
From the point of view of the code analyser, this does not matter.
The wider definition will allow for more situations to be recognized for what they really are.

When an object consists solely of primitives, or deeply immutable objects such as `java.lang.String`, having all fields effectively final is sufficient to generate an object that is again deeply immutable.

.Example 3, an object consisting of primitives and a string.
[source,java]
----
class DeeplyImmutable1 {
    public final int x;
    public final int y;
    public final String message;

    public DeeplyImmutable1(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }
}
----

.Example 4, another way of being effectively final
[source,java]
----
class DeeplyImmutable2 {
    @Final
    private int x;
    @Final
    private int y;
    @Final
    private String message;

    public DeeplyImmutable2(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }

    public String getMessage() {
        return message;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
----

Examples 3 and 4 are functionally equivalent: there is no way of changing the values of the fields once they have been set.
In the real world there may be a reason why someone requires the getters.
Or, you may be given code as in Example 2, but you are not allowed to change it.
Whatever the reason, the code analyser should recognize effective finality.

Note that we will not make a distinction between any of the different non-private access modes in Java.
Only the private modifier gives sufficient guarantees that no reassignment to the fields is possible.

We now have observed that for the purpose of defining immutability, having all your fields effectively final can be sufficient in certain circumstances.
We use this as the basis for the first level of immutability:

****
*Definition*: We call a type *effectively level 1 immutable* when all its fields are effectively final.
****

The code analyser annotates level 1 immutable types with `@E1Immutable`.
Types that are not `@E1Immutable` because they have at least one `@Variable` field, are annotated `@Mutable`.

As above with effective finality, the term _effective_ is present to make a distinction between formal immutability, and immutability that the code analyser computes.
It will also serve to distinguish from _eventual_ immutability, where (in this case) the finality will be achieved only after the code reaches a certain state.
More on this later, but here is a first example of an eventually level 1 immutable type:

.Simplified version of `SetOnce`
[source,java]
----
@E1Immutable(after="set")
class SetOnce<T> {
    private T t;

    @Mark("set")
    public void set(T t) {
        if(t == null) throw new NullPointerException();
        if(this.t == null) throw new UnsupportedOperationException("Already set");
        this.t = t;
    }

    @Only(after="set")
    public void get() {
        if(t == null) throw new UnsupportedOperationException("Not yet set");
        return t;
    }
}
----

Once a value has been set, the field `t` cannot be assigned anymore.

We have just observed that if one restricts to primitives and types like `java.lang.String`, level 1 immutability is sufficient to guarantee deep immutability.
It is not feasible (and we do not wish to) work only with deeply immutable objects.
Moreover, it is easy to see that level 1 immutability is not enough to guarantee what we intuitively may think immutability stands for:

.Example 5, level 1 immutability does not guarantee intuitive immutability
[source,java]
----
@E1Immutable
class StringsInArray {
    private final String[] data;
    public StringsInArray(String[] strings) {
        this.data = strings;
    }
    public String getFirst() {
        return data[0];
    }
}

...
String[] strings = { "a", "b" };
StringsInArray sia = new StringsInArray(strings);
Assert.assertEquals("a", sia.getFirst());
strings[0] = "c"; // <1>
Assert.assertEquals("c", sia.getFirst()); // <2>
----
<1> External modification of the array.
<2> As a consequence, the data structure has been modified.

To continue, we must first understand the notion of modification.

== Modification

****
*Definition*: a method is *modifying* if it causes an assignment in the object graph of the fields of the object it is applied to.
****

We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.

Consequently, a method is not modifying if it only reads from the object graph of the fields.
The code analyser uses the annotations `@NotModified` and `@Modified`.
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we avoid clutter by not annotating them.

For clarity, we repeat that directly assigning to the fields also constitutes a modification.
As a consequence, setters are `@Modified`, while getters are `@NotModified`:

[source,java]
----
@Mutable
class Message {
    @Variable
    private String message;

    @NotModified
    public String getMessage() {
        return message;
    }

    @Modified
    public void setMessage(String message) {
        this.message = message;
    }
}

class Example2 {
    @Final
    @Modified
    private final Message message = new Message();

    public Example2() {
        message.setMessage("No message yet");
    }

    @Modified
    public void inform(String info) {
        this.message.setMessage(info);
    }
}
----

We also see in the example that the `inform` method is `@Modified`.
This is because it calls a modifying method on one of the fields: `setMessage`.

The code analyser annotates a parameter with `@NotModified` when the parameter's method does not apply assignments or modifying methods on the object that enters the method via the parameter.
This restriction holds in the strongest possible way, a topic which we will elaborate on later.
If a parameter is not `@NotModified`, it is `@Modified`.

We will apply exactly the same reasoning to a field.
A field will be annotated `@NotModified` when none of the type's methods, transitively reachable from a non-private non-constructor method, applies assignments or modifying methods on this field.
This restriction again holds in the strongest possible way.
If a field is not `@NotModified`, it is `@Modified`.

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all `@NotModified`.
This is pretty obvious in the case of `toString`, `hashCode`, `getClass`.
It is less obvious for the `wait` and other synchronization-related methods, but remember that as a general rule, we exclude synchronization support from this discussion.

Note also that we cannot add modifying methods to the type `DeeplyImmutable1` in Example 3.

For clarity, let's also look at (a part of) the `Collection` interface, where we've restricted the annotations to `@NotModified` and `@Modified`:

.Showing the modification status of methods in the `Collection` interface
[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.

Adding all elements of a collection to the object (in `addAll`) should not modify the input collection, whence the `@NotModified`.
Other types in the parameters do not have a `@NotModified` annotation:

* `Object` because it is deeply immutable,
* `E` because it is of an unbound generic type, it has the same methods available as `Object`,
* `Consumer` because it is a functional type (an interface with only one abstract method), which is always `@NotModified`, as detailed further on.

The rules for not having to write `@NotModified` will be detailed later, but this example pretty much covers all the bases.

=== Functional types

The type `Consumer<? super E>` in the `forEach` method of `Collection<E>` is defined as:

.Relevant part of definition of Consumer
[source,java]
----
interface Consumer<T> {
    void accept(T t);
}
----

It could be used, for example, like:

[source,java]
----
void addOne(Collection<Set<String>> sets, List<String> stringSource) {
    sets.forEach(set -> {
        if(!stringSource.isEmpty()) set.add(stringSource.remove(0));
    });
}
----

The (hidden) `accept` method takes a set of strings, and modifies this set.
Without the syntactic sugar, this reads:

[source,java]
----
void addOne(Collection<Set<String>> sets, List<String> stringSource) {
    Consumer<Set<String>> consumer = new Consumer<>() {
        void accept(Set<String> set) {
            if(!stringSource.isEmpty()) set.add(stringSource.remove(0));
        }
    }
    sets.forEach(consumer);
}
----

The `forEach` method is modifying the individual sets, but it does not change the collection `sets` itself, which is why we marked the method {nm}.
Neither does `forEach` change the functional type itself, which is why we (implicitly) annotated the `Consumer` parameter with `@NotModified`.
However, this particular implementation of `accept` is modifying its input, causing the `sets` parameter to be modified.

Reshuffling yields:

[source,java]
----
List<String> stringSource = ...
Consumer<Set<String>> consumer = new Consumer<>() {
    void accept(Set<String> set) {
        if(!stringSource.isEmpty()) set.add(stringSource.remove(0));
    }
};
...

void addOne(Collection<Set<String>> sets, Consumer<Set<String>> consumer) {
    sets.forEach(consumer);
}
----

If the `consumer`'s `apply` is modifying, then `sets` will be modified.
If it is not modifying, for example, in the case of the consumer `String.out::println`, then `sets` will not be modified.
We cannot realistically compute this using a static analyser.
This is the point where the programmer needs to _show intent_ by manually adding a contract annotation on the `consumer` parameter to indicate that its method is non-modifying:

[source,java]
----
void addOne(Collection<Set<String>> sets,
            @NotModified1(type = CONTRACT) Consumer<Set<String>> consumer) {
    sets.forEach(consumer);
}
----

This annotation and the use of `...1` at the end is in line with `@NotNull1`, detailed in <<nullable-section>>, which guarantees that the parameter values of the `apply` method are never null.

Once the contract annotation is in place, the analyser computes that `sets` is {nm}, that `addOne` is not a modifying method, and that, because the method does not access any fields nor overrides another method, it should be made static.

We conclude this section with the locality principle for modifications:

****
*Locality principle*: the modifications that a parameter of functional type can effect are outside the analysable scope:
in the `void forEach(Consumer<? super E> action)` method of `Collection<E>`, it is _possible_ to use the method to modify `E`.
But this must happen outside the scope of the interface or its implementations, and will be annotated if it happens.
This will form the basis of the definition of a {container} in one of the next chapters.
****

// ensure a newline at the end
