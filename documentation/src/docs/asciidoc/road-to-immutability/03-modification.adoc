== Modification

=== Definition

****
*Definition*: a method is *modifying* if it causes a computable assignment in the object graph of the fields of the object it is applied to.
****

We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.
In the case of functional types, this includes their closure.
The adjective _computable_ is there to indicate that the modification must be made with code statically visible when analysing the type.

Consequently, a method is not modifying if it only reads from the object graph of the fields.
The code analyser uses the annotations {nm} and {modified}.
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we avoid clutter by not annotating them.

For clarity, we repeat that directly assigning to the fields also constitutes a modification.
As a consequence, setters are {modified}, while getters are {nm}.
Consider:

[source,java]
----
class Counter {
    private int counter;

    @NotModified
    public int getCounter() {
        return counter;
    }

    @Modified
    public int increment() {
        counter += 1;
        return counter;
    }
}

class CountedInfo {
    @Final
    @Modified
    private final Counter counter = new Counter();

    @Modified
    public void printInfo(String info) {
        System.out.println("Message " + counter.increment() + ": "+info);
    }
}
----

We also see in the example that the `printInfo` method is {modified}.
This is because it calls a modifying method on one of the fields: `increment`.

****
*Definition of modification to a parameter*:
The code analyser annotates a parameter with {nm} when the parameter's method does not apply assignments or modifying methods on the object that enters the method via the parameter.
This restriction holds with respect to the parameter's entire object graph.
If a parameter is not {nm}, it is {modified}.
****

We will apply a similar reasoning to a field:

****
*Definition of modification to a field*:
A field will be annotated {nm} when none of the type's methods, transitively reachable from a non-private non-constructor method, applies assignments or modifying methods on this field.
If a field is not {nm}, it is {modified}.
****

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all {nm}.
This is pretty obvious in the case of `toString`, `hashCode`, `getClass`.
It is less obvious for the `wait` and other synchronization-related methods, but remember that as a general rule, we exclude synchronization support from this discussion.

Note also that we cannot add modifying methods to the type `DeeplyImmutable1` in Example 3.

Proceeding, let us also look at (a part of) the `Collection` interface, where we've restricted the annotations to {nm} and {modified}.
While in normal classes the analyser computes the annotations, in interfaces the user stipulates or _contracts_ behaviour by annotating:

[#collection-interface]
.Modification aspects of the Collection interface
[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.

Adding all elements of a collection to the object (in `addAll`) should not modify the input collection, whence the {nm}.
Other types in the parameters have not been annotated with {nm}:

* `Object` because it is deeply immutable;
* `E` because it is of an unbound generic type, it has the same methods available as `Object`.
No code statically visible to implementations of `Collection` can make modifications to `E`;
* `Consumer` because it is a functional type (an interface with only one abstract method).
Arbitrary code, as opposed to statically visible code, can be executed from within the type via parameters of functional type.

The next section will delve deeper into parameters of functional types.

[#functional-types]
=== Functional types, part 1

The type `Consumer<? super E>` in the `forEach` method of `Collection<E>` is defined as:

.Relevant part of definition of Consumer
[source,java]
----
interface Consumer<T> {
    void accept(T t);
}
----

The type `Collection` could implement `forEach` as:

.Possible implementation of forEach
[source,java]
----
void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

This method should clearly be non-modifying: it should simply iterate over the elements of the collection, _without modifying the fields of the collection object_.
Note that this means that implementations of `Collection` cannot have code statically present to make changes to the collection's object graph, which contains the `T` elements.
Given that to that code, `T` has no modifying methods, this works out fine: it cannot make changes to the elements it holds, and it should not make changes to the collection structure.

The `consumer` parameter of the `forEach` method can have a modifying single abstract method, or not.
This does not depend on whether `accept` modifies its parameter `t`, because this incoming parameter is not part of the object graph of the functional type.
It depends on whether `accept` makes modifications to its closure.

So applying functional types can be modifying or non-modifying; at the same time, applying them may cause modifications to the input sent to the parameters.
We must make a distinction between these two types of modifications.
For the purpose of `Collection`, modifications to the closure of the functional type are not that relevant.
Modifications to the parameter are, because the collection holds the values fed into the parameter.

.With annotation on the parameter
[source,java]
----
@NotModified
@Independent
void forEach(@NotModified1 Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

By annotating the parameter with {nm1}, we instruct the analyser to ensure that `forEach` cannot be called with functional types that modify their parameters.
The analyser uses the {independent} annotation to mark that the fields of the type remain independent of the consequences of applying the parameter.

Without the annotation, we allow for some implementations of the consumer to make modifications to the parameters:

.Without annotation on the parameter
[source,java]
----
@NotModified
@Dependent
void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

In this case, the modifications take place in code not visible to the analyser when it studies the implementation of `Collection`.
The analyser uses the {dependent} annotation to mark that the fields of the type link to the parameters of the method.
#TODO needs additional linking rule# The mechanics of linking and (in)dependence will be explained in <<linking-and-independence>>.

We clarify with the following examples, making use of the `Counter` class defined a bit higher:

.Different ways of applying forEach
[source,java]
----
class ConsumerUse {
    private static final Consumer<Counter> incrementer = Counter::increment;

    @NotModified1
    private static final Consumer<Counter> printer = counter -> {
        System.out.println("Counts to " + counter.getCounter());
    };

    static void incrementAll(@Modified Collection<Counter> counters) {
        counters.forEach(incrementer);
    }

    static void println(@NotModified Collection<Counter> counters) {
        counters.forEach(printer);
    }

    static void doSomethingModifying(@Modified Collection<Counter> counters,
            Consumer<Counter> consumer) {
        counters.forEach(consumer); // .forEach(c -> consumer.accept(c))
    }

    static void doSomethingNonModifying(@NotModified Collection<Counter> counters,
            @NotModified1(type = CONTRACT) Consumer<Counter> consumer) {
        counters.forEach(consumer);
    }

    static void forEach(@NotModified Collection<String> strings, Consumer<String> consumer) {
        strings.forEach(consumer);
    }
}
----

In the first two methods, the analyser knows which `Consumer` object will be handed to `forEach`.
It finds that in the first method the collection's object graph containing the counters will be modified.
In the second method, the same object graph will remain unchanged.

How does it do this?
By definition, for the parameter `counters` to be {modified} a modifying method needs to be applied to it.
This does not happen: `forEach` as a method is not modifying.
However, `forEach` feeds the elements of the collection into a modifying `accept` method.
As such, the object graph of the collection, containing the individual elements, changes.

How does the analyser know that `forEach` has the possibility to modify the content of its collection?
The {dependent} annotation on `forEach` links the consumer to the scope object of `forEach`: `counters`.
Because the argument to `forEach`, `incrementer`, is not explicitly {nm1}, it has to assume that modifications propagate into `counters`.
In the second case, the argument, `printer`, is explicitly {nm1}, which prevents modifications to take place because of the `forEach` method call.

In the third and fourth method, however, the implementation of the consumer comes from outside the type.
We cannot know whether the consumer will modify the collection's object graph.
In the fourth method, by annotating with {nm1}, the user shows intent, and asks the analyser to make sure the consumer's `accept` method is non-modifying.
As a consequence, the analyser computes that `counters` is {nm}.
In the third method this intent is absent, and the analyser must conclude that `doSomethingModifying` modifies `counters`.

The fifth case is very similar to the original `forEach` method.
Because strings are deeply immutable, we know that no consumer can change the individual strings, and we know that `forEach` as a method is not modifying.

Note that the use of `...1` at the end of {nm1}, indicating _one level down_, is in line with {nn1}, an annotation detailed in <<nullable-section>>, which guarantees that the object and its content, in this case, the object and the parameter values of the `apply` method, are never null.


// ensure a newline at the end
