== Modification

=== Definition

****
*Definition*: a method is *modifying* if it causes an assignment in the object graph of the fields of the object it is applied to.
****

We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.

Consequently, a method is not modifying if it only reads from the object graph of the fields.
The code analyser uses the annotations {nm} and {modified}.
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we avoid clutter by not annotating them.

For clarity, we repeat that directly assigning to the fields also constitutes a modification.
As a consequence, setters are `@Modified`, while getters are `@NotModified`:

[source,java]
----
class Message {
    @Variable
    private String message;

    @NotModified
    public String getMessage() {
        return message;
    }

    @Modified
    public void setMessage(String message) {
        this.message = message;
    }
}

class Example2 {
    @Final
    @Modified
    private final Message message = new Message();

    public Example2() {
        message.setMessage("No message yet");
    }

    @Modified
    public void inform(String info) {
        this.message.setMessage(info);
    }
}
----

We also see in the example that the `inform` method is `@Modified`.
This is because it calls a modifying method on one of the fields: `setMessage`.

The code analyser annotates a parameter with `@NotModified` when the parameter's method does not apply assignments or modifying methods on the object that enters the method via the parameter.
This restriction holds in the strongest possible way, a topic which we will elaborate on later.
If a parameter is not `@NotModified`, it is `@Modified`.

We will apply exactly the same reasoning to a field.
A field will be annotated `@NotModified` when none of the type's methods, transitively reachable from a non-private non-constructor method, applies assignments or modifying methods on this field.
This restriction again holds in the strongest possible way.
If a field is not `@NotModified`, it is `@Modified`.

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all `@NotModified`.
This is pretty obvious in the case of `toString`, `hashCode`, `getClass`.
It is less obvious for the `wait` and other synchronization-related methods, but remember that as a general rule, we exclude synchronization support from this discussion.

Note also that we cannot add modifying methods to the type `DeeplyImmutable1` in Example 3.

For clarity, let's also look at (a part of) the `Collection` interface, where we've restricted the annotations to `@NotModified` and `@Modified`:

.Showing the modification status of methods in the `Collection` interface
[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.

Adding all elements of a collection to the object (in `addAll`) should not modify the input collection, whence the `@NotModified`.
Other types in the parameters do not have a `@NotModified` annotation:

* `Object` because it is deeply immutable,
* `E` because it is of an unbound generic type, it has the same methods available as `Object`,
* `Consumer` because it is a functional type (an interface with only one abstract method), which is always `@NotModified`, as explained in the next section.

The rules for not having to write `@NotModified` will be detailed later, but this example covers most of the bases.

[#functional-types]
=== Functional types

The type `Consumer<? super E>` in the `forEach` method of `Collection<E>` is defined as:

.Relevant part of definition of Consumer
[source,java]
----
interface Consumer<T> {
    void accept(T t);
}
----

The type `Collection` could implement `forEach` as:

.Possible implementation of forEach
[source,java]
----
void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

This method is clearly non-modifying: it simply iterates over the elements of the collection, without modifying this collection.
The `consumer` parameter of the method is {nm} when the method does not modify the object by calling modifying methods.
The question now is: is `accept` a modifying method?

If there is a modification, we have to consider _where_ this modification takes place.
Does it take place in the type of `forEach`, `Collection`, or does it take place in a type making use of `Collection` and its
`forEach` method?
It seems prudent while analysing to stick to what one knows in the type: there is no way to predict what will go on in types making use of `forEach`.

Therefore, by stipulating that `accept` is {nm}, we enforce that types implementing `Collection` and its `forEach` method cannot make use of `forEach` and its `Consumer` argument in a modifying way.
#TODO how#

Outside of `Collection` and its implementations, it could be used, for example, like:

[source,java]
----
void addAbc(Collection<Set<String>> sets) {
    sets.forEach(set -> { set.add("abc"); });
}
----

The (hidden) `accept` method takes a set of strings, and modifies this set.
Without the syntactic sugar, this reads:

[source,java]
----
void addOne(Collection<Set<String>> setse) {
    Consumer<Set<String>> consumer = new Consumer<>() {
        void accept(Set<String> set) {
            set.add("abc");
        }
    }
    sets.forEach(consumer);
}
----

The following example shows four different types of usage of the consumer:

[source,java]
----
class ConsumerUse {
    private static Consumer<Set<String>> abcAdder = set -> { set.add("abc"); }

    static void addAbc(@Modified Collection<Set<String>> sets) {
        sets.forEach(consumer);
    }

    static void println(@NotModified Collection<Set<String>> sets) {
        sets.forEach(System.out::println);
    }

    static void doSomethingModifying(@Modified Collection<Set<String>> sets,
            Consumer<Set<String>> consumer) {
        sets.forEach(consumer);
    }

    static void doSomethingNonModifying(@NotModified Collection<Set<String>> sets,
            @NotModified1(type = CONTRACT) Consumer<Set<String>> consumer) {
        sets.forEach(consumer);
    }

    static void forEach(@NotModified Collection<String> strings, Consumer<String> consumer) {
        strings.forEach(consumer);
    }
}
----

In the first two methods, the analyser knows which `Consumer` object will be handed to `forEach`.
It correspondingly computes that in the first method, `sets` will be modified, and in the second method, `sets` will remain unchanged.

In the third and fourth method, however, the implementation of the consumer comes from outside the type.

The fifth case is very similar to the original `forEach` method.
Because strings are deeply immutable, we know that

In the `addAbc` case,

We cannot realistically compute this using a static analyser.
This is the point where the programmer needs to _show intent_ by manually adding a contract annotation on the `consumer` parameter to indicate that its method is non-modifying:

This annotation and the use of `...1` at the end is in line with `@NotNull1`, detailed in <<nullable-section>>, which guarantees that the parameter values of the `apply` method are never null.

Once the contract annotation is in place, the analyser computes that `sets` is {nm}, that `addOne` is not a modifying method, and that, because the method does not access any fields nor overrides another method, it should be made static.

We conclude this section with the locality principle for modifications:

****
*Locality principle*: the modifications that a parameter of functional type can effect are outside the analysable scope:
in the `void forEach(Consumer<? super E> action)` method of `Collection<E>`, it is _possible_ to use the method to modify `E`.
But this must happen outside the scope of the interface or its implementations, and will be annotated if it happens.
This will form the basis of the definition of a {container} in the next chapter.
****

// ensure a newline at the end
