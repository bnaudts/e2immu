== Eventual immutability

There are many constraints on real-world use cases where immutability is not immediate.
The type then follows a life cycle described as create, use, drop.

Challenges:

* external frameworks insist on a way of working perpendicular to that of your project
* some graph-like data structures simply cannot be made immutable using conventional tools
* once you go eventually immutable, how is the propagation organized?

When possible, use a builder.

=== Builders

[source,java]
----
@E2Container
class Point {
    public final double x;
    public final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}

@E2Container
class Polygon {

    public final List<Point> points;

    private Polygon(List<Point> points) { // <1>
        this.points = points;
    }

    @Container(builds=Polygon.class)
    static class PolygonBuilder {
        private List<Point> points = new ArrayList<>();

        public void addPoint(Point point) {
            points.add(point);
        }

        public Polygon build() {
            return new Polygon(ImmutableList.copyOf(points));
        }
    }
}
----
<1> The private constructor combined with the construction of an immutable copy in the `build` method guarantees level 2 immutability.

If your code can live with two different types (`PolygonBuilder`, `Polygon`) to represent polygons in their different stages (mutable, immutable), the builder paradigm is great.
If, on the other hand, you want to hold polygons in a type that spans both stages of the polygon lifecycle, it becomes difficult to do this with an eye on immutability.
The <<firstthen>> type, as detailed further, can assist in this situation: it holds an initial object (the _first_) until a state change occurs, and it is forced to hold a second object (the _then_).
Once it is in the final state, it cannot change anymore.
It is _eventually immutable_:

[source,java]
----
class PolygonManager {
    // initially, the polygon is in builder phase
    public final FirstThen<Polygon.PolygonBuilder, Polygon> polygon =
        new FirstThen<>(new Polygon.PolygonBuilder());

    // ...

    public void construct() {
        // in builder phase ...
        polygon.getFirst().add(point);
        // transition
        polygon.set(polygon.getFirst().build());
        // from here on, polygon is immutable!
    }

    public Point firstPoint() {
        return polygon.get().points.get(0);
    }
}
----

=== Definition

We propose a system of eventual immutability based on a single transition of state inside an object.

.First example of frozen class
[source,java]
----
@E2Container(after="freeze")
class SimpleImmutableSet1<T> {
    private final Set<T> set = new HashSet<>();
    private boolean frozen;

    @Only(before="freeze")
    public boolean add(T t) {
        if(frozen) throw new UnsupportedOperationException();
        set.add(t);
    }

    @Mark("freeze")
    public void freeze() {
        if(frozen) throw new UnsupportedOperationException();
        frozen = true;
    }

    @Only(after="freeze")
    public Stream<T> stream() {
        if(!frozen) throw new UnsupportedOperationException();
        return set.stream();
    }

    public boolean isFrozen() { // <1>
        return frozen;
    }

    public int size() { // <1>
        return set.size();
    }
}
----
<1> These methods can be called any time.

The analyser has no problem detecting the presence of preconditions, and observing that one method changes its own precondition.
The rules, however, are sufficiently general to support arbitrary preconditions, as shown in the following variant.
This example does not require an additional field, but relies on the empty/not-empty state change:

.Second example of frozen class
[source,java]
----
@E2Container(after="freeze")
class SimpleImmutableSet2<T> {
    private final Set<T> set = new HashSet<>();

    @Mark("freeze")
    public boolean initialize(Set<T> data) {
        if(!set.isEmpty()) throw new UnsupportedOperationException();
        if(data.isEmpty()) throw new IllegalArgumentException();
        set.addAll(data);
    }

    @Only(after="freeze")
    public Stream<T> stream() {
        if(set.isEmpty()) throw new UnsupportedOperationException();
        return set.stream();
    }

    public int size() {
        return set.size();
    }
}
----

At this point the project intends to implement this form of eventuality for immutability and nullability, but not for the container property.

=== Object flows

So how does the analyser know whether the state change has happened?
The answer lies in computing _object flows_: traces of how and in which order the code accesses an object's methods, and of how these objects travel via assignments and through method calls.

A typical _origin_ of an object flow is a new object creation expression, which takes place in either a method, or a field assignment.
In the following example statement, the expression creates a `StringBuilder` object, accesses the `append` method repeatedly, and then discards the `StringBuilder` object (in favour of a `String`):

[source,java]
----
return new StringBuider().append(i).append("+").append(j).toString();
----

In general, there are three different ways of moving the object outside the creating method:

. the method returns the newly created object,
. the method passes on the newly created object as an argument to a method call (either static, or on another object),
. the method assigns the newly created object to a field inside the class.

Some different origins or starting points for an object flow are:

. new object creation, as in `Point p = new Point(x, y)`, which starts a flow residing in the local variable `p`;
. incoming flows as a return value of method calls or operators, as in `int s = set.size()`, which starts a flow in `s`;
. reading the value of a field;
. literals (attached as statics in the type), as in `Random r = new Random(123L)`, where the long constant starts a flow which 'travels' to the `seed` parameter of the constructor.
. incoming flows from outside the method via parameters, as in the `seed` parameter of the `Random(long seed)` constructor.

Once a flow has started, the code has the opportunity to execute the object's methods.
These methods can be modifying, or not; in the same way, passing the object as an argument of a method can be modifying or not.
While tracking non-modifying methods and arguments is useful from a code analysis' point of view, tracking the modifying methods and arguments is important to determine when the immutability state changes.
After executing the marked method, `freeze` in the example above, the object has changed state and has become immutable:

[source,java]
----
static int method1() {
    SimpleImmutableSet1 set1 = new SimpleImmutableSet1();
    set1.add("abc");
    set1.add("def");
    if (set1.isFrozen()) throw new UnsupportedOperationException();
    set1.freeze();
    if (!set1.isFrozen()) throw new UnsupportedOperationException();
    return (int) set1.stream().count();
}

static int method2() {
    FreezableSet set2 = new FreezableSet();
    set2.add("abc");
    set2.add("def");
    return (int) set2.stream().count(); // <1>
}

static int method3() {
    FreezableSet set3 = new FreezableSet();
    set3.add("abc");
    set3.freeze();
    set3.add("def");  // <1>
    return (int) set3.stream().count();
}
----
<1> The code analyser marks these statements as errors!

The analyser chains together the different flows; in this way, it is mostly able to detect whether an object is a mutable or immutable state.
Once the analyser confirms the object's state change has happened, it can add the `@E2Immutable` annotation to the field or method, as detailed in <<propagation-dynamic>>.

=== Propagation

A type with fields which satisfies all the rules for (eventual) level 2 immutability, with the caveat that some of its fields are eventually immutable themselves, can become level 2 immutable only in situations where these fields have reached immutability.
This means that the object flow analyser has to be able to verify that at some point in the object flow reaching the fields, the mark should be present.

=== Before the mark

A method can return an eventually immutable object, guaranteed to be in its initial state.
This can be annotated with {{beforeMark}}.
Employing `SimpleImmutableSet1` from the example above,

[source,java]
----
@BeforeMark
public SimpleImmutableSet1 create() {
    return new SimpleImmutableSet1();
}
----

Similarly, the analyser can compute a parameter to be {{beforeMark}}, when in the method, at least one before-mark methods is called on the parameter.
Finally, a field can even be {{beforeMark}}, when it is created or arrives in the type as {{beforeMark}}, and stays in this state.

=== Annotations

When a type is eventually level 1 immutable, should the field(s) of the state transition be {variable} or {final}?
Similarly, when a type is eventually level 2 immutable, should the analyser mark the support data fields {modified} or {nm}?

Basically, we propose to mark with the end state, qualifying with the parameter `after`:

[options=header]
|===
| property | not present | eventually | effectively
| finality of field | {variable} | `@Final(after="mark")` | {final}
| modification of field | {modified} | `@NotModified(after="mark")` | {nm}
|===

Since in an IDE it is not too easy to have multiple visual markers, it seems best to use the same visuals as the end state.

When a type is effectively level 1 immutable (not eventually), all fields are effectively final.
The analyser wants to emphasise the rules needed to obtain (eventual) level 2 immutability, by clearly indicating which fields break the level 2 immutability rules.
In the case of eventual level 2 immutability,

* modifications to the support data cease after a given mark
* the analyser disallows modifications to the other fields.

The following arrangement uses the intermediary annotation {supportData} to indicate that rules 2 and 3 apply to reach level 2 immutability, but are currently not satisfied:

[options=header,cols="50,25,25"]
|===
| property       | field | support data field
| modified       | {modified} | {modified}
| not modified   | {nm}       | {nm} {supportData}
| eventually not modified                              |{modified} (not recognized) |  `@NotModified(after="mark")` {supportData}
| not modified and satisfying rules 2 and 3            | - | {nm}
| eventually not modified and satisfying rules 2 and 3 |- | `@NotModified(after="mark")`
|===

Eventual finality simply adds a  `@Final(after="mark")` annotation to each of these situations.

=== Marking by hand

{mark} can only be set in a modifying method.

// ensure a newline at the end
