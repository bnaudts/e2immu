== Eventual immutability

There are many constraints on real-world use cases where immutability is not immediate.
The type then follows a life cycle described as create, use, drop.

Challenges:

* external frameworks insist on a way of working perpendicular to that of your project
* some graph-like data structures simply cannot be made immutable using conventional tools
* once you go eventually immutable, how is the propagation organized?

When possible, use a builder.

=== Builders

[source,java]
----
@E2Container
class Point {
    public final double x;
    public final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}

@E2Container
class Polygon {

    public final List<Point> points;

    private Polygon(List<Point> points) { // <1>
        this.points = points;
    }

    @Container(builds=Polygon.class)
    static class PolygonBuilder {
        private List<Point> points = new ArrayList<>();

        public void addPoint(Point point) {
            points.add(point);
        }

        public Polygon build() {
            return new Polygon(ImmutableList.copyOf(points));
        }
    }
}
----
<1> The private constructor combined with the construction of an immutable copy in the `build` method guarantees level 2 immutability.

If your code can live with two different types (`PolygonBuilder`, `Polygon`) to represent polygons in their different stages (mutable, immutable), the builder paradigm is great.
If, on the other hand, you want to hold polygons in a type that spans both stages of the polygon lifecycle, it becomes difficult to do this with an eye on immutability.
The <<firstthen>> type, as detailed further, can assist in this situation: it holds an initial object (the _first_) until a state change occurs, and it is forced to hold a second object (the _then_).
Once it is in the final state, it cannot change anymore.
It is _eventually immutable_:

[source,java]
----
class PolygonManager {
    // initially, the polygon is in builder phase
    public final FirstThen<Polygon.PolygonBuilder, Polygon> polygon =
        new FirstThen<>(new Polygon.PolygonBuilder());

    // ...

    public void construct() {
        // in builder phase ...
        polygon.getFirst().add(point);
        // transition
        polygon.set(polygon.getFirst().build());
        // from here on, polygon is immutable!
    }

    public Point firstPoint() {
        return polygon.get().points.get(0);
    }
}
----

=== Definition

We propose a system of eventual immutability based on a single transition of state inside an object.

.First example of frozen class
[source,java]
----
@E2Container(after="freeze")
class SimpleImmutableSet1<T> {
    private final Set<T> set = new HashSet<>();
    private boolean frozen;

    @Only(before="freeze")
    public boolean add(T t) {
        if(frozen) throw new UnsupportedOperationException();
        set.add(t);
    }

    @Mark("freeze")
    public void freeze() {
        if(frozen) throw new UnsupportedOperationException();
        frozen = true;
    }

    @Only(after="freeze")
    public Stream<T> stream() {
        if(!frozen) throw new UnsupportedOperationException();
        return set.stream();
    }

    public int size() { // <1>
        return set.size();
    }
}
----
<1> This method can be called at any time.

The analyser has no problem detecting the presence of preconditions, and observing that one method changes its own precondition.
The rules, however, are sufficiently general to support arbitrary preconditions, as shown in the following variant.
This example does not require an additional field, but relies on the empty/not-empty state change:

.Second example of frozen class
[source,java]
----
@E2Container(after="freeze")
class SimpleImmutableSet2<T> {
    private final Set<T> set = new HashSet<>();

    @Mark("freeze")
    public boolean initialize(Set<T> data) {
        if(!set.isEmpty()) throw new UnsupportedOperationException();
        if(data.isEmpty()) throw new IllegalArgumentException();
        set.addAll(data);
    }

    @Only(after="freeze")
    public Stream<T> stream() {
        if(set.isEmpty()) throw new UnsupportedOperationException();
        return set.stream();
    }

    public int size() {
        return set.size();
    }
}
----

At this point the project intends to implement this form of eventuality for immutability and nullability, but not for the container property.

=== Object flows

=== Propagation

A type with fields which satisfies all the rules for (eventual) level 2 immutability, with the caveat that some of its fields are eventually immutable themselves, can become level 2 immutable only in situations where these fields have reached immutability.
This means that the object flow analyser has to be able to verify that at some point in the object flow reaching the fields, the mark should be present.


// ensure a newline at the end
