[#linking-exposed]
== Linking and Exposed

=== New definition of independence

More or less half of the definition of level 2 immutability:

****
*Definition of an independent type:*

. fields linked to constructor parameters are {nm} (hence these parameters must be {nm} as well)
. non-private fields linking to constructor parameters must be level 2 immutable
. all return values of methods are independent of the fields linking to constructor parameters
****

Types cannot be eventually independent.
A newly created independent type is independent of the arguments, in the sense that _if_ these arguments satisfy all rules for level 2 immutability, the new object will not change this.
This helps in _extending_ a level 2 immutable type, for example with an iterator:

.Extending a level 2 immutable type with an iterator
[source,java]
----
@E2Container
public class ExampleManualIterator1<E> {

    @NotModified
    private final List<E> list = new ArrayList<>();

    @Independent
    public ExampleManualIterator1(E[] es) {
        Collections.addAll(list, es);
    }

    interface MyIterator<E> {
        boolean hasNext();

        E next();
    }

    @Independent
    public MyIterator<E> iterator() {
        return new MyIteratorImpl<>(list); // <1>
    }

    @Container
    @Independent
    public static class MyIteratorImpl<E> implements MyIterator<E> {

        @NotModified
        private final List<E> list; // <2>
        @Modified
        private int index;

        @Dependent
        private MyIteratorImpl(@NotModified List<E> list) {
            this.list = list;
        }

        @Override
        @NotModified
        public boolean hasNext() {
            return index < list.size();
        }

        @Override
        @Modified
        @NotNull
        public E next() {
            return list.get(index++);
        }
    }
}
----
<1> The newly created `MyIteratorImpl` object is independent of `list`; which helps in making `ExampleManualIterator1` level 2 immutable.
<2> This field is central to the rules for `MyIteratorImpl` to be {independent}.

The static nested class `MyIteratorImpl` could have been implemented as a non-static nested one (aka _inner class_):

.Same, but with inner class
[source,java]
----
@E2Container
public class ExampleManualIteratorInner1<E> {

    @NotModified
    private final List<E> list = new ArrayList<>();

    @Independent
    public ExampleManualIteratorInner1(E[] es) {
        Collections.addAll(list, es);
    }

    interface MyIterator<E> {
        boolean hasNext();

        E next();
    }

    @Independent
    public MyIterator<E> iterator() {
        return new MyIteratorImpl();
    }

    @Container
    @Independent
    public class MyIteratorImpl implements MyIterator<E> {

        @Modified
        private int index;

        @Override
        @NotModified
        public boolean hasNext() {
            return index < list.size();
        }

        @Override
        @Modified
        @NotNull
        public E next() {
            return list.get(index++);
        }
    }
}
----

The rules are made to be compatible with this situation.

=== Linking

To compute linking, the analyser tries to track actual objects, with the aim of knowing if a field links to another field or a parameter.
It computes a dependency graph of variables depending on other variables, with the following four basic rules:

****
Rule 1: in an assignment `v = w`, variable `v` links to variable `w`.
****

****
Rule 2: in an assignment `v = a.method(b)`,`v` potentially links to `a` and `b`.
****

Note that saying `v` links to `a` is the same as saying that the return value of `method` links to some field inside `A`, the type of `a`.
This is especially clear when `a == this`.

We discern a number of special cases:

. When `v` is of primitive or {e2immutable} type, there cannot be any linking; `v` does not link to `a` nor `b`.
. If `b` is of primitive or {e2immutable} type, `v` cannot link to `b`.
. When `method` has the annotation {independent}, `v` cannot link to `a`.
. If `a` is of {independent} type (which includes all {e2immutable} types), all its methods are independent; therefore, `v` cannot link to `a`.

It is important to note that the analyser only computes independence for non-modifying methods, and that all methods returning non-support-data types are automatically independent.

****
Rule 3: in an assignment `v = new A(b)`, `v` potentially links to `b`.
****

Noting that independence is automatic for non-support-data types, we observe:

. When the constructor `A` is independent, `v` cannot link to `b`.
. When `b` is of primitive or {e2immutable} type, `v` cannot link to `b`.
. If `A` is {e2immutable}, then `v` cannot link to `b` nor `c`, because all constructors are independent.

Most of the other linking computations are consequences of the basic rules above.
For example,

. in an assignment `v = condition ? a : b`, `v` links to both `a` and `b`.
. type casting does not prevent linking: in `v = (Type)w`, `v` links to `w`
. Binary operators return primitives or `java.lang.String`, which prevents linking: in `v = a + b`, `v` does not link to `a` nor `b`.

****
Rule 4: in an array access `v = a[index]`, `v` links to `a`.
****

=== Loop statement

In the loop statement `for(T t: ts)`, does the loop variable `t` link to the source `ts`?
Surely it does, for accessing an element links to the source, as rule 4 shows.

This becomes explicit when one considers a model implementation for this statement:

[source,java]
----
Iterator<T> iterator = ts.iterator();
while(iterator.hasNext()) {
    T t = iterator.next();
    { ... }
}
----

Iterators are, by definition, structures undergoing permanent modification during their life span: some field needs to keep track of the next element to be returned.
Iterators only modify the structure they iterate on when they implement a `remove` method.

Independence of the iterator is important for the semantics of the loop: it ensures that the act of looping over the elements does not change the type.
It therefore seems prudent to enforce independence in the interface, even though this is #inconsistent# with `remove`:

[source,java]
----
interface Iterable<T> {
    @Independent
    Iterator<T> iterator();
}
----

Note that {nm} is not strong enough: not only should the act of creating an iterator not be modifying, applying the `next` and `hasNext` methods should not affect the fields of the type either.

Importantly, the independence relates to the support data of the implementation of the iterator: the resulting object's constructor should link to the support data of the fields.
This allows for modifications on a field responsible for keeping track.
It also ignores potential modifications on the non-support-data of type `T`.

=== Directionality

A short note on directionality.
The definitions posited above appear directed: `v` links to `a`, `b` and `c`.
This means the object held by `v` may contain (parts of) the object represented by `a`, `b` or `c`.
Modifications to `v` may imply modifications to either `a`, `b`, or `c`; conversely, any modification to `a`, `b` or `c`
may have an impact on `v`.
The connected sub-graph `v`, `a`, `b`, `c` therefore forms one 'equivalence class' with respect to modification.

This equivalence is in line with fields linking to parameters, and vice versa, with identical effect: modifications in one can also take place in the other.

[source,java]
----
public SetBasedContainer(Set<T> ts) {
    this.data = ts; // <1>
}

public void unsafeVisit(Consumer<Set<T>> consumer) {
    consumer.accept(data); // <2>
}
----
<1> from the parameter to the field,
<2> from the field to the parameter.

=== Exposed

Finally, we detail how the analyser computes the {exposed} annotation.
The analysis of the loop statement shows that the definitions of linking do not apply: in `for(T t: ts) { ... }`, the analyser needs to know that `t` is part of the object graph of `ts` in case `ts` is a field.

