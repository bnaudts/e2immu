[#linking-exposed]
== Linking and Exposed

=== New definition of independence

Only for support data, on types, ignoring modification.
Then downgrade the transfer of independence to {independent} types, rather than {e2immutable} types.

=== Linking

To compute linking, the analyser tries to track actual objects, with the aim of knowing if a field links to another field or a parameter.
It computes a dependency graph of variables depending on other variables, with the following four basic rules:

****
Rule 1: in an assignment `v = w`, variable `v` links to variable `w`.
****

****
Rule 2: in an assignment `v = a.method(b)`,`v` potentially links to `a` and `b`.
****

Note that saying `v` links to `a` is the same as saying that the return value of `method` links to some field inside `A`, the type of `a`.
This is especially clear when `a == this`.

We discern a number of special cases:

. When `v` is of primitive or {e2immutable} type, there cannot be any linking; `v` does not link to `a` nor `b`.
. If `b` is of primitive or {e2immutable} type, `v` cannot link to `b`.
. When `method` has the annotation {independent}, `v` cannot link to `a`.
. If `a` is of {independent} type (which includes all {e2immutable} types), all its methods are independent; therefore, `v` cannot link to `a`.

It is important to note that the analyser only computes independence for non-modifying methods, and that all methods returning non-support-data types are automatically independent.

****
Rule 3: in an assignment `v = new A(b)`, `v` potentially links to `b`.
****

Noting that independence is automatic for non-support-data types, we observe:

. When the constructor `A` is independent, `v` cannot link to `b`.
. When `b` is of primitive or {e2immutable} type, `v` cannot link to `b`.
. If `A` is {e2immutable}, then `v` cannot link to `b` nor `c`, because all constructors are independent.

Most of the other linking computations are consequences of the basic rules above.
For example,

. in an assignment `v = condition ? a : b`, `v` links to both `a` and `b`.
. type casting does not prevent linking: in `v = (Type)w`, `v` links to `w`
. Binary operators return primitives or `java.lang.String`, which prevents linking: in `v = a + b`, `v` does not link to `a` nor `b`.

****
Rule 4: in an array access `v = a[index]`, `v` links to `a`.
****

=== Loop statement

In the loop statement `for(T t: ts)`, does the loop variable `t` link to the source `ts`?
Surely it does, for accessing an element links to the source, as rule 4 shows.

This becomes explicit when one considers a model implementation for this statement:

[source,java]
----
Iterator<T> iterator = ts.iterator();
while(iterator.hasNext()) {
    T t = iterator.next();
    { ... }
}
----

Iterators are, by definition, structures undergoing permanent modification during their life span: some field needs to keep track of the next element to be returned.
Iterators only modify the structure they iterate on when they implement a `remove` method.

Independence of the iterator is important for the semantics of the loop: it ensures that the act of looping over the elements does not change the type.
It therefore seems prudent to enforce independence in the interface, even though this is #inconsistent# with `remove`:

[source,java]
----
interface Iterable<T> {
    @Independent
    Iterator<T> iterator();
}
----

Note that {nm} is not strong enough: not only should the act of creating an iterator not be modifying, applying the `next` and `hasNext` methods should not affect the fields of the type either.

Importantly, the independence relates to the support data of the implementation of the iterator: the resulting object's constructor should link to the support data of the fields.
This allows for modifications on a field responsible for keeping track.
It also ignores potential modifications on the non-support-data of type `T`.

=== Directionality

A short note on directionality.
The definitions posited above appear directed: `v` links to `a`, `b` and `c`.
This means the object held by `v` may contain (parts of) the object represented by `a`, `b` or `c`.
Modifications to `v` may imply modifications to either `a`, `b`, or `c`; conversely, any modification to `a`, `b` or `c`
may have an impact on `v`.
The connected sub-graph `v`, `a`, `b`, `c` therefore forms one 'equivalence class' with respect to modification.

This equivalence is in line with fields linking to parameters, and vice versa, with identical effect: modifications in one can also take place in the other.

[source,java]
----
public SetBasedContainer(Set<T> ts) {
    this.data = ts; // <1>
}

public void unsafeVisit(Consumer<Set<T>> consumer) {
    consumer.accept(data); // <2>
}
----
<1> from the parameter to the field,
<2> from the field to the parameter.

=== Exposed

Finally, we detail how the analyser computes the {exposed} annotation.
The analysis of the loop statement shows that the definitions of linking do not apply: in `for(T t: ts) { ... }`, the analyser needs to know that `t` is part of the object graph of `ts` in case `ts` is a field.

