== Examples

=== Lazy

`Lazy` implements a lazily-initialized immutable field, of unbound generic type `T`.
As such, it is eventually an `@E1Container`.

[source,java]
----
@E1Container(after = "get")
public class Lazy<T> {
    private final Supplier<T> supplier;
    private volatile T t;

    public Lazy(Supplier<T> supplier) {
        this.supplier = supplier;
    }

    @Modified
    @Mark("get")
    public T get() {
        T localT = t;
        if (localT != null) return localT;

        synchronized (this) {
            if (t == null) {
                t = Objects.requireNonNull(supplier.get());
            }
            return t;
        }
    }
}
----

After calling the marker method `get()`, `t` cannot be assigned anymore.
Because it is of an unbound type, the field `t` is `@NotModified`.
Because it is a functional type, `supplier` is `@NotModified`.
The type is also clearly a container.
Tte type violates the independence rule, so it is not a `@E2Container`.

=== Trie

As a second example, let's look at the code analyser's implementation of a trie, a real, non-trivial data structure.
We have added the nullability annotations, as defined in the next section, but we removed some duplicate ones to avoid overloading the text.

.Code fragment: The code analyser's Trie type.
[source,java]
----
package org.e2immu.analyser.util;

import org.e2immu.annotation.*;
import java.util.*;
import java.util.function.*;

@E2Container(after = "freeze")
public class Trie<T> extends Freezable {

    private final TrieNode<T> root = new TrieNode<>();
    private boolean frozen;

    @Container // by definition, has no methods
    private static class TrieNode<T> {
        @Nullable @Modified
        List<T> data;

        @Nullable @Modified
        Map<String, TrieNode<T>> map;
    }

    @Nullable @NotModified
    private TrieNode<T> goTo(@NotNull1 String[] strings) { // <1>
        return goTo(strings, strings.length);
    }

    @Nullable @NotModified
    private TrieNode<T> goTo(@NotNull1 String[] strings, int upToPosition) {
        TrieNode<T> node = root;
        for (int i = 0; i < upToPosition; i++) {
            if (node.map == null) return null;
            node = node.map.get(strings[i]);
            if (node == null) return null;
        }
        return node;
    }

    @Nullable @NotModified
    public List<T> get(@NotNull1 String[] strings) {
        TrieNode<T> node = goTo(strings);
        return node == null ? null : node.data;
    }

    @NotNull @Modified @Only(before = "freeze")
    public List<T> getOrCompute(String[] strings, Function<String[], T> action) {
        if(frozen) throw new UnsupportedOperationException("Already frozen");

        TrieNode<T> node = goTo(strings);
        if (node == null) {
            return add(strings, action.apply(strings)).data;
        }
        if (node.data == null) {
            node.data = new LinkedList<>();
            node.data.add(action.apply(strings));
        }
        return node.data;
    }

    @NotModified
    public void visit(@NotNull1 String[] strings,
                      @NotNull2 BiConsumer<String[], List<T>> visitor) { // <2>
        TrieNode<T> node = goTo(strings);
        if (node == null) return;
        recursivelyVisit(node, new Stack<>(), visitor);
    }

    private static <T> void recursivelyVisit(TrieNode<T> node,
                                             Stack<String> strings,
                                             BiConsumer<String[], List<T>> visitor) {
        if (node.data != null) {
            visitor.accept(strings.toArray(String[]::new), node.data);
        }
        if (node.map != null) {
            node.map.forEach((s, n) -> {
                strings.push(s);
                recursivelyVisit(n, strings, visitor);
                strings.pop();
            });
        }
    }

    @NotNull @Modified @Only(before = "freeze")
    public void add(@NotNull1 String[] strings, @NotNull T data) {
        if(frozen) throw new UnsupportedOperationException("Already frozen");

        TrieNode<T> node = root;
        for (String s : strings) {
            TrieNode<T> newTrieNode;
            if (node.map == null) {
                node.map = new HashMap<>();
                newTrieNode = new TrieNode<>();
                node.map.put(s, newTrieNode);
            } else {
                newTrieNode = node.map.get(s);
                if (newTrieNode == null) {
                    newTrieNode = new TrieNode<>();
                    node.map.put(s, newTrieNode);
                }
            }
            node = newTrieNode;
        }
        if (node.data == null) node.data = new LinkedList<>();
        node.data.add(Objects.requireNonNull(data));
    }

    @Modified @Mark("freeze")
    public void freeze() {
        if(frozen) throw new UnsupportedOperationException("Already frozen");
        frozen = true;
    }
}
----
<1> {nn1} here means that `strings` cannot be null, and neither can it hold null elements.
Because the type is a container, the implicit `@NotModified` annotation guarantees that the trie will not write to the array.
<2> {nn2} here means that the `visitor` should not be null, but also that the data offered to the visitor will not be null, and neither will its content.

Until the user of this trie calls the `freeze` method, elements can be added via the `add` and `getOrCompute` methods.
Visiting the trie can be done at any time; the `visit` method offers the elements for consumption via the `BiConsumer` parameter.
Verifying that the trie is level 2 immutable, we observe that, after having called `freeze`,

. all fields are `@NotModified`,
. `freeze` is a primitive, so rules 2 and 3 do not apply,
. rules 2 and 3 do apply to `root`, as it is of a type (`TrieNode`) which holds one of the types in the parameters of public methods (`T`).
The field is private, so rule 2 is easily satisfied.
There are no constructors with parameters, so we only have to show that the public non-modifying methods return objects that are independent of the `root` field.


// leave an empty line!
