== Other annotations

The {e2immu} project defines a whole host of annotations complementary to the ones required for immutability.
We discuss them briefly, and refer to the user manual for an in-depth analysis.

[#nullable-section]
=== Nullable, not null

=== Identity and fluent methods

The analyser marks methods which returns their first parameter with `@Identity`, and methods which return `this` with `@Fluent`.
The former are convenient to introduce preconditions, the latter occur frequently when chaining methods in builders.
Here is an integrated example:

[source,java]
----
@Container(builds=Set.class)
class Builder {
    @NotNull @NotModified @Identity
    private static <T> T requireNonNull(@NotNull T t) {
        if(t == null) throw new UnsupportedOperationException();
        return t;
    }

    private final List<String> list = new ArrayList<>();

    @Fluent
    public Builder add(@NotNull String s) {
        list.add(requireNonNull(s));
        return this;
    }

    @Fluent
    public Builder add(int i) {
        list.add(Integer.toString(i));
        return this;
    }

    @E2Container
    public List<String> build() {
        return ImmutableList.copyOf(list);
    }

    public static final Set<String> one23 = new Builder().add(1).add(2).add(3).add("go").build();
}
----

=== Size

The `@Size` annotations are conceptually similar to the nullability markers.
When presented with the precondition:

[source,java]
----
public boolean process(Set<T> set) {
    if(set.isEmpty()) throw new UnsupportedOperationException();
    // ...
}
----

the {e2immu} code analyser adds a `@Size(min = 1)` annotation.
This leads to a similar check method:

[source,java]
----
@Identity @Size(min=1) @NotModified @NotNull
public static <T> Collection<T> requireNonEmpty(
        @Size(min = 1) @NotModified @NotNull Collection<T> collection) {
    if(collection.isEmpty()) throw new UnsupportedOperationException();
    return collection;
}
----

with apologies for the massive amount of annotations.
Internally the analyser translates the `isEmpty` method to the expression `collection.size() >= 1`, which allows for further comparisons and analysis.

=== Utility class, extensions, singleton

Using the simple and common definition:

****
*Definition*: a *utility class* is a class which cannot be instantiated: it has no non-static fields, and has a single, private, unused constructor.
****

the code analyser recognizes classes that only contain an assortment of static fields and methods.
The value of recognizing this type is twofold: firstly, it enforces the private constructor; secondly, it allows for the detection of extension classes.

In Java, many classes cannot easily be extended.
Implementations of extensions typically use a utility class with the convention that the first parameter of the static method is the object of the extended method call:

[source,java]
----
@Extension(of=String[].class)
class ExtendString {
    private ExtendString() { throw new UnsupportedOperationException(); }

    public static String weave(@NotModified String[] strings) {
        // generate a new string by weaving the given strings (concat 1st chars, etc.)
    }

    public static int appendEach(@Modified String[] strings, String append) {
        // append the parameter 'append' to each of the strings in the array
    }
}
----

We use the following criteria to designate a utility class as an extension:

****
*Definition*:
****

Static classes can be used to 'extend' closed types, as promoted by the Xtend project.
Level 2 immutable classes can also play the role of extension facilitators, with the additional benefit of having some immutable data to be used as a context.

// ensure a newline at the end
