[#indirect-modification]
== Indirect Modification

=== Cyclic references

Time for more fine print on modifications.
We need to revisit the situation of seemingly non-modifying methods with modifying parameters.
Up to now, a method is only modifying when it assigns to a field, calls a modifying method on one of the fields, or directly calls a modifying method on `this`.
However, there could be indirect modifications, as in:

.Indirect modifications
[source,java]
----
@E2Container
public class ModificationGraphChecks {

    @MutableModifiesArguments
    static class C1 {

        @Variable
        private int i;

        @Modified
        public int incrementAndGet() {
            return ++i;
        }

        @Modified // <1>
        public int useC2(@Modified C2 c2) {
            return i + c2.incrementAndGetWithI();
        }

    }

    @E1Immutable
    static class C2 {

        private final int j;

        @Modified
        private final C1 c1;

        public C2(int j, @Modified C1 c1) {
            this.c1 = c1;
            this.j = j;
        }

        @Modified
        public int incrementAndGetWithI() {
            return c1.incrementAndGet() + j;
        }
    }
}
----
<1> `useC2` does not directly modify `i`, but `incrementAndGetWithI` does so indirectly.

This observation forces us to tighten the definition of a non-modifying method: on top of the definition given above, we have to ensure that none of the modifying methods called on a parameter which is {modified}, call one of 'our' modifying methods.
These rules are mostly, but not easily, enforceable when all code is visible.

An additional interface can help to remove the circular dependency between the types.
This has the advantage of simplicity, both for the programmer and the analyser, which at this point doesn't handle circular dependencies too well.
It imposes more annotation work on the programmer, however, because the interface's methods need annotating.

[#abstract-methods]
=== Abstract methods

=== Concrete use of abstract methods


Once there is modifying method in a class, the analyser cannot exclude that the unknown code will not execute it.
Therefore,

****
*Implication of the indirect modification rule*: A method calling any non-declared single abstract method is modifying as soon as there are

. other non-private modifying methods in the type,
. or non-private fields
. or other non-independent non-private methods
****

These are a subset of the rules used in level 2 immutability; they are very similar to those of an independent type.

Manually contracting the method to be not modifying will activate the analyser, which may or may not be successful in detecting such unwanted modification calls.
There is one situation, however, where they are easy to spot: lambdas.

As `forEach` is iterating over the elements of some `Iterable`, the consumer should not make any attempts at modifying the iterable.
Doing so will result in a `ConcurrentModificationException`:

[source,java]
.Modifying the list being iterated over
----
public class ExampleManualSelfModificationOnForEach {

    @Test
    public void testDangerous() {
        List<String> l1 = new ArrayList<>();
        Collections.addAll(l1, "a", "c", "e");
        try {
            print(l1);
            Assert.fail();
        } catch(ConcurrentModificationException cme) {
            // OK
        }
    }

    static void print(List<String> list) {
        list.forEach(l -> {
            System.out.println(l);
            if (l.startsWith("a")) {
                list.add("b"); // <1>
            }
        });
    }
}
----
<1> The offending modifying method.

The {nm} annotation on `forEach` does prevent the `list.add` method to be called, because the lambda block in the first statement of `print` fully declares the code of the consumer.

The following example shows a number of situations:

[source,java]
----
private final Consumer<T> consumer;
private int counter;

@Modified // <1>
public int incrementAndGet() { return ++counter; }

@Modified // <2>
public void expose1(T t) {
    consumer.accept(t1);
}

@Modified // <2>
public void expose2(Consumer<Integer> intConsumer) {
    intConsumer.accept(counter);
}

@NotModified // <2>
private static <T> void staticallyExposing(@NotModified T t, Consumer<T> consumer) {
    consumer.accept(t);
}

@Modified // <3>
public void expose2() {
    staticallyExposing(t2, exposingConsumer2);
}
----
<1> This is the real modifying method, potentially called from undeclared code.
<2> Modifying because the method calls a single abstract method, `accept`.
<3> Indirectly modifying because `staticallyExposing` is modifying.

Note that we never make a distinction between static and instance fields, or methods, concerning modification.

[#params-functional-interface]
=== Parameters of abstract types

When the parameter is of an abstract type, other complications arise.
Starting with the functional interface `Consumer` an example,

.Initial observation of modification in Consumer
[source,java]
----
@FunctionalInterface
public interface Consumer<T> {
    @Modified
    void accept(@Modified T t);
    // ...
}
----

we realise that the single abstract method in `Consumer` is, in general, modifying, and that it potentially modifies its parameter.
Indeed, using `Point` defined in <<point-and-line>>,

[source,java]
----
Consumer<Point> moveOneToTheRight = point -> point.setX(point.getX() + 1);
Point p = ...;
Consumer<Point> addToP = point -> {
    p.setX(p.getX() + point.getX());
    p.setY(p.getY() + point.getY());
}
----

The first consumer, `moveOneToTheRight`, has a non-modifying `accept` method which modifies its parameter.
The second one, `addToP`, has a modifying `accept` method, with a parameter which remains unmodified.

However, these observations contrast with the use of `Consumer` in the `forEach` method of many collections:

.Possible implementation of forEach
[source,java]
----
default void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

Here,

. `T` is implicitly immutable, so the consumer's `accept` cannot make changes to `t` _that we know of_;
. it is expected that `accept` makes some modification, but not a modification to `this`.

For all intents and purposes, we want to mark both the method and the parameter inside `forEach` as {nm}.
The method does nothing but help us iterate over the elements of the collection, an action which is not modifying when executed using a for-loop.
The modifying aspect is in the application of the method: when a modifying method is passed as argument to `forEach`, the object of the method call will be marked as modified:

.Marking the object as modified
[source,java]
----
Set<Integer> set = new HashSet<>();
List.of(1, 2, 3).forEach(set::add); // <1>
----
<1> The `forEach` modifies `set` as the object of the modifying method `add`.

We already conclude that

****
*Additional, overriding modification rule*: Parameters of abstract types are {nm} if the abstract method is not applied to other parameters of the method.
****

Let us explain this:

Modifications abstract methods make to the fields of the class can only be made through methods which are already {modified} (or access to non-private fields); this will not change the overall modification status of the type.
As a consequence,

. we need not look at indirect modifications (which would be nigh on impossible anyway), implying that functional interface type parameters have no impact on the modification status of the method.
. we do not need to change our definition of containers, which requires parameters that are {nm}.

Secondly,

****
*Additional, overriding modification rule*: We treat unbound parameter types, and types that can be replaced by an unbound parameter type, as level 2 immutable when passing them as parameters to abstract methods.
They will not be modified.
****

So in effect, the parameter of the `accept` method is modifying for all types except the ones where modifications don't matter to the type.
Making the consumer {nm1} forces absence of modifications on the parameters in the implementation.
The annotation {nn1} implies that null arguments will cause exceptions; the analyser will warn against them.

If the data passed to the `accept` method is independent of the fields, we annotate the consumer parameter with {independent}.
The independence shields off the fields from modification, which is a necessary requirement for level 2 immutability.

Implementing a visitor using the `forEach` method defined as:

.Annotated definition of forEach.
[source,java]
----
@NotModified
default void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

renders code like:

.Example use of forEach.
[source,java]
----
private Set<T> set;

@NotModified
public void visit(Consumer<T> consumer) {
    set.forEach(consumer);
}

@NotModified
public void copy(@Independent Consumer<Set<T>> consumer) {
    consumer.accept(new HashSet<>(set));
}
----

The next section discusses the modification or non-modification of the `visit` and `copy` methods.


