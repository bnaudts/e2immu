[#functional-interfaces]
=== Functional interfaces

Functional interfaces are interfaces with a single abstract method.
The following table lists some frequently used examples:

[options=header]
|===

| Name | single abstract method
| `Consumer<T>` | `void accept(T t);`
| `Function<T,R>` | `R apply(T t);`
| `BiFunction<T, U, R>` | `R apply(T t, U u);`
| `Supplier<R>` | `R get();`
| `Predicate<T>` | `boolean test(T t);`
|===

It is important not to forget that _any_ interface defining a single abstract method can be seen as a functional interface.
While the examples above all employ generics, generics are not a requirement for functional interfaces.
The Java language offers syntactic sugar for functional programming, but the types remain Java types.
As such we have to ensure that definitions for functional interfaces which we will present in this section, are compatible with the definitions for general types.

We will also have to introduce one extra provision for dealing with code for which no declaration is readily available.
This is the case for interface types and abstract classes.
Because the actual implementation of such types cannot be known beforehand #TODO#

The case of overriding implementations

=== Modification

Let us go back to the annotations of `Collection` in <<collection-interface>>.
Making use of the fact that `Collection` extends `Iterable`, the default implementation of `forEach` could look like:

.Possible implementation of forEach
[source,java]
----
default void forEach(Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

In this section, we will argue that `forEach` should be annotated {nm}, and we will find a way to express that this method does not modify its parameter `consumer`.
However, looking at the definition of `Consumer`,

[source,java]
----
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
    // ...
}
----

it feels too harsh to demand that `accept` is {nm}; similarly we cannot add {nm} in front of the parameter `T t`.
Too many implementations of this interface are modifying, or modify the parameter.

How do we square these contractions?

==== Annotating _forEach_

Intuitively, `forEach` should be non-modifying: it should simply iterate over the elements of the collection, _without modifying the fields of the collection object in the process_.
Because the type `T` has no modifying methods visible to `forEach`, it cannot make explicit changes to the elements it holds, and it should not make changes to the collection structure.

At the same time, users of `forEach` will very likely want to make changes to the `T` elements.
Therefore, it will not be productive to enforce the parameter of the consumer's `accept` method to be {nm}.
Because the `T` elements are part of the object graph of the collection's fields, changes to them technically change this object graph as well.
We need to find some mechanism to indicate that these changes are not relevant to `forEach` being not modifying.

Let us look at the same situation, but then without unbound generic types, and consider:

[source,java]
----
class Polygon {
    private final List<Point> points;
    ...
    public void visit(Consumer<Point> visitor) {
        for(Point point: points) visitor.accept(point);
    }
}
----

For the `visit` method to be non-modifying, no visitor should modify the points.
Unlike `Collection`, `Polygon` has modification access to `Point`, via the `setX` and `setY` methods.
Here it makes sense to explicitly demand that `visitor` does not modify its parameters:

[source,java]
----
@NotModified
public void visit(@NotModified1 Consumer<Point> visitor) {
    for(Point point: points) visitor.accept(point);
}
----

By annotating a parameter with {nm1}, we instruct the analyser to ensure that parameter's method cannot be called with an implementation of the functional interface that modifies this parameter.

NOTE: The use of the suffix 1 in {nm1}, indicating _one level down_, is in line with {nn1}, an annotation detailed in <<nullable-section>>, which guarantees that the object and its content, in this case, the object and the parameter values of its `accept` method, are never null.

The {nm1} annotation on this particular visitor is less restrictive than a blanket {nm} on the parameter of `accept` in `Consumer`.
It is still too strong for a generic method like `forEach`, however.

We find a solution in the fact that `accept` may be modifying, but `forEach` has no knowledge of modifying methods.
Referring back to our original definition of modification in <<modification>>, we extend this definition as follows:

****
*Definition*: *Computable modifications* are modifications to those types in the object graph for which modifying methods are available.
If the analyser encounters modifying methods to elements of the object graph which it cannot compute, it will mark the methods (and by implication, the functional interfaces) doing the modification with the {exposed} annotation.
****

This means that `forEach` ends up as:

.Without annotation on the parameter
[source,java]
----
@NotModified
default void forEach(@Exposed Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----

The {exposed} annotation indicates that modifications on the `T` elements presented are possible, but are outside the scope of the method.

There is a third level of modification that requires attention.
As `forEach` is iterating over the elements of some `Iterable`, the consumer should not make any attempts at modifying the iterable.
Doing so will result in a `ConcurrentModificationException`:

[source,java]
.Modifying the list being iterated over
----
public class ExampleManualSelfModificationOnForEach {

    @Test
    public void testDangerous() {
        List<String> l1 = new ArrayList<>();
        Collections.addAll(l1, "a", "c", "e");
        try {
            print(l1);
            Assert.fail();
        } catch(ConcurrentModificationException cme) {
            // OK
        }
    }

    static void print(List<String> list) {
        list.forEach(l -> {
            System.out.println(l);
            if (l.startsWith("a")) {
                list.add("b"); // <1>
            }
        });
    }
}
----
<1> The offending modifying method.

The {nm} annotation on `forEach` forces the analyser to reject modifying methods on its scope object.
If `forEach` were an implementation method to be analysed, rather than an interface method specification, the contracted annotation on the parameter has to be used:

.forEach as normal method
[source,java]
----
@NotModified // <1>
void forEach(@NotModified(type = CONTRACT) @Exposed Consumer<T> consumer) {
    for(T t: this) consumer.accept(t);
}
----
<1> The analyser infers this one, knowing the consumer cannot call self-modifying methods, and the `T` elements are free from modification as well.

==== Another example

We provide another example to clarify, making use of the `Counter` class defined a bit higher:

.Different ways of applying forEach
[source,java]
----
class ApplyingForEach {
    private static final Consumer<Counter> incrementer = Counter::increment;

    @NotModified1
    private static final Consumer<Counter> printer = counter -> {
        System.out.println("Counts to " + counter.getCounter());
    };

    static void incrementAll(@Modified Collection<Counter> counters) {
        counters.forEach(incrementer);
    }

    static void println(@NotModified Collection<Counter> counters) {
        counters.forEach(printer);
    }

    static void doSomethingModifying(@Modified Collection<Counter> counters,
            Consumer<Counter> consumer) {
        counters.forEach(consumer); // .forEach(c -> consumer.accept(c))
    }

    static void doSomethingNonModifying(@NotModified Collection<Counter> counters,
            @NotModified1(type = CONTRACT) Consumer<Counter> consumer) {
        counters.forEach(consumer);
    }

    static void forEach(@NotModified Collection<String> strings, Consumer<String> consumer) {
        strings.forEach(consumer);
    }
}
----

Observe that we now use {nm1} on fields, with the predictable meaning: the parameters of the field's single abstract method will not be modified.
The {e2immu} analyser can also attach this dynamic type annotation to methods which return a functional interface.

In the first two methods, the analyser knows which `Consumer` object will be handed to `forEach`.
It finds that in the first method the collection's object graph containing the counters will be modified.
In the second method, the same object graph will remain unchanged.

How does it do this?
By definition, for the parameter `counters` to be {modified} a modifying method needs to be applied to it.
This does not happen: `forEach` as a method is not modifying.
However, `forEach` feeds the elements of the collection into a modifying `accept` method, as indicated by the {exposed} annotation.
As such, the object graph of the collection, containing the individual elements, changes.

The {exposed} annotation on `forEach` links the consumer to the scope object of `forEach`: `counters`.
Because the argument to `forEach`, `incrementer`, is not explicitly {nm1}, it has to assume that modifications propagate into `counters`.
In the second case, the argument, `printer`, is explicitly {nm1}, which prevents modifications to take place because of the `forEach` method call.

In the third and fourth method, however, the implementation of the consumer comes from outside the type.
We cannot know whether the consumer will modify the collection's object graph.
In the fourth method, by annotating with {nm1}, the user shows intent, and asks the analyser to make sure the consumer's `accept` method is non-modifying.
As a consequence, the analyser computes that `counters` is {nm}.
In the third method this intent is absent, and the analyser must conclude that `doSomethingModifying` modifies `counters`.

The fifth case shows the strength of immutability.
Because strings are level 2 immutable, we know that no consumer can change the individual strings, and we know that `forEach` as a method is not modifying.

==== Annotating _consumer_

The `consumer` parameter of the `forEach` method can have a modifying single abstract method, or not.
This depends on whether `accept` makes modifications to its closure (the object graph of all fields of the implementation of the interface, including the variables of the enclosing type if there is one).

From the point of view of `Collection`, this closure will always be 'outside', i.e., not inside its own definition.
Only when that is the case, can we justify annotating with {modified}.

Consider the following simpler example, again employing `Counter`:

[source,java]
----
class OneOrOther {
    private final Counter = new Counter();

    @Modified // <1>
    private final Supplier<Integer> addOne = () -> counter.increment();

    @Modified // <2>
    public int increment() {
        return addOne.get();
    }
}
----
<1> `addOne` is {modified} because there is a method that calls one of its modifying methods.
<2> `next` is {modified} because `addOne.get()` modifies.

In this modifying situation, `addOne` is simply a modifying method in disguise.
The modification status of the single abstract method can only be seen in the following representation:

[source,java]
----
@Modified
private final Supplier<Integer> addOne = new Supplier() {

    @Modified // <1>
    public Integer get() {
        return counter.increment();
    }
}
----
<1> This annotation is not visible using the lambda syntax.

==== Summary

In tabular form,

.Annotations of an object of function interface (return) type with modifying SAM
[options=header]
|===
| The annotation on ... | parameter | field | method
| {modified} | is the norm when the method applies SAM, because SAM is modifying | *with declaration*: if it changes other fields; is the norm otherwise (assume self-modification) | N/A
| {nm} | *contracted*: no implementations with SAMs allowed that modify this scope: overrides {modified} on SAM; can co-exist with {exposed} | *with declaration*: if it does not modify other fields; *contracted*: via linking, enforce that no implementation has a self-modifying SAM | N/A
| {exposed} | modifications to the parameters are out of scope, which helps non-modification of the method: overrides {modified} on SAM's parameters; no effect on argument | modifying SAM only takes objects with out-of-scope modifications, across all usages; does not exclude {nm}, {modified} | Return type: FI returned has a modifying SAM which only takes objects with out-of-scope modifications in this method
| {nm1} | *contracted*: no implementations which modify their parameters allowed; sets SAM's parameters to {nm}: can co-exist with {nm}, stronger than {exposed} | computed via declaration or linking;  does not exclude {nm}, {modified} |  Return type: computed via declaration or linking
|===

It is important to note that all modifications relating to a scope are relating to the scope of the type in which the declaration takes place.

The {modified} annotation on a method with functional interface type parameters is the norm when these parameters are applied to part of the fields' object graph, because their SAM's parameter is {modified}.

When {nm} is _contracted_ on a method with functional interface type parameters, the analyser will enforce that the method receives no argument which is an implementation which calls self-modifying methods.
Apart from implying all other non-modification rules, this is equivalent to contracting {nm} on all parameters of a functional interface type.

As for the _computation_ of {nm} on these methods, {exposed} causes the analyser to ignore modifying parameters in SAMs.

=== Immutability

Now we must verify when and how functional interfaces are compatible with the rules of level 2 immutability.

The first rule states that fields must be {nm}.
This is also relevant in the case for functional types, when they are defined in the type:

.Example with functional type, modifying at the single abstract method level
[source,java]
----
class SetBasedContainer6<T> {
    private final Set<T> data;
    private final Consumer<T> consumer = t -> data.add(t);
    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }
    public void add(T t) {
        consumer.accept(t);
    }
}
----

In this example, the consumer modifies `data`, hence `add` is a modifying method.
The type cannot be level 2 immutable, the underlying cause being that the single abstract method of the field `consumer`
is modifying.

We argue (for now, without being able to motivate too rigorously) that most functional types should not be counted as support data:
they do not provide 'support space' for the simpler types that the class is dealing with.

Parameters of functional interface type are important to the independence rules of support data fields, however.
We have seen that a visitor pattern exposes elements for modification outside the type.
In reactive frameworks, like https://vertx.io[vertx.io], functional interface parameters are the default means of 'returning' or propagating values.

The independence rules for support data exist to ensure that the support data cannot be modified outside the type.
One would think to add a specific rule for parameters of functional interface type, such as "A method is independent when for each of its parameters of functional interface type, the objects linking to the arguments of the single abstract method must not link to the fields of the class." However, it turns out that {nm1} and the first rule of level 2 immutability take care of the situation.

Consider the following three methods added to an example from above:

.Modification of v3 as defined above
[source,java]
----
class SetBasedContainer3_3<T> {
    private final Set<T> data;

    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }

    public Stream<T> stream() {
        return data.stream();
    }

    public void unsafeVisit(Consumer<Set<T>> consumer) {
        consumer.accept(data); // <1>
    }

    public void safeVisit1(@NotModified1 Consumer<Set<T>> consumer) {
        consumer.accept(data); // <2>
    }

    public void safeVisit2(Consumer<T> consumer) {
        data.forEach(consumer); // <3>
    }
}
----
<1> The consumer exposes the support data field `data` to the outside world.
<2> The consumer exposes the support data field `data` safely.
<3> The consumer exposes `T` elements to the outside world.

In the first case, the consumer is not {nm1}, so `accept` has a parameter which is {modified}.
Therefore, sending `data` as an argument to such a parameter causes modifications, which makes `data` {modified}, which in turn violates the first rule.

The method `safeVisit1` exposes the support data to the outside world, with a guarantee from the analyser that no code can modify it.
This would again violate the tentative independence rule imagined above; however, it seems a perfectly safe thing to do: the analyser will guarantee that the consumer does not modify the whole support data's object graph.

In the third case, we first observe that `forEach` does not modify `data` because it is not a modifying method.
As explained in <<linking-part2>>, we observe that the `forEach` method does not link `data` to `consumer`.
However, because of the {exposed} annotation, it exposes elements of type `T` to the outside world.
This is compatible with level 2 immutability rules for fields that are not support data.

We conclude that no specific rules need adding or tweaking to the definition of level 2 immutability because of functional interfaces.
On the other hand, we are due a more detailed explanation of how to compute linking and exposure.




==== Abstract methods

In terms of modification, abstract methods can in theory be either: it depends on the concrete implementation.
Sometimes we can contract them, as in the case of a collection's methods; otherwise, we explicitly want to avoid contracting, as for functional interfaces.

Elsewhere, we've argued that inside the method calling an abstract method which has arrived as a parameter, the abstract method can be treated as _non modifying_.
The effect will be on the object of the concrete instance that was passed on as argument.
Therefore, we annotate the parameter with {propagateModification}, to inform the analyser that modification needs to assessed at the point where the concrete implementation is passed on as argument to the parameter.

[source,java]
----
interface T {
    @Modified
    void doSomething();
    @NotModified
    void print();
}

interface Consumer {
  // Method unmarked
  void accept(T t); // Parameter t unmarked
}

class SomeContainer {
  private T someT;
  ....
  @NotModified
  public void forEach(@PropagateModification Consumer consumer) {
    consumer.accept(someT); // internally, non-modifying action
  }
  ...
}

public void loop1(SomeContainer sc) {
    sc.forEach(T::doSomething); // changes to T object in SomeContainer
}

public void loop2(SomeContainer sc) {
    sc.forEach(T::print); // no changes to T object in SomeContainer
}

public void loop3(@Modified1 SomeContainer sc) {
    sc.forEach(this::someModifyingAction); // changes to 'this', not to T object
}

@Modified
public void someModifyingAction(@NotModified T t) { ... }
----

In `loop1` and `loop2` no modifying method is called on `sc`, so according to the rules of modification, the parameter `sc` is {nm}.
However, because of the  {propagateModification} on the consumer, we know that inside `sc`, some object will be changed.
This, we indicate with {m1}:

[source,java]
----
public static void loop1(@Modified1 SomeContainer sc) {
    sc.forEach(T::doSomething); // changes to T object in SomeContainer
}
----

#TODO# situation is different when `accept` takes another parameter (instead of a field) as argument.

#TODO# situation where a field is modified.

In `loop2`, {nm1} is implicitly present.
We can contract the latter annotation instead of computing {propagateModification}:

[source,java]
----
class SomeContainer {
  private T someT;
  ....
  @NotModified
  public void forEach(@NotModified1 Consumer consumer) {
    consumer.accept(someT); // internally, non-modifying action
  }
  ...
}
----

If we define it to indicate that concrete consumers cannot modify their parameters, the implementors of `forEach` are guaranteed that no changes to `someT` take place.
In this way they can avoid the independence requirement for level 2 immutability.

#TODO# inconsistency?
No. {modified} means that a change on the object, or subgraph.
{m1} indicates no change on object, only subgraph.
{nm} {m1} means that the change is only in the subgraph.
{modified} {nm1} means that the change is only in the object, not in the subgraph.

Summarising what we currently have:

====
{propagateModification} is used on parameters of types with at least one abstract method, to indicate that this abstract method has been called inside the method.
The argument of the abstract method is not a constant, and is not linked to another parameter.

{m1} is used when there is a potential modification on objects held by the object annotated.

====

NOTE: Attentive readers feel that they are facing a full-blown recursion here.
However, software developers are humans as well, and will not work easily with 3rd, 4th level functions.
We will stick to one, and later maybe a second level; after all, we're trying to make a practical tool and not a theoretically closed system.
There are too many combinations possible, even if we restrict to one level.

==== Example: iterators

An iterator can never be a level 2 immutable object: it has to hold state.

[source,java]
----
interface Iterator<T> {
    @Modified boolean hasNext();

    @Modified T next();

    @Modified default void remove() { throw new UnsupportedOperationException(); }

    @Modified // computed
    default void forEachRemaining(@PropagateModification Consumer<T> action) {
        while(hasNext()) action.accept(next());
    }
}
----

The nature of `remove` is radically different from that of the `next`, `hasNext` combo, however.
An iterator is independent of the type it iterates over: the modifications made by `next` and `hasNext` are restricted to the iterator itself, whereas the modification made by `remove` plans to modify the underlying type.

.Iterator, attempt 2
[source,java]
----
interface Iterator<T> {
    @Modified @NotModified1 boolean hasNext();

    @Modified @NotModified1 T next();

    @Modified @Modified1 default void remove() { throw new UnsupportedOperationException(); }

    @Modified // computed
    default void forEachRemaining(@PropagateModification Consumer<T> action) {
        while(hasNext()) action.accept(next());
    }
}
----



