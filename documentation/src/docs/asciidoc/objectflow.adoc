== Object flows

An `ObjectFlow` object records the flow of objects of a given type throughout an application.

A typical origin of an object flow is an new object creation expression, which takes place in either a method, or field assignment.
In the following example statement, the expression creates a `StringBuilder` object, accesses the `append` method repeatedly, and then discards the `StringBuilder` object in favour of a `String`:

[source,java]
----
return new StringBuider().append(i).append("+").append(j).toString();
----

In general, there are three different ways of moving the object outside the creating method:

. the method returns the newly created object
. the method passes on the newly created object as an argument to a method call (either static, or on another object).
. the method assigns the newly created object to a field inside the class.

There are four different origins:

. new object creation (`NEW_OBJECT_CREATION`)
. incoming flows from outside the method via parameters (`PARAMETER`), or as a return value of method calls or operators (`RESULT_OF_METHOD`)
. chaining of flows inside a method (`INTERNAL`)
. literals (attached as statics in the type, `LITERAL`)

In the light of eventual immutability, we consider a state change where, after calling a certain method, the object becomes immutable.
Once immutable, calling one of the modifying methods results in an error.

The type of the object flow is as specific as we can be.

We do not create flows inside a class, i.e., on the `this` object.

=== Components of an object flow

Many instances of the `ObjectFlow` object linked together describe a single object flow.
The object has the following defining components:

* a type
* a location
* an origin type

augmented by the optional components:

* a (potentially empty) list of predecessor flows
* a (potentially empty) list of non-modifying method and field accesses
* a (potentially empty) list of non-modifying method call-outs (where the flow is used as an argument)
* optionally one modifying method access or one modifying method call-out, but not both
* a (potentially empty) list of successor flows

It is important to note that we allow only modification in the flow object, while we record all non-modifying ones without keeping track of the sequence.
As soon as the analyser encounters a second modifying call, the object flow splits into two flows, each with one modifying call or call-out.
The main reason is that each modification may be the one causing a state change (from mutable into immutable).

=== Registration of an object flow

An object flow connects to object flows in other methods and fields.
Even though of these methods or fields may not have been analysed yet, we still want to make bi-directional links:

* from a call-out to the `previous` set of a `PARAMETER` flow
* from a new internal flow of origin `RESULT_OF_METHOD` to the `next` set of the return flow of a method

To this end, fields, methods and parameters have an initial flow registered using a `FirstThen` construct: at the end of analysis, the analyser `fixes` a permanent one.

The statement analyser first registers new flows of origin `RESULT_OF_METHOD`, `PARAMETER`, `NEW_OBJECT_CREATION`, and `INTERNAL` in the evaluation context.
It does so for each iteration, therefore it is important not to add these _unfixed_ flows to other flows that have already been fixed.
Only when the analyser encounters no delays, it fixes the flows of the method or field.
It writes flows of origin `PARAMETER` to their permanent place in `ParameterAnalysis`; all others stay in the `internalObjectFlows` set of `MethodAnalysis` or `FieldAnalysis`.

Summarizing registration, we have _before_ analysis:

. field, method result, and parameter have an initial flow object.
The initial flow objects of field and method receive downstream object flows, registered in `next`, for results of method calls, and field access.
The initial parameter flow object receives upstream flows in `previous`, for call-outs.
Note that flows referring to the above must do this only once, at the end of their analysis step.
. there cannot be references to literals, internal flow objects, new object creations.

During analysis, which consists of multiple iterations, we register as follows:

. new objects, parameters, results of method calls and operators, are stored in the evaluation context's `internalObjectFlows`.
The analyser discards them at the end of the iteration if it has encountered a delay.
. when the analyser splits a flow, it also adds the flow to the internal object flows.
It links both flows bi-directionally.
Importantly, only _local_ flows (created during the iteration) can be split.
. literals:

At the end of analysis:

. the method analyser separates parameter flows from the other flows in the evaluation context, and replace the initial parameter flow with the final one.
It takes the incoming flows of the initial one (in `previous`) and adds them to the final one.
It also replaces the old flow object with the new one in each of the call-out sets.

. for each of the field accesses and results of methods, it adds the reverse link

After analysis:

. only field, method result, and parameter flows are accessible.

They have been set to their permanent state.

=== Examples

Let us start with a small bit of code:

[source,java]
----
class X {
    public final int i;
    public final int j;

    public X(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public String toString() {
      return new StringBuider().append(i).append(" x ").append(j).toString();
    }
}
----

The statement in the `toString` method represents one `ObjectFlow` object of the type `StringBuilder`, in the location `X.toString()`, with a new creation and four method calls.
This flow does not link to the object flows of `i` and `j` (occurring in the two `append` calls) because they belong to the `this` object.
The last method call returns a `String` object, which is outside the scope of object flow for `StringBuilder`.

It creates an object flow of type `String`, in the location `X.toString()`, with a parent linking to the `ObjectFlow` in `StringBuilder.toString()`, and a list representing the return statement and all the uses of the `X.toString()` method.

Using the class `X` in an admittedly silly way,

[source,java]
----
class UsingX {
  public final X x12 = new X(1, 2);
  public final X x44 = new X(4, 4);

  public X mix(X x) {
    return new X(x12.i + x.i, x44.j + x.j);
  }

  public String toString() {
    return x12+", "+x44;
  }
}
----

In the locations `UsingX.x12` and `UsingX.x44` we create flows that consists solely of the creation of an object of type `X`.

In the `mix()` method, we create a flow for the argument `x`.
It consists of links to source flows (those flows calling out to `mix`), and two references to a field access.
We create a flow for the return statement consisting of a creation of type `X`, and the set of links to the return statement.
The creation call links to a newly created flow with origin `x12`, and field access `i`, and, similarly, to a newly created flow with origin `x44` and field access `j`.

The flow in `UsingX.toString()` is a concatenation of strings.
Regardless of the implementation of the concatenation, the flow should connect to the `X.toString()` method's object flow twice:
one with a flow with origin `x12` and a method access `toString()`, and once with a flow with origin `x44` and method access `toString()`.

==== Flow versus usage

Should we also attach the access flows of `x12.i`, `x.i`, `x.j` and `x44.j` to `next` sets of `i` and `j` in `X`?
From the point of view of recording usage, I'd say yes.

Consider

[source,java]
----
class UsingX_2 {
    public final X x;

    public UsingX_2(int v) {
        x = new X(v, 1);
    }
}
----

A flow passing through this class ends in `X.i`.

==== Multiple return statements

Multiple return statements matter insofar there are callouts or modifying statements in between.
Here we can distinguish two distinct flows:

[source,java]
----
class UsingY {
    public Set<Y> wrap(Y y) {
        if(y.isModifiable()) {
            y.modify();
            return Set.of(y, someOtherY);
        }
        return Set.of(y);
    }
}
----

This raises a number of problems: how would we know which flow to connect to when constructing the flow of `y` when calling `wrap`?

