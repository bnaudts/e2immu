=== Method resolution

Java allows for method overloading (the same name, with different signatures) and overriding (same name, same signature, but in a super-type), which makes it difficult to determine or _resolve_ a method given name, scope (the object or type on the left hand side) and parameters.
As we will see, generics, functional interfaces and lambda's complicate the picture significantly.

Terminology-wise, we use a formal definition

[source]
returnType = type . methodName ( parameter1, parameter2, ... )

In a concrete context, this becomes

[source]
result = scope . methodName (argument1, argument2 ,... )

==== The basic mechanism

The straightforward mechanism of resolving a method is the following procedure:

. evaluate the scope, determine the scope type
. collect all methods with the given name, in the type and all super-types, with a number of parameters compatible to the number of arguments (because of _varargs_ this has to be compatible, not equal!)
. one by one evaluate the arguments, and determine their type
. filter out the methods where at least one argument's type is not assignable to the parameter's type
. ensure that the remaining methods are all overrides of each other
. sort according to parameter specificity, and take the most specific one

Let's cover some simple examples

[source]
----
java.lang.Math: int max(int, int)
java.lang.Math: long max(long, long)
----

This is an example of overloading combined with types which are asymmetrically assignable to each other.

[source]
----
java.util.Collection: int size()
java.util.Set:        int size()
----

This is an example of overriding; if the scope turns out to be a set, then the 2nd should be chosen.

Let us now introduce generics, and consider

[source]
----
java.util.Set<E>: boolean add(E e)
----

If the scope turns out to be a `Set<String>`, then we'll expect a `String` first argument.
In fact, as long as there is one type parameter, and the return type is the same as that of a parameter, the result's type (or concrete return type) can be determined easily:

[source]
----
java.util.Set<E>: static <E> Set<E> of(E e1, E e2)
java.util.Set<E>: static <E> Set<E> of(E... elements)
----

Apart from having to choose between the two methods (varargs getting lower priority), a call `Set.of("a", "b")`
has a formal return type of `Set<E>` and a concrete one of `Set<String>`.
In this situation the concrete value for the type parameter can be easily obtained from the arguments, and the one of the result simply follows.

Step 3 (one by one evaluate the arguments) comes before we know which method will be the final choice; it follows that in the basic procedure, the arguments are evaluated outside of the context of the method.
Problems start when the arguments cannot be evaluated independently of the context of the method.
This happens often with _method references_ and _lambdas_ without explicit parameter types, in the context of a _functional interface_.

==== Functional interfaces

A functional interface is an interface which has one abstract, non-static, non-default method.
This method is, for all intents and purposes, equivalent to the functional interface:

[source]
java.util.function.Function<T, R>:  R apply(T t)

Note that this is an interface, which means that a class implementing the interface must present some `apply` method with the specified argument and result type.
The logic of a lambda `t -> logic(t)` is in the method body of this `apply` method.
However, the class is nowhere to be seen.
This is why it may appear like `R apply(T t)` is a static method, even it is not.

So consider

[source]
List<A> as = ...;
as.stream().map(a -> a.toString()).collect(Collectors.joining())

The lambda `a -> a.toString()` cannot be evaluated in isolation, because we have no idea of which type `a` is.
But working from left to right, we can find the method `stream()` on `List`, with concrete return type `Stream<A>`.
The method `map` is defined as follows:

[source]
Stream<T>: <R> Stream<R> map(Function<? super T, ? extends R> function)

Ignoring the covariance and contra-variance aspects, we see that to find a concrete return type for `map`, we must evaluate its parameter.
We cannot evaluate its parameter in isolation, but we can evaluate it in the context of the functional interface `R apply(T t)`, or, concretely, `R apply(A t)`, because working from left to right we have already determined that were dealing with a `Stream<A>`, `A` being the concrete type for the formal parameter `T`. Knowing that in `a -> a.toString()`, `a` is of type `A` allows us to evaluate the lambda body, and determine the return type `R` (which is `String` as you would have guessed, but there's _no_ guarantee).
After evaluation of `map`, the chain continues to the right, this time on a `Stream<String>`.

Consider the more complicated example:

[source]
----
Map<T, Set<T>> toDo = ...;
toDo.entrySet().stream().min(
    Comparator.comparingInt(e -> e.getValue().dependsOn.size())).orElseThrow()
----

