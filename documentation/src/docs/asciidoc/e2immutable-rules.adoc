=== New discussion 20200421

Slightly simplified definitions.

content modification::
We define content modification as the calling of methods on an object that cause changes in the fields of the object.

link:: A link between two variables occurs when modifications in one object, cause modifications in the other as well.
This typically occurs when object has been embedded in the other.
Links cannot occur between variables of primitive or @E2Immutable types.

@NotModified on parameters::
No code _in the class_ can make content modifications to such parameters or variables linked to such parameters.
Implicit for primitives and @E2Immutable types.
Note that we do not allow assignments to parameters.

@NotModified on methods::
No code in the method makes any assignment or content modification to any of the fields.

@NotModified on fields::
No code _in the class_ can make content modifications to the field.
Implicit for primitives and @E2Immutable types.
We will allow assignments to fields (i.e., not @Final) while guaranteeing @NotModified.

It is important to realise that `@NotModified` works on static and on instance fields.

@Independent on methods:: There is no link between this method's parameters and any of the fields of the method.
Neither is there a link between the return value, if present, and the parameters.
Because modifications cannot occur between variables of primitive or @E2Immutable types, there's no need to require @Independent when parameters and return type are of these types.

@Final on fields::  field is effectively or eventually final: it is not assigned to outside construction time.

@E1Immutable on fields:: dynamic type annotation (the concrete type is @E1Immutable, even if the formal type is not)

@Container on type:: a container is a type where all parameters of non-private methods and constructors are <<notmodified-annotation>>, unless they are explicitly marked @Output.
+
This definition means that inside the class, there is no code that modifies the objects to the class.
Other objects can, internally, be constructed, modified, etc., at will.
At the same time, outside the class, these objects can be modified as well.
A @Container is a 'safe place' to store objects, allowing you complete freedom to modify the objects knowing that the storage code will no touch them.

@E1Immutable on type:: a class is effectively or eventually (level 1 or assignment) immutable when all its fields are @E1Immutable.

@E1Container on type:: @E1Immutable and @Container type; maybe not that important a type, but we'll see it often. `Pair` is the archetypal example.

@E2Immutable on type:: a type is effectively or eventually (level 2 or content) immutable when
. all its fields are @E1Immutable
. all its fields are <<notmodified-annotation>>
. all its fields are either private, or <<e2immutable-annotation>> themselves
. all its constructors and non-private methods are <<independent-annotation>>.

Because all fields are @NotModified, the methods must be @NotModified as well in an @E2Immutable type.

@E2Immutable, @E1Immutable, ... on a field or parameter:: the code analyser should be able to deduce from the flow of the code that this object, even though its formal type does not have this property.

@E2Container:: a type is an effectively or eventually immutable container when, on top of the definitions of @E2Immutable, all methods and constructor parameters are @NotModified.
As far as we can see now, many @E2Immutable types will have this additional property.
Borderline situations would be like

[source]
----
@E2Immutable
class SomeClass<T> {

  @E2Immutable
  public final Set<T> immutableSet;

  ...

  public void enrich(Set<T> input) {
    input.addAll(immutableSet); // <1>
  }
}
----
<1> This action ensures that the `input` parameter is not @NotModified.
It generally would make more sense, though, to move this method to the place where it is used:

[source]
----
class CanBeEnriched {
  Set<T> ts = ...;

  void enrich(SomeClass<T> someClass) {
    ts.addAll(someClass.immutableSet);
  }
}
----

The class `java.lang.String` is an @E2Container. `List` is not a container, because of the `toArray` method.
We provide an exception with the @Output annotation.

@NotNull on parameters:: an exception will be thrown when null value is passed to this parameter

@NotNull on methods:: the method never returns null

@NotNull on fields:: the field's value cannot be null.
This is only relevant when either
+
. the field is @Final
. the field is `private`, it has an initialiser, and both the initialiser and all assignments in all methods are guaranteed not to render a null value

@UtilityClass:: an @E2Immutable class with only static methods and static fields, private constructors only, and no means of creating instance objects.

@ExtensionClass:: an @E2Immutable class (can be @UtilityClass, but doesn't have to be, it can have instance variables) where all non-private static methods have an instance of the same type as their first parameter.
If they do not have parameters, the return type of the method is considered.
Extension classes are often not @E2Container, as the static methods are likely to modify the content of the first parameter based on the value of other parameters.

@Singleton:: private constructors only, exactly one public static field containing an object.