
== Motivation

Software development managers responsible for larger projects need to keep a eye on 
many aspects of code quality, from naming and inline documentation to standardisation of the use of paradigms. 
As an object oriented programming language increasingly equipped with functional programming machinery, 
Java provides many such paradigms: it is very difficult to write code that is maintainable in the long term. 



One of the more crucial aspects of understanding the code of large software projects is to try to assess
the _object lifecycle_: when and how are objects modified? In object oriented programming, full of public getters and
setters, objects can be modified all the time. In many a functional set-up, objects are immutable. Java allows for the
whole scala from OO to functional, and different parts of the JDK and many popular libraries are positioned
all across this range.

An easy way to envisage the life cycle of an object is to assume that it consists of a building phase, followed
by an immutable phase. We set out to show that there are many different forms of immutability, from very strict
deep immutability to weak guarantees of non-modification, that can be made explicit in the code. We believe that
code complexity can be greatly reduced when the software engineer is made aware of the state of objects.

Enter {e2immu}, a set of definitions and a fully implemented code analyser to enforce the ideas behind them.
Using {e2immu} in your project will help to maintain higher coding standards, the
ultimate beneficiary being code that will survive longer.

=== Assumptions

We discuss the Java language, version 8 or higher. We have already indicated that we believe that Java offers
too much freedom to programmers. In this section, we impose some limits that are not critical to the substance of
our discussion, but facilitate reasoning. Think of them as low hanging fruit programming guidelines.

-  Exceptions do not belong to the normal programming flow; they are meant to raise situations that the program does not want to deal with
-  Parameters of a method are never assigned to in the implementation of the method.
The simple way out of this is to create a new local variable, and assign it to the parameter.
So we'll treat parameters as if the have a `final` modifier.
-  Fields can only be non-`final` if they are `private`. We do not trust `protected` and package-private without the `final` modifier.
We're quite happy with `public final` fields rather than getter methods!
-  Static fields can only be used for non-constant purposes in very limited circumstances;
one example is a variable to check enforce a singleton. The whole topic of using statics to access thread-local variables will lead us too far.
-  Methods must be static if they do not read or write non-static fields, and do not implement or overload some interface or class method.
-  Synchronization is orthogonal to the data of the program; whilst it may have an influence on _when_ certain code runs,
it should not be used to have a bearing on the semantics of the code.

=== Containers

An object is _immutable_ if it cannot be modified. It is _deeply immutable_ if all objects contained in it,
recursively, cannot be modified. The base for this recursive definition are primitives and standard classes such as
`java.lang.String`: a class with `final` fields of these types, is immutable.

A _container_ is our term for a generic data structure: a class that can hold objects, but that does not modify them.
The JDK collection classes are containers: because the objects they hold are characterized by a generic type parameter
(often without bounds, as written `<T>`), the only methods that can be applied to the objects are
the ones from `java.lang.Object`, and they are not meant to make modifications to the object.
Let's discuss some of them:

The method `int hashCode()` returns a hash code computed over the fields of the object, with the intention of producing
different codes for different instances. But, if run on the same instance, it must produce the same hash code.
This requirement hints at some sort of immutability of the fields that are defining for the object.
In the specification of the method, there is no mention of a requirement to not change the fields or their
content while computing the hash code. It just seems pretty natural not to do this, especially given the requirement
of producing the same value over time for each instance.
By marking the method <<notmodified-annotation>>, we will enforce that all overriding implementations of `hashCode`
do not make modifications to the fields or their content.

Similarly, we do not expect `boolean equals(Object other)` or `String toString()` to modify the fields or their
content: they should be implemented by reading the value of the fields. We mark them <<notmodified-annotation>> as well.

One additional restriction that a <<notmodified-annotation>> annotation on the
method places on its implementation is that it does not modify the parameter's content either.
In the case of `equals`, such a modification is difficult but not inconceivable:
a malicious implementation could contain `instanceof` conditions, and `clear` any incoming `Set`.
Our code analyser will guarantee the absence of such unexpected behaviour.

So when we mark a class <<container-annotation>>, we will enforce that, informally speaking,
there is no way that the methods of the container modify the content of the objects passed to the class.
This we will now formally define, and illustrate with examples.

=== Modifications and links

How do we define _not modifying the content of an object_? 

Looking from inside of this object, a modification of a the content  means that an assignment to a
field or any of its sub-field, sub-sub-field, ... is made. From the outside, unless there is public write
access to said field of course, the modification can only take place by calling some method that executes it.
Methods that only read fields of an object, do not modify it. Methods that somehow cause an assignment
inside the object's fields, do.

Intuitively, on any implementation of `java.util.Set`, one expects the `boolean add(T t)` method to make a
change to the fields of the set. Similarly, `int size()` should not make changes to fields. It may use a
local counter, but it typically will not assign to fields.

Note, again, that there is nothing in the interface that prohibits `int size()` from changing the set.
We will mark it <<notmodified-annotation>>, so that no implementation can actually do so. We cannot mark the `add`
method with <<notmodified-annotation>>, because this method makes changes to the set.

Consider the following artificial Java class:

.MyThings.java
[source]
----
class MyThings {
    private int counter = 0;
    private final Set<String> strings = new HashSet<>();
    private final List<Integer> numbers = new LinkedList<>();

    void increment() {
        counter = counter + 1;
    }

    void addNumber(int i) {
        numbers.add(i);
    }

    void addString(String message) {
        Set<String> theSet = string;
        theSet.add(message);
    }
}
----

All three methods modify the content of a field in `MyThings`. Only `increment` can assign to a field directly;
calling `numbers.add()` causes a modification to the content of `numbers`. Note that `addString` tries to do this in a
roundabout way, but nobody is fooled: it is the same object that is modified, even if
the call takes place on a local variable.

The code analyser _links_ the field `string` to the local variable `theSet`. Changes made to the latter
propagate to the former. These links are necessary to properly assess modification; we will encounter them,
and the absence of links denoted by the <<independent-annotation>> annotation, later in the text.
Any assignment potentially creates a
link from the variables in the right-hand side to the variable on the left-hand side of the assignment.
Direct assignments obviously do, as in the first line of `addString`. Many others don't, and never when
immutable objects are involved. For example, `int i = j+1` does not link `i` to `j`: both are independent in their own right.

Parameterized method calls on non-immutable objects in the right-hand side are the ones to watch: 

[source]
----
MySet<T> mySet3 = mySet1.someAction(mySet2);
----

The `someAction` method could be an identity function returning `mySet2`, which would link `mySet3` to `mySet2`;
it could be a fluent one, returning `this` and therefore `mySet1`, which would link it to `mySet1`;
thirdly, it could somehow join the two sets and force a link from both `mySet2` and `mySet1` to `mySet3`;
finally, there could be no link whatsoever, because a new `MySet` object was created.

Back to the topic of modifications. Fields as well as parameters of methods and constructors,
can be marked with <<notmodified-annotation>>. Primitives and immutable classes such as `java.lang.String` do not need to be
annotated, there is no way to modify their content anyway.

=== Containers: definition and example

We are now in the position to formally define containers. A class becomes a container when the
parameters of all non-private methods and constructors can be marked <<notmodified-annotation>>,
or are of a type that is not content-modifiable (<<e2immutable-annotation>>, unbound type parameter, primitive).

Fields that are linked to parameters will receive the annotation as well, because any modification on them
would result in a modification on the parameter. Fields not linked to parameters (such as an object counter)
may be modified.

It is worthwhile reiterating that variables (fields, parameters, local variables) are linked by assignments and
joint occurrence in method calls. Only special properties of those method calls, such as <<independent-annotation>>,
can ensure that the joint occurrence does not result in a link.

Typical examples of containers are the Java collection classes, and we will discuss some examples here. But let's first
discuss a simpler example:

[source]
----

----

=== Effectively final classes

Containers provide a small step toward immutability: you can give them your object, and you'll know that the container will not touch it.

Another, different step towards immutability is a type of class we'll call _effectively final_, defined as a class where
all fields are only assigned to in constructors.

Consider

.ExampleEffectivelyFinal.java
[source]
----
@E2Final
public class ExampleEffectivelyFinal {
    private int i = 3;
    private final String s = "abc";
    private boolean ready;
    private double d;

    public ExampleEffectivelyFinal(boolean ready) {
        this.ready = ready;
        compute();
    }
    private void compute() {
        d = i * i;
    }
}
----
All four fields are set at construction time, so the class is effectively final, even if it is not as
nicely phrased as it should be.

Very often, containers can be effectively final, as in the following example:

.Pair.java
[source]
----
@E2Final
@Container
public class Pair<K, V> {
    public final K key;
    public final V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public String toString() {
        return "Pair["+key+","+value+"]";
    }
}
----

The class is obviously a container: the only parameters to the single constructor are of unbound type, so no modification is possible.
An effectively final class is immutable at the level of its fields, but it is not deeply immutable since it does not protect its mutable content.

=== Eventually final classes

You may think the effectively final definition a little underwhelming, and it is. Still, there are a great many frameworks
that will require a definition a little weaker than effectively final, because they use _dependency injection_ via
dedicated methods like setters or `init` methods.
Because control over the the dependency injects rests with the framework, which will raise errors when the injection
fails, we can treat these injectors as part of the construction phase of the object.
The code analyser can help treat these dedicated methods as 'framework only',
and block the user from assigning to fields that are technically assignable.

This is where we extend the meaning of the <<e2final-annotation>> annotation to _eventually final_.
Classes with dependency injection can be effectively final for all intents and purposes, but only with the
additional caveats that the framework has to have done its job,
and that the user should not use those methods reserved for the framework.


But <<e2final-annotation>> is not limited to dependency injection. In combination with containers,
it allows for data structures that are solidly level 1 immutable.
Consider the class `SetOnce`, which the analyser internally uses to do delayed assignments in an immutable way:

.Excerpt from SetOnce.java
[source]
----
@E2Final(after = "set", compute = false)
@Container
public class SetOnce<T> {
    private volatile T t;

    @Mark("set")
    @Only(before = "set")
    public void set(@NullNotAllowed T t) {
        if (t == null) throw new NullPointerException("Null not allowed");
        synchronized (this) {
            if (this.t != null) {
                throw new UnsupportedOperationException("Already set");
            }
            this.t = t;
        }
    }

    @Mark("set")
    public void setIfNotYetSet(@NullNotAllowed T t) {
        if (t == null) throw new NullPointerException("Null not allowed");
        synchronized (this) {
            if (this.t == null) {
                this.t = t;
            }
        }
    }

    @Only(after = "set")
    @NotNull
    public T get() {
        if (t == null) throw new UnsupportedOperationException("Not yet set");
        return t;
    }

    @NotModified
    public boolean isSet() {
        return t != null;
    }
}
----

The benefit of using the {e2immu} project is that, when sufficient care has been taken, there are vast places in the code base where the
code analyser can flag an error when the user attempts to use the `set` method; at the same time, unnecessary `isSet`
calls can be flagged, and, maybe even more importantly, the analyser itself knows that the exception in `get` will not be thrown there.


=== Effective immutability

Where effectively final classes are _level 1_ immutable, effectively immutable classes are _level 2_ immutable:
all fields are protected from content changes.

=== Builders

The _builder_ paradigm describes the transition from container to effectively immutable class:
in the first part of the object's lifecycle, it is being constructed in the container class associated with an effectively immutable class.
We advocate implementing this as follows:

.InverseMaps.java
[source]
----
@E2Immutable
class InverseMaps<A, B> {

    public final Map<A, B> aToB;
    public final Map<B, A> bToA;

    private InverseMaps(Map<A, B> aToB, Map<B, A> bToA) {
        this.aToB = aToB;
        this.bToA = bToA;
    }

    @Container
    static class InverseMapsBuilder {

        private Map<A, B> aToB = new HashSet<>();
        private Map<B, A> bToA = new HashSet<>();

        @Fluent
        public InverseMapsBuilder add(A a, B b) {
            aToB.put(a, b);
            bToA.put(b, a);
        }

        @NotNull
        @NotModified
        public InverseMaps build() {
            return new InverseMaps(ImmutableMap.copyOf(aToB), ImmutableMap.copyOf(bToA);
        }
    }
}
----

The key aspect here is that the effectively immutable class's constructor is private: the builder controls the
instance creation, and guarantees that the set, which is exposed publicly, is immutable.

=== On annotations

The code analyser will determine whether a class, field or parameter has a certain property,
like <<container-annotation>> or <<notmodified-annotation>>.
Adding these annotations explicitly in the code will cause the analyser to raise errors if a certain property is not met.
This is handy because if you set out to develop a container class, this annotation will act as a guard against changes or
implementations that violate the property. Especially sub-classes developed by others may escape your attention.

A place where manually inserting annotations is necessary, are interfaces: by definition, they set out obligations
or restrictions for implementing classes to follow, so it is only natural that you set your semantic intentions by hand as well.
Because the annotations are inherited by the implementing classes, they are the most powerful means of restricting
the implementation of classes. The code analyser will fail on implementations that do not follow the interface's restrictions.

Thirdly, there is the issue of external code. The project contains annotated versions of quite a few JDK classes.
Here, we marked the methods and classes by hand rather than by analyser. Initially, we did this because we're still
developing the analyser, as some sort of bootstrapping process. But the more important reason is that we want to
change the annotations to be a little more strict than that the JDK developers designed them.

Take for example `java.util.Map`. The interface allows for `null` keys. No way I'd use this feature myself, or
allow my software engineers to use it. Similarly, every time we run the code analyser, implicitly all
overloading `toString()` methods will be checked for content modifications!

=== Eventual immutability

There are many situations where immutability can be reached after a short construction phase, but
where the builder pattern is impractical or code-wise extremely repetitive.

A first example is a large graphical structure, built using maps. If the structure is not known beforehand,
and is not guaranteed to be free of cycles, there is no practical way to construct it directly using immutable maps.
But it is maybe easy to _freeze_ the data structure: to irrevocably set a flag that blocks all further modifications.

=== Quick overview of all annotations

Core annotations are:

*  <<container-annotation>>, <<e2final-annotation>>, <<e2immutable-annotation>>
*  <<notmodified-annotation>>, <<independent-annotation>>

Supporting annotations:

*  <<mark-annotation>>, <<only-annotation>>: for state changes from _before_ to _after_
*  <<notnull-annotation>>, <<nullnotallowed-annotation>>: idem
*  <<linked-annotation>>, <<output-annotation>>: helper with modifications
*  <<identity-annotation>>, <<fluent-annotation>>: idem
*  <<final-annotation>>, <<constant-annotation>>: mostly internal

Experimental:

*  <<utilityclass-annotation>>, <<extensionclass-annotation>>
