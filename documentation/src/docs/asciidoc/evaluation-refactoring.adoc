=== Refactoring of evaluation

==== Methods

We will mark methods that are only used in the construction phase.

==== The property map

Every `Instance` object is different.

`this` instances will end up as `Instance` objects in values; however, there should be only one such per type per `VariableProperties` object.
They will not sit in the `properties` map.

Local variables will be in the `properties` map, as they are right now.
The local copy system will remain.
We will store the variables by `name` rather than by object itself.

Parameters will also be in the `properties` map (they simply cannot be assigned to).
Similar to parameters are effectively final fields of records.

Most changes will be for fields.
We will distinguish a number of different cases:

Fields during construction:: they will act like local variables for each method, named: `this.` plus name.
Of global importance is detecting `fieldRead`, `fieldAssignment`, `fieldAssignmentValue`, which can all happen directly.
Of local importance is the current value, null checks, etc.

Non-final fields outside construction:: each reading of a field will produce a different `Instance` value.
These fields will not appear in the property map.
Assignments and content modifications are reported.

Final fields:: Final fields have a value, which is either an `Instance`, `MethodValue`, or a `Constant`, but not a variable value.
These fields will not appear in the property map.
Fields during construction that become final (or are explicitly final) are treated as final fields.
Content modifications are reported.
Final fields of record type end up as having non-final fields outside construction: we simply forbid this.

Record fields in local variables:: act as local variables, initialised at creation of the record.
They will be reset when the record variable is reassigned.

Record fields in parameters:: act as local variables, with initial indeterminate values.
Names are 2-valued, like As soon as there is any assignment or content modification to these variables, the parameter cannot be @NotModified anymore.

Record fields in a field:: act as local variables, with initial indeterminate values, pretty much like fields during construction.
Names are 4-valued, like `SimpleTypeName.this.field.recordField`, or 3 valued `localVariable.field.recordField`, where the local variable must be of the same type.
Any assignment or content modification will break the @NotModified of the method.

Non-final fields during synchronization block:: act like local variables, for the duration of the block.

For example, in the comparator a comparison `this.field != other.field` will consist, in the case of final fields, of a value comparison between two non-variable values; in the case of non-final fields, of two instances, which are by definition different.

`VariableValue` is reserved for those variables that appear in the map.
The `variable` will always faithfully be the inspected variable.
The `name` will point to the location in the local map.
We probably will need to store some more info.

=== Arrays

Consider assignment to elements in an array.
We should treat them exactly in the same ways as we treat record fields: if `a` is an array, then initialisation and element assignments are assignments to two different variables, one dependent on the other for its existence:

[source,java]
----
int[] a = new int[3];
a[0]=1;
a[1]=2;
if(a[0] == 0) { ... } // should raise an error (evaluation of condition to constant)
----

The extra complication are assignments in loops:

[source,java]
----
for(int i=0; i<a.length; i++) a[i]=10;
----
Here, we would ideally see that `i` traverses the whole array.
Then, there are _arbitrary_ assignments like
[source,java]
----
int index=magicFormula();
a[index] += 1;
----
As long as `index` stays unmodified, we can create a temporary variable.
