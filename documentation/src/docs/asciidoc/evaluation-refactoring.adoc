=== Refactoring of evaluation

==== Methods

We will mark methods that are only used in the construction phase.

==== The property map

Every `Instance` object is different.

`this` instances will end up as `Instance` objects in values; however, there should be only one such per type per `VariableProperties` object.
They will not sit in the `properties` map.

Local variables will be in the `properties` map, as they are right now.
The local copy system will remain.
We will store the variables by `name` rather than by object itself.

Parameters will also be in the `properties` map (they simply cannot be assigned to).
Similar to parameters are effectively final fields of records.

Most changes will be for fields.
We will distinguish a number of different cases:

Fields during construction:: they will act like local variables for each method, named: `this.` plus name.
Of global importance is detecting `fieldRead`, `fieldAssignment`, `fieldAssignmentValue`, which can all happen directly.
Of local importance is the current value, null checks, etc.

Non-final fields outside construction:: each reading of a field will produce a different `Instance` value.
These fields will not appear in the property map.
Assignments and content modifications are reported.

Final fields:: Final fields have a value, which is either an `Instance`, `MethodValue`, or a `Constant`, but not a variable value.
These fields will not appear in the property map.
Fields during construction that become final (or are explicitly final) are treated as final fields.
Content modifications are reported.

Record fields in local variables:: act as local variables, initialised at creation of the record.
They will be reset when the record variable is reassigned.

Record fields in parameters:: act as local variables, with initial indeterminate values.
Names are 2-valued, like As soon as there is any assignment or content modification to these variables, the parameter cannot be @NotModified anymore.

Record fields in a field:: act as local variables, with initial indeterminate values, pretty much like fields during construction.
Names are 4-valued, like `SimpleTypeName.this.field.recordField`, or 3 valued `localVariable.field.recordField`, where the local variable must be of the same type.
Any assignment or content modification will break the @NotModified of the method.

Non-final fields during synchronization block:: act like local variables, for the duration of the block.

For example, in the comparator a comparison `this.field != other.field` will consist, in the case of final fields, of a value comparison between two non-variable values; in the case of non-final fields, of two instances, which are by definition different.

`VariableValue` is reserved for those variables that appear in the map.
The `variable` will always faithfully be the inspected variable.
The `name` will point to the location in the local map.
We probably will need to store some more info.

==== Not null

Evaluation will also contain a forward not-null requirement.
The good thing about such a forward requirement is that the correct actions or error messages can be raised.