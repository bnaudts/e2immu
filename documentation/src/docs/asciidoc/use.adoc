
== Using e2immu

=== Basic use

Starting your first project, basic use of the `e2immu` analyser looks like

image::e2immu_basic_use.png[title="Basic use of e2immu",id="basic-use"]

Having installed `e2immu` s IntelliJ IDEA plugin, and having started a local annotation server,
you can edit your project, occasionally run the analyser, and make use of pre-annotated libraries.

The analyser produces computed annotations, errors and warnings, which
you can of course read from the command line. It also pushes these errors, warnings, and computed
annotations to the annotation server, which is continuously consulted by the highlighter plugin.
So while you're working on your project, each time you run the analyser, your editor is updated.
We're suggesting that you confirm critical annotations in the source code.
They will get the annotation type `VERIFY` which is the default for source code read by the analyser,
they allow you to 'stabilize' your code with respect to class types like <<e2final-annotation>> or
<<e2immutable-annotation>>.

This set-up will get you pretty far, as long as

-  your project consists of a single set of source files
-  all the libraries you are using have been pre-annotated.


=== Full flow

The `e2immu` analyser is set up to read, in order of decreasing priority,

.  the source code of your project
.  annotated API sources, as a replacement for class files with XML annotations
.  class files and associated XML annotation files from jars, for libraries used in your project

If your project is or becomes a library for other projects to use, the computed annotations have to be
made available to the users of the library:

.  for fast turn-around development on your own or in small teams,
you can use the analyser run on the library. This is depicted in <<figure-fast-turnaround>>.
to upload computed annotations to the annotation store, and instruct the
analyser on the project consuming the library to consult this store. For this purpose, the annotation store
has the ability to store annotations in user-defined _projects_; the analyser can read from any such _projects_.
.  the standard procedure is for the computed annotations to be included in the `jar` file of the project:
the analyser can directly write `annotations.xml` files
in the resources of your project, one for each package. This action can take place after the compilation
phase and before the packaging phase in you build tool. `e2immu` provides a plugin for Gradle for now.
This flow is depicted in <<figure-annotated-xml-via-gradle>>.

image::e2immu_fast_turnaround.png[title="Fast turnaround use of e2immu",id="figure-fast-turnaround"]

image::e2immu_annotated_xml_via_gradle.png[title="Add annotation.xml files to your jar",id="figure-annotated-xml-via-gradle"]

If you are annotating external libraries with `e2immu` annotations,
there are two options

.  you can use the _external annotations_ feature of IntelliJ IDEA to create annotations files.
These files are best grouped into a new jar file, on per library, which is to be included
in the dependencies of your project.
.  you can use annotated API sources, a kind of Java source file which contains all the declarative
aspects of the types you'll be using. These files are quick to create, provide a nice overview,
and can be used in combination with the underlying JAR so that you only have to copy those
declarations that you want to annotate. Their main advantage is clarity: all types, fields, and methods
_relevant to you_ are close together, with their annotations

Annotated API sources can be generated by the analyser from jars and XML annotations, presenting only
those types, methods and fields that your project is using.

Updated annotation files can be generated by the analyser from the combination of annotated API sources and
existing annotation files.

=== The e2immu analyser command line

The input to the analyser is largely controlled by the following primary locations

-  `--source=<dir>`: the directories where `.java` sources are to be found. They can be `:` or `,` separated;
   the argument can also be repeated. When nothing is specified, the analyser assumes `src/main/java`.
-  `--classpath=<cp>`: the classpath. This classpath should include the `.class` files corresponding to the `.java` files
   presented to the analyser. The format is as parsed by the JDK classpath: colon separated, with wildcards for multipe
   jar files in the same directory, containing jar files, `.class` files, or directories.
   Multiple `--classpath` options may be present; all are concatenated.
   When nothing is specified, `build/classes/java/main:build/resources/main` is assumed.
-  `--jre=<dir>`: location of the JRE if a different one from the analyser's is to be taken
-  `--restrict-source=<packages>`: restrict the input to the following packages. The parameter can be comma separated,
   with wildcards as detailed in the note below.

NOTE: The Maven or Gradle plugin typically takes care of correct values for source input and classpath.

Then there are typical options like

-  `--quiet` (short `-q`): do not write warnings, errors, etc to the standard output. They are still uploaded when
   the `--upload` option is activated.
-  `--debug=<logtargets>`: log targets to activate for debug output
-  `--ignore-errors`: do not end the analyser in an error state when errors have been raised by the analyser.
They are still uploaded when the `--upload` option is activated.

The following options are available to control the output to the annotation server:

-  `--upload` (short: `-u`): upload annotations to an annotation server
-  `--upload-url=<url>`, change the default URL which is `http://localhost:8281`
-  `--upload-project=<project>`, change the default project which is `default`
-  `--upload-packages=<packages>`: a comma-separated list of package names for which annotations are to be uploaded.
The default is to upload all annotations of all types encountered during the parsing process.

The following options are available to control the files written:

-  `--write-annotation-xml` (short: `-w`): create annotation files to be included in the
   resources, and hence the jar of the project.
-  `--write-annotation-xml-packages=<packages>`: a comma-separated list of package names for which annotation.xml files
    are to be written. The default is to write them for all the packages of `.java` files parsed
-  `--write-annotation-xml-dir=<directory>`: alternative location to write the Xml files. Defaults to the resources
   directory of the project.
-  `--write-annotated-api` (short: `-a`)
-  `--write-annotated-api-packages=<packages>`: a comma-separated list of package names for which annotated API files
are to be written. The default is to write them for all the packages of `.java` files parsed
-  `--write-annotated-api-dir=<directory>`: alternative location to write the annotated API files. The default is the
main directory of the project

NOTE: When describing packages, a dot at the end of a package name may be used to indicate the inclusion of all
sub-packages. The wildcard `java.` includes `java.lang`, `java.io`, etc.

=== Using the Gradle plugin

The easiest way to use the analyser is via the Gradle plugin.

[source]
.Example of `build.gradle` file
----
plugins {
    id 'java'
    id 'org.e2immu.analyser'
}

...

repositories {
    ...
}

dependencies {
   ...
}

e2immu {
    skipProject = false
    sourcePackages = 'org.e2immu.'
    jmods = 'java.base.jmod,java.se.jmod'
    jre = '/Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/Home/'
    writeAnnotatedAPIPackages = 'org.e2immu.'
    writeAnnotationXMLPackages = 'org.e2immu.'
}
----

The list of properties configurable differs slightly from the one of the command line.
Gradle takes care of source and class path.


[#inheritance-rules]
=== Inheritance rules of annotations

As a general rule, we would like to impose that any class that implements an interface,
inherits all the annotations of that interface.
For example, if `java.util.List` is a container, then we want any implementation of that
interface to be a container too.

Frequently used JDK classes such as `java.lang.String` are marked `final` themselves,
so that they cannot be subclassed. But in general, it seems a bad idea to weaken contracts.
On the other hand, we can mark `java.lang.Object` as <<e2immutable-annotation>>, while obviously not all
its derived classes can be of that type.

But the marks for eventually final and immutable classes push us to add some rules.
Consider the `Verticle` interface and parts of its default implementation `AbstractVerticle`
(please refer the section <<vertx-integration>> for an in-depth treatment):

.Excerpts and annotations of Verticle.java and AbstractVerticle.java
[source]
----
@EventuallyFinal(after = "init", framework = true)
interface Verticle {

    @Mark("init")
    void init(@NullNotAllowed Vertx vertx, @NullNotAllowed Context context);

    @NotAllowed(before = "init")
    @NotModified
    Vertx getVertx();

    @NotAllowed(before = "init")
    void start(Promise<Void> startPromise) throws Exception;

    @NotAllowed(before = "init")
    void stop(Promise<Void> startPromise) throws Exception;
}

public abstract class AbstractVerticle implements Verticle {
    protected Vertx vertx;
    protected Context context;

    @Override
    public Vertx getVertx() {
        return vertx;
    }

    @Override
    public void init(Vertx vertx, Context context) {
        this.vertx = vertx;
        this.context = context;
    }
    ...
}
----

Our primary motivation here is to make sure that `vertx` and `context` are never assigned
to in code derived from `AbstractVerticle`: the code analyser will ensure they become effectively final.
On top of that, we can try to monitor calls the `getVertx` method before the verticle has been registered,
and calls to `init` from outside the framework.

Now, inside a class that derives from `AbstractVerticle`, a similar situation arises:

.MyVerticle.java
[source]
----
@EventuallyFinal(after = "start", framework = true)
public class MyVerticle extends AbstractVerticle {
    private HttpServer server;
    private JsonObject configuration;

    @Override
    @Mark("start")
    public void start(Promise<Void> startPromise) {
        server = vertx.createHttpServer(); // <1>
        ConfigRetriever retriever = ConfigRetriever.create(vertx, options); // <1>
        retriever.getConfig(ar -> {
            if (ar.failed()) {
                startPromise.fail("Cannot read config");
            } else {
                configuration = ar.result();
                startPromise.complete(); // <2>
            }
        });
    }

    private void handleRequest(RoutingContext routingContext) {
        textResult(routingContext, "a=" + configuration.a);
    }
}
----
<1> The `vertx` field has been initialised, is effectively final, and is non-null.
<2> Logical exit point of the method: only after having executed this handler,
which assigns to `configuration`, the rest of the program can continue.

The two fields in this subclass will become effectively final, but, crucially,
later than the `vertx` field. The `handleRequest` method will be only be called
after the `start` method logically ends.

Should we treat the effective finality `AbstractVerticle` and `MyVerticle` as independent?
Or do we want to impose <<e2final-annotation>> on any
concrete implementation of `AbstractVerticle`? My intuition would say _yes_, we should
do that, because of the nature of the class imposed on `MyVerticle` by the `Verticle` interface:
it is going to be a class which has a start/stop lifecycle, instantiated by a framework, where code runs
in the context of the framework and services started in that framework. Instances of this class should
not be passed on; public methods should not be available for 'outsiders'. In most situations, the start/stop
nature is binary, and while it may have a protracted starting phase, it will not become a
start/phase 1/phase 2/stop lifecycle.
But there are too many other examples where this would seem impractical.
Therefore, we'll stick to

[sidebar]
.Summary of inheritance rules
--
As a general rule, a class inherits all annotations from directly implemented interfaces, but not from
a possible parent class and its interfaces implemented.
An interface that extends another interface does not inherit the annotations from its ancestor.

However, methods inherit the annotations of methods they override.

Marks for <<e2final-annotation>> and <<e2immutable-annotation>> annotations are restricted to the methods
listed in the type that has the annotation, and the fields linked to them.
--

=== Annotating your own code

hello!

=== Annotating libraries

It follows from the discussion in <<inheritance-rules>> that there are choices to be made when annotating a library;
we can even envision different kinds of annotations on the same library.
