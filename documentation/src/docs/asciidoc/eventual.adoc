== Eventual immutability

=== @Mark, @Only

We can detect eventual immutability if the programmer follows explicit rules:

=== Dynamic annotations

How do we deal with types that are eventually `@E2Immutable`?

How to detect it?
At the formal level of the type, we can tell if it is eventual, or not, but we can only act if it is not eventually `@E2Immutable`.
Therefore, the context is important: a formal variable (parameter, field) or actual variable value (assigned to result of method) can be `@E2Immutable` as well.

As a rule, we will use:

. on a type, the `IMMUTABLE` property ignores the eventual aspect
. if a parameter or field has been annotated with `IMMUTABLE`, the eventual aspect has been resolved.
We then use this annotation to indicate that we know more about the actual type than that the formal type indicates.
This can be either because the formal type is a super type with a lower immutability status (e.g., `Set` where we know an `ImmutableSet` has been assigned), or because the eventual aspect has been solved.
. on a variable value, the `IMMUTABLE` property is the best of the formal situation (first parameter, field, then type) and a local value computed by the marks

A parameter can be `@E2Immutable` when all flows leading to it have the correct mark.
This can easily be computed when the parameter's method is private, but how do we deal with this in the non-private cases?
Consider

[source,java]
----
@E2Container(after="mark")
public class Config {
    // ...
}

public class SomeType {
  public SomeType(Config config) {
    this.config = config;
  }
  // ...
}

public class Main {
    @E2Container // <1>
    private static Config generateConfig(String... args) {
        // ... return a new Config object, call @Mark method
    }

    private Main(@E2Container Config config) { // <2>
        this.config = config;
    }

    @E2Container // <3>
    private Config config;

    public static void main(String... args) {
        Main main = new Main(generateConfig(args));
        SomeType someType = new SomeType(main.config);
        // ... do some real work
    }
}
----
<1> single return statement, known to have passed the mark
<2> computed from the incoming object flows, because the constructor is private
<3> via assignment in the constructor.

Only after analysing all types in the application, and therefore, knowing all usages of the `SomeType` constructor, can we know if the `Config` parameter in that constructor can be annotated `@E2Container`.
Note that types are analysed in the order of the dependency graph: the analyser looks at the least dependent types first.
Usage of a type is typically analyser later than the type itself.
This does not sit well with the idea that all downstream use should be marked automatically: unless there is another trick up our sleeve, we will have to manually mark `Config` as `@E2Immutable` in every constructor.

We can move in the other direction if we annotate an eventually `@E2Immutable` type `@E1Immutable` when we can guarantee that in that location, the method will modify the type's content.
Similarly, we annotate an eventually `@E1Immutable` type `BeforeImmutableMark` if in that location the method makes assignments to the type's fields.
Consider

[source,java]
----
public class ModifiesConfig {
    @Modified
    @E1Immutable
    private final Config config;

    public ModifiesConfig(@E1Immutable Config config) {
        this.config = config;
    }

    @Modified
    public void add(String s) {
        config.add(s); // modifying operation
    }

    @E1Immutable
    public Config getConfig() {
        return config;
    }
}

public class DoSomeWork {
    private final ModifiesConfig modifiesConfig;

    public DoSomeWork(@E1Immutable Config config) {
        this.modifiesConfig = new ModifiesConfig(config); // <1>
    }

    @E2Immutable
    public Config done() {
        Config config = modifiesConfig.getConfig();
        config.mark(); // call the @Mark method
        return config;
    }
}
----
<1> the `@E1Immutable` annotation travels from the `new ModifiesConfig(config)` statement to the `DoSomeWork` constructor's parameter

Consequently,

[source,java]
----
new DoSomeWork(new Config()).done(); // OK

Config config = new DoSomeWork(new Config()).done();
new DoSomeWork(config); // causes an error
----

is not because in the second line, `config` is `@E2Immutable`, or _after the mark_, while the constructor expects `@E1Immutable`, _before the mark_.

In a location that does not call modifying methods on an eventually `@E2Immutable` type, we cannot independently annotate it `@E2Immutable`, because there is no way of knowing what the mark status is.
If the method calls a modifying method, or calls out to a method that announces that it will do so, then we can add the negative annotation `@E1Immutable`.
The 'negative' annotation `@E1Immutable` for eventually `@E2Immutable` types 'travels' through constructors, which the positive one does not.

We recap the interplay between `@E2Immutable`, `@E1Immutable`, `@Modified` on parameters and fields:

. when we annotate `@E2Immutable`, we never add `@NotModified`, independent of the type being effectively or eventually `@E2Immutable`.
. when a parameter or field is `@Modified`, and eventually `@E2Immutable`, we annotate `@E1Immutable`.

=== Eventual immutability without marks

What if a type is almost `@E2Immutable`, the 'almost' due to a silently eventually `@E2Immutable` field?
Consider

[source,java]
----
@E2Container
public class ExtendedConfig {
    public final Config config;
    public final String someOtherField;

    public ExtendedConfig(Config config, String s) { // <1>
        this.config = config;
        this.someOtherField = s;
    }
}
----
<1> We could manually annotate `Config` here, to guarantee effective second level immutability.

We will consider the immutable state of an eventually immutable type to be its default state.
This is fine: ``ExtendedConfig```'s immutability can only be breached by breaching ``Config```'s,
which would cause an error.

=== Values of the IMMUTABLE property

The `IMMUTABLE` property has the following values, shown as two 3-bit components (_(i,j)_ stands for _i+8*j_):

[cols ="7,31,31,31",options=header]
|===
| value | meaning  | annotation on field, parameter, method | annotation on type
| -1    | delay | - | -
| 0,0   | delay | - | -
| 1,0   | not level 1 immutable | -  | `@Mutable`
| 2,0   | eventually level 1 immutable; value for type | `@E1Immutable` when formal type is not (eventually) level 1 immutable | `@E1Immutable(after="...")`
| 3,0   | eventually level 1 immutable, before mark | `@BeforeImmutableMark` | -
| 4,0   | eventually level 1 immutable, after mark | `@E1Immutable` | -
| 5,0   | effectively level 1 immutable, no idea level 2 .2+| `@E1Immutable` when formal type is not (eventually) level 1 immutable .2+|`@E1Immutable`
| 5,1   | effectively level 1 immutable, not level 2
| 1,1   | not level 1, not level 2 immutable | - | -
| 2,2   | eventually level 1 & 2 immutable  | `@E2Immutable` when formal type is not (eventually) level 2 immutable | `@E2Immutable(after="...")`
| 5,2   | effectively level 1, eventually level 2 immutable  | `@E2Immutable` when formal type is not (eventually) level 2 immutable | `@E2Immutable(after="...")`
| 3,3   | eventually level 1 & 2 immutable, before mark | `@BeforeImmutableMark` | -
| 5,3   | effectively level 1, eventually level 2 immutable, before mark | `@E1Immutable @BeforeImmutableMark` | -
| 4,4   | eventually level 2 immutable after mark | `@E2Immutable` | -
| 5,5   | effectively level 2 immutable | `@E2Immutable` when formal type is not (eventually) level 2 immutable | `@E2Immutable`
|===

Note that effectively level 1, eventually level 2 is possible because the precondition that governs marking can be based on the content.

Is there a pattern we can reuse for `@NotNull`, the only other one we have with multiple levels?

[cols ="10,31,31,31",options=header]
|===
| value | meaning  | annotation on field, parameter, method | annotation in owning type
| -1    | delay | - | -
| 0,0   | nullable  | `@Nullable` | `@Nullable`
| 1,0   | eventually not null, before mark | `@BeforeNotNullMark` (not field) | -
| 2,0   | eventually not null | - | `@NotNull(after="...")`
| 3,0   | eventually not null, after mark | `@NotNull` |
| 4,0   | effectively not null | `@NotNull` | `@NotNull`
| 1,1   | eventually not null & content not null, before mark | `@BeforeNotNullMark` | -
| 4,1   | not null, eventually content not null, before mark | `@BeforeNotNullMark @NotNull` | -
| 2,2   | eventually not null & content not null .2+| `@NotNull1` .2+| `@NotNull1(after="...")`
| 4,2   | effectively not null, eventually content not null
| 3,3   | eventually content not null, after mark | `@NotNull1` | -
| 4,4   | effectively content not null | `@NotNull1` | `@NotNull1`
4*| ...
| 2,2,2 | eventually contents`' content not null | `@NotNull2` | `@NotNull2(after="...")`
4*| ...
| 4,4,4 | effectively contents`' content not null | `@NotNull2` |  `@NotNull2`
|===

Some examples:

[source,java]
----
@E1Immutable(after="mark")
class SomeClass<X> {
    private X x;

    @Mark("mark")
    public void initialize(Input<X> input) {
        if(x == null) throw new UnsupportedOperationException();
        x = doSomeComputation(input); // returns not null
    }

    @NotNull(after="mark")
    public X getX() {
        return x;
    }
}
----

This is a variation on the normal `@Mark`, `@Only` scheme.

Here is an example that does not involve immutability of the type:
[source,java]
----
@Mutable
class ExampleNN1 {
    @NotNull1(after="mark")
    private final String[] strings;
    private String input;

    public ExampleNN1(int size) {
        strings = new String[size];
    }

    @Mark("mark")
    public void init() {
        String in = this.input;
        Arrays.fill(strings, in == null ? "?" : in);
    }

    @NotNull1(after="mark")
    public Stream<String> getStrings() {
        return Arrays.stream(strings);
    }

    public void setInput(String input) {
        this.input = input;
    }
}
----

A stream can be created at any time, but its contents will only be not null when the `init()` method has run.
Does this make sense, and how can we detect it?

. There is only one method that changes the content of a field
.  The iterator that fills the content is complete, i.e., it is guaranteed to run over all elements (is detectable via rewriting
with streams, so that `@Size(copy = true))` is present). This iterator must not be conditional.
.  The value that is set in the content is `@NotNull`. Obviously, when value is `@NotNull1`, the field will get a `@NotNull2`, etc.