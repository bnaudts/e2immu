=== Level 1 immutability

Let us start with a definition:

****
*Definition*: We say a field is *effectively final* when it either has the modifier `final`, or it is not assigned to in methods that can be transitively called from non-private (non-constructor) methods.
****

The code analyser annotates with `@Final` in the latter case; there is no point in cluttering with an annotation when the modifier is already there.
It annotates fields that are not effectively final with `@Variable`.

This definition allows effectively final fields to be assigned in methods accessible only from the constructor:

.Example 1, effectively final, but not with the `final` modifier
[source,java]
----

----

Obviously, if the same method is also accessible after construction, the field becomes variable:

.Example 2, the method is accessible after construction
[source,java]
----

----

Please note that it is perfectly possible to rewrite the first example in such a way that the `final` modifier can be used.
From the point of view of the code analyser, it does not matter.
The wider definition will allow for more situations to be recognized as they really are.

When an object consists solely of primitives, or deeply immutable objects such as `java.lang.String`, having all fields effectively final is sufficient to generate an object that is again deeply immutable.

.Example 3, an object consisting of primitives and a string.
[source,java]
----
class DeeplyImmutable1 {
    public final int x;
    public final int y;
    public final String message;

    public DeeplyImmutable1(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }
}
----

.Example 4, another way of being effectively final
[source,java]
----
class DeeplyImmutable2 {
    @Final
    private int x;
    @Final
    private int y;
    @Final
    private String message;

    public DeeplyImmutable2(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }

    public String getMessage() {
        return message;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
----

Examples 3 and 4 are functionally equivalent: there is no way of changing the values of the fields once they have been set.
In the real world there may be a reason why someone requires the getters.
Or, you may be given code as in Example 2, but you are not allowed to change it.
Whatever the reason, the code analyser should recognize effective finality for what it is.

Note that we will not make a distinction between any of the different non-private access modes in Java.
Only the private modifier gives sufficient guarantees that no reassignment to the fields is possible.

We now have observed that in view of immutability, having all your fields effectively final can be useful in certain circumstances.
We use this concept to define a first level of immutability:

****
*Definition*: We call a type *effectively level 1 immutable* when all its fields are effectively final.
****

The code analyser annotates level 1 immutable types with `@E1Immutable`.

As above with effective finality, the term _effective_ is present to make a distinction between formal immutability, and immutability that the code analyser computes.
It will also serve to distinguish from _eventual_ immutability, where (in this case) the finality will be achieved only after the code reaches a certain state.
More on this later.

We have just observed that if one restricts to primitives and types like `java.lang.String`, level 1 immutability is sufficient to guarantee deep immutability.
It is not feasible (and we do not wish to) work with deeply immutable objects only.
Moreover, it is easy to see that level 1 immutability may not enough to agree with all purposes of immutability:

.Example 5, level 1 immutability may not enough
[source,java]
----
@E1Immutable
class StringsInArray {
    private final String[] data;
    public StringsInArray(String[] strings) {
        this.data = strings;
    }
    public String getFirst() {
        return data[0];
    }
}

...
String[] strings = { "a", "b" };
StringsInArray sia = new StringsInArray(strings);
Assert.assertEquals("a", sia.getFirst());
strings[0] = "c";
Assert.assertEquals("c", sia.getFirst());
----

To continue, we must first understand the notion of modification.

=== Modification

****
*Definition*: a method is *modifying* if it causes an assignment in the object graph of the fields of this object.
****

We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.

Consequently, a method is not modifying if it only reads from the object graph of the fields.
The code analyser uses the annotations `@NotModified` and `@Modified`.
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we will clutter by annotating them.

For clarity, we repeat that directly assigning to the fields also constitutes a modification.
As an example, setters are `@Modified`, while getters are `@NotModified`:

[source,java]
----
class Message {
    @Variable
    private String message;

    @NotModified
    public String getMessage() {
        return message;
    }

    @Modified
    public void setMessage(String message) {
        this.message = message;
    }
}

class Example2 {
    @Final
    @Modified
    private final Message message = new Message();

    public Example2() {
        message.setMessage("No message yet");
    }

    @Modified
    public void inform(String info) {
        this.message.setMessage(info);
    }
}
----

We also see in the example that the `inform` method is `@Modified`.
This is because it calls a modifying method on one of the fields: `setMessage`.

The code analyser annotates a parameter with `@NotModified` when the parameter's method does not apply modifying methods on the object that enters the method via the parameter.
This restriction holds in the strongest possible way, a topic which we will elaborate on later.
If a parameter is not `@NotModified`, it is `@Modified`.

We will apply exactly the same reasoning to a field.
A field will be annotated `@NotModified` when none of the type's methods, transitively reachable from a non-private non-constructor method, applies modifying methods on this field.
This restriction again holds in the strongest possible way.
If a field is not `@NotModified`, it is `@Modified`.

Clearly `@NotModified` is stronger than `@Final`: a field that is not `@Final` cannot be `@NotModified`.
A field that is `@NotModified` must be `@Final`.

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all `@NotModified`.
This is pretty obvious in the case of `toString`, `hashCode`, `getClass`.
It is less obvious for the `wait` and other synchronization-related methods.

IMPORTANT: As a general rule, we will exclude synchronization support from this discussion.

Note also that we cannot add modifying methods to the type `DeeplyImmutable1` in Example 3.

For clarity, let's also look at (a part of) the `Collection` interface, where we've restricted the annotations to `@NotModified` and `@Modified`:

.Showing the modification status of methods in the `Collection` interface
[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.

IMPORTANT: The code analyser cannot compute annotations from an interface.
They must be manually added, to convey the intentions of the methods.

Adding all elements of a collection to the object (in `addAll`) should not modify the input collection, whence the `@NotModified`.
Other types in the parameters do not have a `@NotModified` annotation:

* `Object` because it is deeply immutable,
* `E` because it is of an unbound generic type, it has the same methods available as `Object`,
* `Consumer` because it is a functional type, with only one method, which is always `@NotModified`.

The rules for not having to write `@NotModified` will be detailed later, but this example pretty much covers all the bases.

=== Linking, intuitively

Let us now elaborate on how we will compute modifications.
Consider the following example:

[source,java]
----
class WithSet<X> {
    private final Set<X> set;

    public WithSet(Set<X> xs) {
        this.set = xs;
    }
    public void add(X x) {
        set.add(x);
    }
}
----

The parameter `xs` is _linked_ to the field `set`, which is modified in the `add` method by `set.add()` call.
This implies that calling `WithSet.add` modifies the source set, passed to the constructor.
The following annotations emerge:

[source,java]
----
class WithSet<X> {
    @Modified
    private final Set<X> set;

    public WithSet(@Modified Set<X> xs) {
        this.set = xs;
    }

    @Modified
    public void add(X x) {
        set.add(x);
    }
}
----

As noted above, the parameter `x` of `WithSet.add` is trivially `@NotModified`  because unbound parameter types have no modifying methods that can be called on them.

Linking looks at the underlying object, and not at the variable.
Consider the following alternative `add` method:

[source,java]
----
@Modified
public void add(X x) {
    Set<X> theSet = this.set;
    X theX = x;
    theSet.add(theX);
}
----

Nothing has changed, obviously.

We will discuss linking more formally later.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that the object represented by both is the same.

==== Independence

The opposite of linking is independence.
We will annotate independence on methods and constructors, and to parameters in one specific case.

When added to a non-private method, the annotation implies that the object returned does not link to any of the fields of the class.
When added to a constructor, the annotation implies that the fields of the resulting instance do not link to the parameters of the constructor.
If a method does not return a value (it is `void`), and it has consumer parameters, the annotation indicates that the objects linked to the consumers do not link to the fields of the class or other parameters of the method.
The annotation is then added to the consumer (not implemented yet).

Linking means that modifying a given object implies potentially modifying the linked object as well.
Remember that as explained in <<linked-annotation>>, primitives, unbound type parameters, and classes marked <<e2immutable-annotation>> break the chain because of their content immutability.

It follows that:

- empty constructors of top-level types and static sub-types (but not necessarily sub types-that are not static!) are always independent; no need to annotate
- methods that return effectively immutable objects are independent, since these objects cannot be modified

#This needs to be verified#

The problem at the moment: should the definition of linking

=== Immutability

Loosely speaking, a container is a type to which you can safely pass on your objects, it will not modify them.
This is the formal rule:

A type is a `@Container`::
when none of the parameters of the methods and constructors of the type are `@Modified`.

Whatever else the container does, storing them in fields or not, it will not change your objects.
You obviously remain free to change them, and the container will keep on holding the changed object, not some copy.

We proceed with effectively final fields, and the first level of immutability.
The former ensures that once construction is over, the fields cannot be assigned anymore:

A type is `@E1Immutable`::
when all its fields are `@NotModified`.
We call this 'level 1 immutable'.

****
Note: requiring that all fields are `@NotModified` is equivalent to requiring that all non-private fields are `@Final`, and that methods that are not part of the construction phase, are `@NotModified`.
****

A type is `@E1Container`::
when it is both `@E1Immutable` and `@Container`.

****
Note: Rule 2 in `@E1Immutable` is different from the requirement that no parameter is `@NotModified`, however, when the fields are directly assigned from parameters in the constructor, the rules amount to the same.
****

****
Note: Effective level 1 immutability can also be achieved by presenting a restricted view to the user, by means of an interface which consists of the non-modifying methods only.
****

The following example is typical of a level 1 immutable container:

[source,java]
----
@E1Container
public class Pair<K,V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Note that since `K` and `V` are unbound types, it is not possible to modify their content, since there are no modifying methods one can call on unbound types.
This example doesn't even have non-constructor methods.

The field `k` is linked to the parameter `k` in the constructor.
The `@NotModified` requirement on the parameter directly translates to an `@NotModified` on the field.

Let us summarize the loose definition for a level 1 immutable type, and generalize it straight away by dropping the level descriptor:

IMPORTANT: After construction, an immutable container holds a number of objects, and the container will not change their content, nor will it exchange them for other objects, or allow others to do so.
The container is not responsible for what others do to the content of the objects it has been given.

Assuming the type's goal is to store a number of objects, it is easy to see that a level 1 immutable type cannot hold additional, modifiable state.
It follows that every method call on the container object with the same arguments will render the same result.
(Note that this can be bypassed in Java by using _static_ state, i.e., state specific to the type rather than the object.
Let us ignore that for now.)

In order to hold an arbitrary (or even modestly large) amount of objects, a type has to have 'support data': think an array, a tree structure, buckets for a hash table, etc.
The difference between `@E1Immutable` and `@E2Immutable` is essentially about expressing the immutability of the support data.
After construction, a level 2 immutable type will still hold a fixed number of objects, and the type will not change their content, nor exchange them for other objects, nor allow others to exchange them.

Let us formalize this definition.

A type is `@E2Immutable` or effectively level 2 immutable, when

. it is `@E1Immutable`
. all its fields are either private, or are at least `@E1Immutable`.
. all its constructors and non-private methods are `@Independent`.

****
Notes

. rule 2 is there to ensure that the content of the object cannot be modified through access to the non-private fields.

. rule 3 is there to ensure that the content of the object cannot be modified externally.
****

Both properties can be reached _eventually_ if there is one or more methods that effect a transition from the mutable to the immutable state.
In the case of `@E1Immutable`, this means that all methods that assign or modify fields become off-limits after calling this marker method.

The `@Container` property can currently not be made eventual.

.Example with array, v1
[source,java]
----
class ArrayContainer1<T> {
    private final T[] data;
    public ArrayContainer1(T[] ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> After creation, changes to the source array are effectively changes to the data.
Fails rule 3, independence.

.Example with array, v2, still not OK
[source,java]
----
class ArrayContainer2<T> {
    public final T[] data; // <1>
    public ArrayContainer2(T[] ts) {
        this.data = new T[ts.length];
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> Users of this type can modify the content of the array!
Fails rule 2.

.Example with array, v3, safe
[source,java]
----
class ArrayContainer3<T> {
    private final T[] data; // <1>
    public ArrayContainer3(T[] ts) {
        this.data = new T[ts.length]; // <2>
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> The array is private, and therefore protected from modification.
<2> The array has been copied, and therefore is independent of the one passed in the parameter.

The independence rule enforces the type to have its own structure rather than someone else's.
Here's the same group of example, now with JDK Collections:

.Example with collection, v1
[source,java]
----
class SetBasedContainer1<T> {
    private final Set<T> data;
    public SetBasedContainer1(Set<T> ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> After creation, changes to the source set are effectively changes to the data.

.Example with collection, v2, still not OK
[source,java]
----
class SetBasedContainer2<T> {
    public final Set<T> data; // <1>
    public SetBasedContainer2(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> Users of this type can modify the content of the set after creation!

.Example with set, v3, safe
[source,java]
----
class SetBasedContainer3<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> The set is private, and therefore protected from external modification.
<2> The set has been copied, and therefore is independent of the one passed in the parameter.

.Example with set, v4, safe
[source,java]
----
class SetBasedContainer4<T> {
    public final ImmutableSet<T> data; // <1>
    public SetBasedContainer4(Set<T> ts) {
        this.data = ImmutableSet.copyOf(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> the data is public, but the `ImmutableSet` is `@E2Immutable` itself.
<2> Independence guaranteed.

The independence rule 3 is there to ensure that the type does not expose its support data through parameters and return types:

.Example with set, v5, unsafe
[source,java]
----
class SetBasedContainer5<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer5(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Set<T> getSet() {
        return data; // <3>
    }
}
----
<1> No exposure via the field
<2> No exposure via the parameter of the constructor
<3> ... but exposure via the getter.
We could as well have made the field `public final`.

==== Examples

This is a `@Container`, the field is `@Final`, but the field is not `@NotModified`:

[source,java]
----
class Example2 {
    @Final
    @Modified
    public final Set<T> set = new HashSet<>();

    @Modified
    public void add(T t) { set.add(t); }

    @NotModified
    public Stream<T> stream() { return set.stream(); }
}
----

==== Case Lazy

`Lazy` implements a lazily-initialized immutable field, of unbound generic type `T`.
As such, it is eventually an `@E1Container`.

[source,java]
----
@E1Container(after = "get")
public class Lazy<T> {
    private final Supplier<T> supplier;
    private volatile T t;

    public Lazy(Supplier<T> supplier) {
        this.supplier = supplier;
    }

    @Modified
    @Mark("get")
    public T get() {
        T localT = t;
        if (localT != null) return localT;

        synchronized (this) {
            if (t == null) {
                t = Objects.requireNonNull(supplier.get());
            }
            return t;
        }
    }
}
----

After calling the marker method `get()`, `t` cannot be assigned anymore.
Because it is of an unbound type, the field `t` is `@NotModified`.
Because it is a functional type, `supplier` is `@NotModified`.
The type is also clearly a container.
Tte type violates the independence rule, so it is not a `@E2Container`.

==== Case E2ImmuAnnotationExpressions

Code can be summarized as:

[source,java]
----
public class E2ImmuAnnotationExpressions {

    @NotModified
    private final TypeStore typeStore;

    public E2ImmuAnnotationExpressions(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
    }

    public final Lazy<AnnotationExpression> beforeImmutableMark =
      new Lazy<>(() -> create(BeforeImmutableMark.class));
    // ... like beforeImmutableMark there's many more

    @NotModified
    private AnnotationExpression create(Class<?> clazz) {
      ... // reads from the typeStore
    }

    @NotModified
    @NotNull
    public TypeInfo getFullyQualified(@NotNull String fqn) {
        return Objects.requireNonNull(typeStore.get(fqn));
    }
}
----

The `TypeStore` is eventually an `@E2Container`, once all types have been added.
The types in the store are of class `TypeInfo`.
They are independent of the `typeStore`, so rule 3 is satisfied both for constructor and `getFullyQualified` method.

The type `Lazy` is eventually an `@E1Container`, which makes it irrelevant what the nature of `AnnotationExpression` is.

We can therefore conclude that `E2ImmuAnnotationExpressions` as depicted here is eventually an `@E2Container`.

Let's now remove the `Lazy` intermediate, by changing the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions2 {

    @NotModified
    private final TypeStore typeStore;

    public final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions2(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }
    ...
}
----

Because `Lazy` has gone, we would have an `@E1Immutable` restriction on `AnnotationExpression`
to maintain `@E2Immutable`.
Similarly, if we change the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions3 {

    @NotModified
    private final TypeStore typeStore;

    private final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions3(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }

    public AnnotationExpression getBeforeImmutableMark() {
        return this.beforeImmutableMark;
    }

    ...
}
----

We again have an independence rule to contend with, which demands that `AnnotationExpression` is at least `@E1Container`
if we want to maintain `@E2Immutable`.

It is important to realize that `@E1Immutable` is not _less desirable_ than `@E2Immutable`.
The former exists merely for simpler constructs than the latter.
Where there is a mixture of fields with constructs which require support data, and fields which don't, intermediates such as `Lazy` may be necessary for the overall `@E2Immutable` to be reached.

In other words, the analyser will compute the level of immutability achieved.
If the analyser finds level 1, and the programmer expects level 2, an error will be raised.

Current attitude: the definitions work well and are correct in many cases.
We will have them implemented, and may get to better insights later.
One doubt remains: can we automatically deduce whether we need level 1 or level 2?

One potential rule emerges:

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods, then we need level 2 immutability in rules 2 and 3 for that particular field.
Otherwise, level 1 immutability is sufficient.
****

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods (directly, or held in a different way), then we need level 1 immutability in rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.
****

This rule definitely works for types which hold collections to which individual entries can be added.
Consider the simplified example of the `TypeStore`:

[source,java]
----
class TypeStore {
    private final Trie<TypeInfo> trie = new Trie<>();
    ...
    public void add(TypeInfo typeInfo) {
        ....
        this.trie.add(typeInfo);
    }
}
----

The `TypeStore` has a field of type `Trie` (_A_), which holds elements of type `TypeInfo` (_B_);
`TypeInfo` also occurs in the non-private methods.


`Lazy` in itself is an eventual `@E1Container`.
The type `E2ImmuAnnotationExpressions` holds a type, _A_, `Lazy<AnnotationExpression>`, which holds `AnnotationExpression`.
Now `AnnotationExpression` does not occur in any of the methods of `E2ImmuAnnotationExpressions`, but we trivially can make it so by introducing:

[source,java]
----
public AnnotationExpression getBeforeImmutableMark() {
  return this.beforeImmutableMark.get();
}
----

or by making the `create()` method public.

The rule will need to apply to rules 2 and 3 of the level 2 immutability definition; but, we can apply the rule on a field-by-field basis.
We definitely need to allow for creativity; the programmer should be able to overrule.

==== Combination example

First consider

[source,java]
----
@E2Container
class TypeStore {
    public final TypeInfo object;
    public final TypeInfo string;

    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
        object = get("java.lang.Object");
        string = get("java.lang.String");
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The trie holds `TypeInfo` objects.
Rules 2 and 3 will apply to fields and methods of the type `Trie`, not to fields and methods of the type `TypeInfo`.

This type can be level 2 immutable when

. it is `@E1Immutable`.
This is fine: all fields are `final`, and there are no modifying methods.

. the non-private fields are of type `TypeInfo`, which is directly returned by one of the methods.
There is no additional restriction on them.

. The `TypeInfo` object returned by the `get` method is not subject to independence requirements.
The `trie` field must be independent of the `allTypes` parameter because the trie holds `TypeInfo` objects.
Given that they are completely separate data structures, this should be no problem.

It is important to observe that we need not have any restriction on `TypeInfo`, nor on `Trie`!

Now, adding a method

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return trie;
}
----

would force the `Trie` type to be `@E1Immutable` as well for independence to be achieved, and the `@E2Immutable` status to be kept.
Alternatively, we could change the method to:

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return new Trie(trie.elements());
}
----

in order to return a copy.

[source,java]
----
@E2Container
class TypeStore {
    public final Lazy<TypeInfo> object =
        new Lazy<>(() -> get("java.lang.Object"));
    public final Lazy<TypeInfo> string =
        new Lazy<>(() -> get("java.lang.String"));
    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The two public fields are of type `Lazy`, which holds `TypeInfo`, and `TypeInfo` is present in one public method.
As a consequence, `Lazy` must be at least `@E1Immutable`, but that is fine.
In this second example, `Lazy` acts as a data structure.

The following example shows that `Stream<M>` should trigger the rules of `@E2Immutable`:

[source,java]
----
class ImmutableMSet {
    private Set<M> ms;
    public ImmutableMSet(Set<M> ms) {
        this.ms = new HashSet<>(ms);
    }
    public Stream<M> stream() {
        return ms.stream();
    }
}
----

=== Realize that

this version of the level 2 immutability definition is more like an _as immutable as it 's going to get_ definition.
It does accord with the intuitive definition.
The number (level 1, level 2) has less to do with the effective depth.

=== Additional requirements

. Having `@Immutable` objects in an `@E1Immutable` object such as `Pair` makes the object effectively or eventually `@Immutable`.

. Having deeply immutable objects in an `@E2Immutable` object makes the object deeply immutable.

We may need better terminology, however, deeply immutable is not relevant to what we're doing.

=== To check

Is linking using this new definition of `@E2Immutable` sufficient?

Rules center around

. direct assignment
. assignment to sub-field
. method result, with various limitations when a type is immutable

How do these limitations work?
For deeply immutable objects, this is trivial: there's no point in linking because no modifications can be made.
For other objects, the level of immutability will have an effect.

Let type `M` be `@Mutable`.
Then `SetOnce<M>` is `@E1Immutable` but not deeply immutable.

In the following example, the rules for `@E2Immutable` are not triggered, because `M` remains hidden.
It is therefore immaterial what type `SetOnce` is:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public SetOnce<M> getM() {
        return m1;
    }
}
----

It is therefore "equivalent" to:

[source,java]
----
class CopyOfM {
    private M m;
    public CopyOfM(M m) {
        this.m = m;
    }
    public M getM() {
        return m;
    }
}
----

Once you give it the `m` object, it'll keep it.
You can change the content of `m`, but that's immaterial.

This will trigger the `@E2Immutable` rules:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public M getM() {
        return m1.get();
    }
}
----

Because the argument is `@E1Immutable` we will always have the same `m` in the getter!
Here _as immutable as it gets_ is fine; level 1 immutability breaks the linking.

Changing the `SetOnce` for a `List`, which will need level 2:

[source,java]
----
class DirectAssignmentOfSet {
    private List<M> ms;
    public DirectAssignmentOfSet(List<M> ms) {
        this.ms = ms;
    }
    public M getFirst() {
        return ms.get(0);
    }
}
----

Clearly the field `ms` is linked to the parameter of the constructor.
This link can only be broken with level 1 immutability, otherwise, the user can change the result of `getFirst` by modifying the list after constructing an instance of the type.
The level 2 extensions do not seem to be necessary in this example: as long as we can ensure that the list does not change, we're fine.
Level 1 will ensure that no modifying objects can be called.
Recursively, this implementation of `List` may be modifiable from the outside.
We conclude we need level 2 extensions in the independence computation.
