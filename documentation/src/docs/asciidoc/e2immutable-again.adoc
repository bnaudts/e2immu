== The road to immutability

===
==== Case E2ImmuAnnotationExpressions

Code can be summarized as:

[source,java]
----
public class E2ImmuAnnotationExpressions {

    @NotModified
    private final TypeStore typeStore;

    public E2ImmuAnnotationExpressions(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
    }

    public final Lazy<AnnotationExpression> beforeImmutableMark =
      new Lazy<>(() -> create(BeforeImmutableMark.class));
    // ... like beforeImmutableMark there's many more

    @NotModified
    private AnnotationExpression create(Class<?> clazz) {
      ... // reads from the typeStore
    }

    @NotModified
    @NotNull
    public TypeInfo getFullyQualified(@NotNull String fqn) {
        return Objects.requireNonNull(typeStore.get(fqn));
    }
}
----

The `TypeStore` is eventually an `@E2Container`, once all types have been added.
The types in the store are of class `TypeInfo`.
They are independent of the `typeStore`, so rule 3 is satisfied both for constructor and `getFullyQualified` method.

The type `Lazy` is eventually an `@E1Container`, which makes it irrelevant what the nature of `AnnotationExpression` is.

We can therefore conclude that `E2ImmuAnnotationExpressions` as depicted here is eventually an `@E2Container`.

Let's now remove the `Lazy` intermediate, by changing the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions2 {

    @NotModified
    private final TypeStore typeStore;

    public final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions2(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }
    ...
}
----

Because `Lazy` has gone, we would have an `@E1Immutable` restriction on `AnnotationExpression`
to maintain `@E2Immutable`.
Similarly, if we change the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions3 {

    @NotModified
    private final TypeStore typeStore;

    private final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions3(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }

    public AnnotationExpression getBeforeImmutableMark() {
        return this.beforeImmutableMark;
    }

    ...
}
----

We again have an independence rule to contend with, which demands that `AnnotationExpression` is at least `@E1Container`
if we want to maintain `@E2Immutable`.

It is important to realize that `@E1Immutable` is not _less desirable_ than `@E2Immutable`.
The former exists merely for simpler constructs than the latter.
Where there is a mixture of fields with constructs which require support data, and fields which don't, intermediates such as `Lazy` may be necessary for the overall `@E2Immutable` to be reached.

In other words, the analyser will compute the level of immutability achieved.
If the analyser finds level 1, and the programmer expects level 2, an error will be raised.

Current attitude: the definitions work well and are correct in many cases.
We will have them implemented, and may get to better insights later.
One doubt remains: can we automatically deduce whether we need level 1 or level 2?

One potential rule emerges:

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods, then we need level 2 immutability in rules 2 and 3 for that particular field.
Otherwise, level 1 immutability is sufficient.
****

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods (directly, or held differently), then we need level 1 immutability in rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.
****

This rule definitely works for types which hold collections to which individual entries can be added.
Consider the simplified example of the `TypeStore`:

[source,java]
----
class TypeStore {
    private final Trie<TypeInfo> trie = new Trie<>();
    ...
    public void add(TypeInfo typeInfo) {
        ....
        this.trie.add(typeInfo);
    }
}
----

The `TypeStore` has a field of type `Trie` (_A_), which holds elements of type `TypeInfo` (_B_);
`TypeInfo` also occurs in the non-private methods.


`Lazy` in itself is an eventual `@E1Container`.
The type `E2ImmuAnnotationExpressions` holds a type, _A_, `Lazy<AnnotationExpression>`, which holds `AnnotationExpression`.
Now `AnnotationExpression` does not occur in any of the methods of `E2ImmuAnnotationExpressions`, but we trivially can make it so by introducing:

[source,java]
----
public AnnotationExpression getBeforeImmutableMark() {
  return this.beforeImmutableMark.get();
}
----

or by making the `create()` method public.

The rule will need to apply to rules 2 and 3 of the level 2 immutability definition; but, we can apply the rule on a field-by-field basis.
We definitely need to allow for creativity; the programmer should be able to overrule.

==== Combination example

First consider

[source,java]
----
@E2Container
class TypeStore {
    public final TypeInfo object;
    public final TypeInfo string;

    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
        object = get("java.lang.Object");
        string = get("java.lang.String");
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The trie holds `TypeInfo` objects.
Rules 2 and 3 will apply to fields and methods of the type `Trie`, not to fields and methods of the type `TypeInfo`.

This type can be level 2 immutable when:

. it is `@E1Immutable`.
This is fine: all fields are `final`, and there are no modifying methods.

. the non-private fields are of type `TypeInfo`, which is directly returned by one of the methods.
There is no additional restriction on them.

. The `TypeInfo` object returned by the `get` method is not subject to independence requirements.
The `trie` field must be independent of the `allTypes` parameter because the trie holds `TypeInfo` objects.
Given that they are completely separate data structures, this should be no problem.

It is important to observe that we need not have any restriction on `TypeInfo`, nor on `Trie`!

Now, adding a method

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return trie;
}
----

would force the `Trie` type to be `@E1Immutable` as well for independence to be achieved, and the `@E2Immutable` status to be kept.
Alternatively, we could change the method to:

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return new Trie(trie.elements());
}
----

in order to return a copy.

[source,java]
----
@E2Container
class TypeStore {
    public final Lazy<TypeInfo> object =
        new Lazy<>(() -> get("java.lang.Object"));
    public final Lazy<TypeInfo> string =
        new Lazy<>(() -> get("java.lang.String"));
    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The two public fields are of type `Lazy`, which holds `TypeInfo`, and `TypeInfo` is present in one public method.
As a consequence, `Lazy` must be at least `@E1Immutable`, but that is fine.
In this second example, `Lazy` acts as a data structure.

The following example shows that `Stream<M>` should trigger the rules of `@E2Immutable`:

[source,java]
----
class ImmutableMSet {
    private Set<M> ms;
    public ImmutableMSet(Set<M> ms) {
        this.ms = new HashSet<>(ms);
    }
    public Stream<M> stream() {
        return ms.stream();
    }
}
----

=== Realize that

this version of the level 2 immutability definition is more like an _as immutable as it 's going to get_ definition.
It does accord with the intuitive definition.
The number (level 1, level 2) has less to do with the effective depth.

=== Additional requirements

. Having `@Immutable` objects in an `@E1Immutable` object such as `Pair` makes the object effectively or eventually `@Immutable`.

. Having deeply immutable objects in an `@E2Immutable` object makes the object deeply immutable.

We may need better terminology, however, deeply immutable is not relevant to what we're doing.

=== To check

Is linking using this new definition of `@E2Immutable` sufficient?

Rules center around

. direct assignment
. assignment to sub-field
. method result, with various limitations when a type is immutable

How do these limitations work?
For deeply immutable objects, this is trivial: there's no point in linking because no modifications can be made.
For other objects, the level of immutability will have an effect.

Let type `M` be `@Mutable`.
Then `SetOnce<M>` is `@E1Immutable` but not deeply immutable.

In the following example, the rules for `@E2Immutable` are not triggered, because `M` remains hidden.
It is therefore immaterial what type `SetOnce` is:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public SetOnce<M> getM() {
        return m1;
    }
}
----

It is therefore "equivalent" to:

[source,java]
----
class CopyOfM {
    private M m;
    public CopyOfM(M m) {
        this.m = m;
    }
    public M getM() {
        return m;
    }
}
----

Once you give it the `m` object, it'll keep it.
You can change the content of `m`, but that's immaterial.

This will trigger the `@E2Immutable` rules:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public M getM() {
        return m1.get();
    }
}
----

Because the argument is `@E1Immutable` we will always have the same `m` in the getter!
Here _as immutable as it gets_ is fine; level 1 immutability breaks the linking.

Changing the `SetOnce` for a `List`, which will need level 2:

[source,java]
----
class DirectAssignmentOfSet {
    private List<M> ms;
    public DirectAssignmentOfSet(List<M> ms) {
        this.ms = ms;
    }
    public M getFirst() {
        return ms.get(0);
    }
}
----

Clearly the field `ms` is linked to the parameter of the constructor.
This link can only be broken with level 1 immutability, otherwise, the user can change the result of `getFirst` by modifying the list after constructing an instance of the type.
The level 2 extensions do not seem to be necessary in this example: as long as we can ensure that the list does not change, we're fine.
Level 1 will ensure that no modifying objects can be called.
Recursively, this implementation of `List` may be modifiable from the outside.
We conclude we need level 2 extensions in the independence computation.
