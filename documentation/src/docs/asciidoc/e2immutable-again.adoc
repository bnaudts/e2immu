=== Plan

. effectively final
. deeply immutable using types composed of primitives, `Object`, and `String`
. combination of effectively final and unbound parameter types, `Pair`
. we do not have to live with only deeply immutable
. example where the components of `Pair` can be modified
. definition of modification
. modifying methods in collections
. intuitive definitions of independence and linking using collections
. back to `Pair`, level 1 immutability
. back to collections: level 1 immutability is not good enough
. level 2 immutability
. formal definition of linking: when should we insist on level 2??
. from which follows the formal definition of independence.

=== Effectively final

We will annotate a field as `@Final` when it is either marked `final`, or it is not assigned to in methods that can be transitively called from non-private (non-constructor) methods.
The field is then 'effectively final'.
Fields that are not `@Final` are marked `@Variable`.

When an object consists solely of primitives, or deeply immutable objects such as `java.lang.String`, having all fields effectively final is enough to generate an object that is again deeply immutable.

.Example 1, an object consisting of primitives and a ``String``
[source,java]
----
class DeeplyImmutable {
    public int x;
    public int y;
    public String message;

    public DeeplyImmutable(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }
}
----

It is not feasible (and we do not wish to) work with deeply immutable objects only.
To continue, we must first understand the notion of modification.

=== Modification

A method is modifying if it causes an assignment in the object graph of the fields of this object.
Consequently, a method is not modifying if it only reads from the object graph of the fields.
We use the annotations `@NotModified` and `@Modified`.

For clarity, we will say that directly assigning to the fields also constitutes a modification.
As an example, setters are `@Modified`, while getters are `@NotModified`:

[source,java]
----
class Message {
    @Variable
    private String message;

    @NotModified
    public String getMessage() {
        return message;
    }

    @Modified
    public void setMessage(String message) {
        this.message = message;
    }
}

class Example2 {
    @Final
    @Modified
    private final Message message = new Message();

    public Example2() {
        message.setMessage("No message yet");
    }

    @Modified
    public void inform(String info) {
        this.message.setMessage(info);
    }
}
----

All non-trivial constructors are modifying, so we will not annotate them.

A parameter will be annotated `@NotModified` when the parameter's method does not apply modifying methods on the object that enters the method via the parameter.
This restriction holds in the strongest possible way, a topic which we will elaborate on later.
If a parameter is not `@NotModified`, it is `@Modified`.

We will apply exactly the same reasoning to a field.
A field will be annotated `@NotModified` when none of the type's methods, transitively reachable from a non-private non-constructor method, does not apply modifying methods on this field.
This restriction again holds in the strongest possible way.
If a field is not `@NotModified`, it is `@Modified`.

Clearly `@NotModified` is stronger than `@Final`: a field that is not `@Final` cannot be `@NotModified`.
At the same time, a field that is `@NotModified` must be `@Final`.

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all `@NotModified`.
Note also that we cannot add modifying methods to the type `DeeplyImmutable` in Example 1.

For clarity, let's also look at (a part of) the `Collection` interface, where we've restricted the annotations to `@NotModified` and `@Modified`:

[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size should not.

=== Linking, intuitively

Let us now elaborate on how we will compute modifications.
Consider the following example:

[source,java]
----
class WithSet<X> {
    private final Set<X> set;

    public WithSet(Set<X> xs) {
        this.set = xs;
    }
    public void add(X x) {
        set.add(x);
    }
}
----

The parameter `xs` is _linked_ to the field `set`, which is modified in the `add` method by `set.add()` call.
This implies that calling `WithSet.add` modifies the source set, passed to the constructor.
The following annotations emerge:

[source,java]
----
class WithSet<X> {
    @Modified
    private final Set<X> set;

    public WithSet(@Modified Set<X> xs) {
        this.set = xs;
    }

    @Modified
    public void add(X x) {
        set.add(x);
    }
}
----

The parameter `x` of `WithSet.add` is `@NotModified`.
We have not marked it, because unbound parameter types have no modifying methods that can be called on them.
If they occur as a parameter, which we never allow to be assigned to, they are always `@NotModified`.

Linking looks at the underlying object, and not at the variable.
Consider the following alternative `add` method:

[source,java]
----
@Modified
public void add(X x) {
    Set<X> theSet = this.set;
    X theX = x;
    theSet.add(theX);
}
----

Nothing has changed, obviously.
The example is illustrative in that it shows that we need to treat complex composite objects differently from , but not for primitives and deeply immutable objects, because we cannot change them anyway.

=== Linking, more formally

A field can be linked to another field or parameter.
Intuitively, this happens when a modification on one object implies a modification on the other.
This implies a 'connection' between the variables, some shared object.

Primitives cannot be linked.
Fully immutable types like `String` cannot be linked, because one cannot modify them.

A method's result can be linked to a field in the class, or a parameter of the same or one of the other methods.
The goal of linking is to help the computation of the `@NotModified` annotation by ensuring that a field or parameter can only be
`@NotModified` when there are no modifications on any of the linked variables.

Intuitively,

* directly initialising a field from a constructor's parameter (`this.t = t`) causes linking
* the `add(T t)` method in collections does not imply a linking between the parameter and the support structure organising the collection:
changing `t` will not change the collection itself.
* by extension, the collection `ts` in `addAll(Collection<T> ts)` will still be independent (or not linked) of the object's collection.
Adding an element to `ts` afterwards, will not change the object collection.
* if two containers share their 'support data', then they are linked

Technically, the value that a field receives during construction determines how it is linked.
If it is directly assigned to a parameter, it will be linked to that parameter.
If the assignment expression contains a method call, in general it is linked to the object of the method call and all the parameters.
If there are multiple assignments conditionally executed, we have to consider the worst case and link the variable to the union of the fields and parameters of the expressions.
Improving the situation are primitives and immutable objects.
We will make definitions in such a way that we can reduce linking, and define some measure of independence.

==== Independence

When added to a non-private method, this annotation implies that the object returned is not linked to any of the fields of the class.
When added to a constructor, the annotation implies that the resulting instance is not linked to the parameters of the constructor.
If a method does not return a value (it is `void`), and it has consumer parameters, the annotation indicates that the objects linked to the consumers are not linked to the fields of the class or other parameters of the method.
The annotation is then added to the consumer (not implemented yet).

Linking means that modifying a given object implies potentially modifying the linked object as well.
Remember that as explained in <<linked-annotation>>, primitives, unbound type parameters, and classes marked <<e2immutable-annotation>> break the chain because of their content immutability.

It follows that:

- empty constructors of top-level types and static sub-types (but not necessarily sub types-that are not static!) are always independent; no need to annotate
- methods that return effectively immutable objects are independent, since these objects cannot be modified

#This needs to be verified#

The problem at the moment: should the definition of linking

=== Immutability

Loosely speaking, a container is a type to which you can safely pass on your objects, it will not modify them.
This is the formal rule:

A type is a `@Container`::
when none of the parameters of the methods and constructors of the type are `@Modified`.

Whatever else the container does, storing them in fields or not, it will not change your objects.
You obviously remain free to change them, and the container will keep on holding the changed object, not some copy.

We proceed with effectively final fields, and the first level of immutability.
The former ensures that once construction is over, the fields cannot be assigned anymore:

A type is `@E1Immutable`::
when all its fields are `@NotModified`.
We call this 'level 1 immutable'.

****
Note: requiring that all fields are `@NotModified` is equivalent to requiring that all non-private fields are `@Final`, and that methods that are not part of the construction phase, are `@NotModified`.
****

A type is `@E1Container`::
when it is both `@E1Immutable` and `@Container`.

****
Note: Rule 2 in `@E1Immutable` is different from the requirement that no parameter is `@NotModified`, however, when the fields are directly assigned from parameters in the constructor, the rules amount to the same.
****

****
Note: Effective level 1 immutability can also be achieved by presenting a restricted view to the user,
by means of an interface which consists of the non-modifying methods only.
****

The following example is typical of a level 1 immutable container:

[source,java]
----
@E1Container
public class Pair<K,V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Note that since `K` and `V` are unbound types, it is not possible to modify their content, since there are no modifying methods one can call on unbound types.
This example doesn't even have non-constructor methods.

The field `k` is linked to the parameter `k` in the constructor.
The `@NotModified` requirement on the parameter directly translates to an `@NotModified` on the field.

Let us summarize the loose definition for a level 1 immutable type, and generalize it straight away by dropping the level descriptor:

IMPORTANT: After construction, an immutable container holds a number of objects, and the container will not change their content, nor will it exchange them for other objects, or allow others to do so.
The container is not responsible for what others do to the content of the objects it has been given.

Assuming the type's goal is to store a number of objects, it is easy to see that a level 1 immutable type cannot hold additional, modifiable state.
It follows that every method call on the container object with the same arguments will render the same result.
(Note that this can be bypassed in Java by using _static_ state, i.e., state specific to the type rather than the object.
Let us ignore that for now.)

In order to hold an arbitrary (or even modestly large) amount of objects, a type has to have 'support data': think an array, a tree structure, buckets for a hash table, etc.
The difference between `@E1Immutable` and `@E2Immutable` is essentially about expressing the immutability of the support data.
After construction, a level 2 immutable type will still hold a fixed number of objects, and the type will not change their content, nor exchange them for other objects, nor allow others to exchange them.

Let us formalize this definition.

A type is `@E2Immutable` or effectively level 2 immutable, when

. it is `@E1Immutable`
. all its fields are either private, or are at least `@E1Immutable`.
. all its constructors and non-private methods are `@Independent`.

****
Notes

. rule 2 is there to ensure that the content of the object cannot be modified through access to the non-private fields.

. rule 3 is there to ensure that the content of the object cannot be modified externally.
****

Both properties can be reached _eventually_ if there is one or more methods that effect a transition from the mutable to the immutable state.
In the case of `@E1Immutable`, this means that all methods that assign or modify fields become off-limits after calling this marker method.

The `@Container` property can currently not be made eventual.

.Example with array, v1
[source,java]
----
class ArrayContainer1<T> {
    private final T[] data;
    public ArrayContainer1(T[] ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> After creation, changes to the source array are effectively changes to the data.
Fails rule 3, independence.

.Example with array, v2, still not OK
[source,java]
----
class ArrayContainer2<T> {
    public final T[] data; // <1>
    public ArrayContainer2(T[] ts) {
        this.data = new T[ts.length];
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> Users of this type can modify the content of the array!
Fails rule 2.

.Example with array, v3, safe
[source,java]
----
class ArrayContainer3<T> {
    private final T[] data; // <1>
    public ArrayContainer3(T[] ts) {
        this.data = new T[ts.length]; // <2>
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> The array is private, and therefore protected from modification.
<2> The array has been copied, and therefore is independent of the one passed in the parameter.

The independence rule enforces the type to have its own structure rather than someone else's.
Here's the same group of example, now with JDK Collections:

.Example with collection, v1
[source,java]
----
class SetBasedContainer1<T> {
    private final Set<T> data;
    public SetBasedContainer1(Set<T> ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> After creation, changes to the source set are effectively changes to the data.

.Example with collection, v2, still not OK
[source,java]
----
class SetBasedContainer2<T> {
    public final Set<T> data; // <1>
    public SetBasedContainer2(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> Users of this type can modify the content of the set after creation!

.Example with set, v3, safe
[source,java]
----
class SetBasedContainer3<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> The set is private, and therefore protected from external modification.
<2> The set has been copied, and therefore is independent of the one passed in the parameter.

.Example with set, v4, safe
[source,java]
----
class SetBasedContainer4<T> {
    public final ImmutableSet<T> data; // <1>
    public SetBasedContainer4(Set<T> ts) {
        this.data = ImmutableSet.copyOf(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> the data is public, but the `ImmutableSet` is `@E2Immutable` itself.
<2> Independence guaranteed.

The independence rule 3 is there to ensure that the type does not expose its support data through parameters and return types:

.Example with set, v5, unsafe
[source,java]
----
class SetBasedContainer5<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer5(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Set<T> getSet() {
        return data; // <3>
    }
}
----
<1> No exposure via the field
<2> No exposure via the parameter of the constructor
<3> ... but exposure via the getter.
We could as well have made the field `public final`.

==== Examples

This is a `@Container`, the field is `@Final`, but the field is not `@NotModified`:

[source,java]
----
class Example2 {
    @Final
    @Modified
    public final Set<T> set = new HashSet<>();

    @Modified
    public void add(T t) { set.add(t); }

    @NotModified
    public Stream<T> stream() { return set.stream(); }
}
----

==== Case Lazy

`Lazy` implements a lazily-initialized immutable field, of unbound generic type `T`.
As such, it is eventually an `@E1Container`.

[source,java]
----
@E1Container(after = "get")
public class Lazy<T> {
    private final Supplier<T> supplier;
    private volatile T t;

    public Lazy(Supplier<T> supplier) {
        this.supplier = supplier;
    }

    @Modified
    @Mark("get")
    public T get() {
        T localT = t;
        if (localT != null) return localT;

        synchronized (this) {
            if (t == null) {
                t = Objects.requireNonNull(supplier.get());
            }
            return t;
        }
    }
}
----

After calling the marker method `get()`, `t` cannot be assigned anymore.
Because it is of an unbound type, the field `t` is `@NotModified`.
Because it is a functional type, `supplier` is `@NotModified`.
The type is also clearly a container.
Tte type violates the independence rule, so it is not a `@E2Container`.

==== Case E2ImmuAnnotationExpressions

Code can be summarized as:

[source,java]
----
public class E2ImmuAnnotationExpressions {

    @NotModified
    private final TypeStore typeStore;

    public E2ImmuAnnotationExpressions(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
    }

    public final Lazy<AnnotationExpression> beforeImmutableMark =
      new Lazy<>(() -> create(BeforeImmutableMark.class));
    // ... like beforeImmutableMark there's many more

    @NotModified
    private AnnotationExpression create(Class<?> clazz) {
      ... // reads from the typeStore
    }

    @NotModified
    @NotNull
    public TypeInfo getFullyQualified(@NotNull String fqn) {
        return Objects.requireNonNull(typeStore.get(fqn));
    }
}
----

The `TypeStore` is eventually an `@E2Container`, once all types have been added.
The types in the store are of class `TypeInfo`.
They are independent of the `typeStore`, so rule 3 is satisfied both for constructor and `getFullyQualified` method.

The type `Lazy` is eventually an `@E1Container`, which makes it irrelevant what the nature of `AnnotationExpression` is.

We can therefore conclude that `E2ImmuAnnotationExpressions` as depicted here is eventually an `@E2Container`.

Let's now remove the `Lazy` intermediate, by changing the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions2 {

    @NotModified
    private final TypeStore typeStore;

    public final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions2(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }
    ...
}
----

Because `Lazy` has gone, we would have an `@E1Immutable` restriction on `AnnotationExpression`
to maintain `@E2Immutable`.
Similarly, if we change the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions3 {

    @NotModified
    private final TypeStore typeStore;

    private final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions3(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }

    public AnnotationExpression getBeforeImmutableMark() {
        return this.beforeImmutableMark;
    }

    ...
}
----

We again have an independence rule to contend with, which demands that `AnnotationExpression` is at least `@E1Container`
if we want to maintain `@E2Immutable`.

It is important to realize that `@E1Immutable` is not _less desirable_ than `@E2Immutable`.
The former exists merely for simpler constructs than the latter.
Where there is a mixture of fields with constructs which require support data, and fields which don't, intermediates such as `Lazy` may be necessary for the overall `@E2Immutable` to be reached.

In other words, the analyser will compute the level of immutability achieved.
If the analyser finds level 1, and the programmer expects level 2, an error will be raised.

Current attitude: the definitions work well and are correct in many cases.
We will have them implemented, and may get to better insights later.
One doubt remains: can we automatically deduce whether we need level 1 or level 2?

One potential rule emerges:

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods, then we need level 2 immutability in rules 2 and 3 for that particular field.
Otherwise, level 1 immutability is sufficient.
****

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods, then we need level 1 immutability in rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.
****

This rule definitely works for types which hold collections to which individual entries can be added.
Consider the simplified example of the `TypeStore`:

[source,java]
----
class TypeStore {
    private final Trie<TypeInfo> trie = new Trie<>();
    ...
    public void add(TypeInfo typeInfo) {
        ....
        this.trie.add(typeInfo);
    }
}
----

The `TypeStore` has a field of type `Trie` (_A_), which holds elements of type `TypeInfo` (_B_);
`TypeInfo` also occurs in the non-private methods.


`Lazy` in itself is an eventual `@E1Container`.
The type `E2ImmuAnnotationExpressions` holds a type, _A_, `Lazy<AnnotationExpression>`, which holds `AnnotationExpression`.
Now `AnnotationExpression` does not occur in any of the methods of `E2ImmuAnnotationExpressions`, but we trivially can make it so by introducing:

[source,java]
----
public AnnotationExpression getBeforeImmutableMark() {
  return this.beforeImmutableMark.get();
}
----

or by making the `create()` method public.

The rule will need to apply to rules 2 and 3 of the level 2 immutability definition; but, we can apply the rule on a field-by-field basis.
We definitely need to allow for creativity; the programmer should be able to overrule.

==== Combination example

First consider

[source,java]
----
@E2Container
class TypeStore {
    public final TypeInfo object;
    public final TypeInfo string;

    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
        object = get("java.lang.Object");
        string = get("java.lang.String");
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The trie holds `TypeInfo` objects.
Rules 2 and 3 will apply to fields and methods of the type `Trie`, not to fields and methods of the type `TypeInfo`.

This type can be level 2 immutable when

. it is `@E1Immutable`.
This is fine: all fields are `final`, and there are no modifying methods.

. the non-private fields are of type `TypeInfo`, which is directly returned by one of the methods.
There is no additional restriction on them.

. The `TypeInfo` object returned by the `get` method is not subject to independence requirements.
The `trie` field must be independent of the `allTypes` parameter because the trie holds `TypeInfo` objects.
Given that they are completely separate data structures, this should be no problem.

It is important to observe that we need not have any restriction on `TypeInfo`, nor on `Trie`!

Now, adding a method

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return trie;
}
----

would force the `Trie` type to be `@E1Immutable` as well for independence to be achieved, and the `@E2Immutable` status to be kept.
Alternatively, we could change the method to:

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return new Trie(trie.elements());
}
----

in order to return a copy.

[source,java]
----
@E2Container
class TypeStore {
    public final Lazy<TypeInfo> object =
        new Lazy<>(() -> get("java.lang.Object"));
    public final Lazy<TypeInfo> string =
        new Lazy<>(() -> get("java.lang.String"));
    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The two public fields are of type `Lazy`, which holds `TypeInfo`, and `TypeInfo` is present in one public method.
As a consequence, `Lazy` must be at least `@E1Immutable`, but that is fine.
In this second example, `Lazy` acts as a data structure.

=== Realize that

this version of the level 2 immutability definition is more like an _as immutable as it 's going to get_ definition.
It does accord with the intuitive definition.
The number (level 1, level 2) has less to do with the effective depth.

=== To check

Is linking using this new definition of `@E2Immutable` sufficient?
