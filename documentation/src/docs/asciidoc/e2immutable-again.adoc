== The road to immutability

=== Level 1 immutability

Let us start with a definition:

****
*Definition*: We say a field is *effectively final* when it either has the modifier `final`, or it is not assigned to in methods that can be transitively called from non-private (non-constructor) methods.
****

The code analyser annotates with `@Final` in the latter case; there is no point in cluttering with an annotation when the modifier is already there.
It annotates fields that are not effectively final with `@Variable`.

This definition allows effectively final fields to be assigned in methods accessible only from the constructor:

.Example 1, effectively final, but not with the `final` modifier
[source,java]
----

----

Obviously, if the same method is also accessible after construction, the field becomes variable:

.Example 2, the method is accessible after construction
[source,java]
----

----

Please note that it is perfectly possible to rewrite the first example in such a way that the `final` modifier can be used.
From the point of view of the code analyser, it does not matter.
The wider definition will allow for more situations to be recognized as they really are.

When an object consists solely of primitives, or deeply immutable objects such as `java.lang.String`, having all fields effectively final is sufficient to generate an object that is again deeply immutable.

.Example 3, an object consisting of primitives and a string.
[source,java]
----
class DeeplyImmutable1 {
    public final int x;
    public final int y;
    public final String message;

    public DeeplyImmutable1(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }
}
----

.Example 4, another way of being effectively final
[source,java]
----
class DeeplyImmutable2 {
    @Final
    private int x;
    @Final
    private int y;
    @Final
    private String message;

    public DeeplyImmutable2(int x, int y, String message) {
        this.message = message;
        this.x = x;
        this.y = y;
    }

    public String getMessage() {
        return message;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
----

Examples 3 and 4 are functionally equivalent: there is no way of changing the values of the fields once they have been set.
In the real world there may be a reason why someone requires the getters.
Or, you may be given code as in Example 2, but you are not allowed to change it.
Whatever the reason, the code analyser should recognize effective finality for what it is.

Note that we will not make a distinction between any of the different non-private access modes in Java.
Only the private modifier gives sufficient guarantees that no reassignment to the fields is possible.

We now have observed that in view of immutability, having all your fields effectively final can be useful in certain circumstances.
We use this concept to define a first level of immutability:

****
*Definition*: We call a type *effectively level 1 immutable* when all its fields are effectively final.
****

The code analyser annotates level 1 immutable types with `@E1Immutable`.
Types that are not `@E1Immutable` because they have at least one `@Variable` field, are annotated `@Mutable`.

As above with effective finality, the term _effective_ is present to make a distinction between formal immutability, and immutability that the code analyser computes.
It will also serve to distinguish from _eventual_ immutability, where (in this case) the finality will be achieved only after the code reaches a certain state.
More on this later, but here is a first example of an eventually level 1 immutable type:

.Simplified version of `SetOnce`
[source,java]
----
@E1Immutable(after="set")
class SetOnce<T> {
    private T t;
    @Mark("set")
    public void set(T t) {
        if(t == null) throw new NullPointerException();
        if(this.t == null) throw new UnsupportedOperationException("Already set");
        this.t = t;
    }
    @Only(after="set")
    public void get() {
        if(t == null) throw new UnsupportedOperationException("Not yet set");
        return t;
    }
}
----

Once a value has been set, the field `t` cannot be assigned anymore.

We have just observed that if one restricts to primitives and types like `java.lang.String`, level 1 immutability is sufficient to guarantee deep immutability.
It is not feasible (and we do not wish to) work with deeply immutable objects only.
Moreover, it is easy to see that level 1 immutability may not enough to agree with all purposes of immutability:

.Example 5, level 1 immutability may not enough
[source,java]
----
@E1Immutable
class StringsInArray {
    private final String[] data;
    public StringsInArray(String[] strings) {
        this.data = strings;
    }
    public String getFirst() {
        return data[0];
    }
}

...
String[] strings = { "a", "b" };
StringsInArray sia = new StringsInArray(strings);
Assert.assertEquals("a", sia.getFirst());
strings[0] = "c";
Assert.assertEquals("c", sia.getFirst());
----

To continue, we must first understand the notion of modification.

=== Modification

****
*Definition*: a method is *modifying* if it causes an assignment in the object graph of the fields of this object.
****

We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.

Consequently, a method is not modifying if it only reads from the object graph of the fields.
The code analyser uses the annotations `@NotModified` and `@Modified`.
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we will clutter by annotating them.

For clarity, we repeat that directly assigning to the fields also constitutes a modification.
As an example, setters are `@Modified`, while getters are `@NotModified`:

[source,java]
----
@Mutable
class Message {
    @Variable
    private String message;

    @NotModified
    public String getMessage() {
        return message;
    }

    @Modified
    public void setMessage(String message) {
        this.message = message;
    }
}

class Example2 {
    @Final
    @Modified
    private final Message message = new Message();

    public Example2() {
        message.setMessage("No message yet");
    }

    @Modified
    public void inform(String info) {
        this.message.setMessage(info);
    }
}
----

We also see in the example that the `inform` method is `@Modified`.
This is because it calls a modifying method on one of the fields: `setMessage`.

The code analyser annotates a parameter with `@NotModified` when the parameter's method does not apply modifying methods on the object that enters the method via the parameter.
This restriction holds in the strongest possible way, a topic which we will elaborate on later.
If a parameter is not `@NotModified`, it is `@Modified`.

We will apply exactly the same reasoning to a field.
A field will be annotated `@NotModified` when none of the type's methods, transitively reachable from a non-private non-constructor method, applies modifying methods on this field.
This restriction again holds in the strongest possible way.
If a field is not `@NotModified`, it is `@Modified`.

Clearly `@NotModified` is stronger than `@Final`: a field that is not `@Final` cannot be `@NotModified`.
A field that is `@NotModified` must be `@Final`.

Before delving deeper into definitions, let us agree that the methods of `Object` and `String` are all `@NotModified`.
This is pretty obvious in the case of `toString`, `hashCode`, `getClass`.
It is less obvious for the `wait` and other synchronization-related methods.

IMPORTANT: As a general rule, we will exclude synchronization support from this discussion.

Note also that we cannot add modifying methods to the type `DeeplyImmutable1` in Example 3.

For clarity, let's also look at (a part of) the `Collection` interface, where we've restricted the annotations to `@NotModified` and `@Modified`:

.Showing the modification status of methods in the `Collection` interface
[source,java]
----
public interface Collection<E> extends Iterable<E> {
    @Modified
    boolean add(E e);

    @Modified
    boolean addAll(@NotModified Collection<? extends E> collection);

    @NotModified
    boolean contains(Object object);

    @NotModified
    boolean containsAll(@NotModified Collection<?> c);

    @NotModified
    void forEach(Consumer<? super E> action);

    @NotModified
    boolean isEmpty();

    @Modified
    boolean remove(Object object);

    @Modified
    boolean removeAll(@NotModified Collection<?> c);

    @NotModified
    int size();

    @NotModified
    Stream<E> stream();

    @NotModified
    Object[] toArray();
}
----

Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.

IMPORTANT: The code analyser cannot compute annotations from an interface.
They must be manually added, to convey the intentions of the methods.

Adding all elements of a collection to the object (in `addAll`) should not modify the input collection, whence the `@NotModified`.
Other types in the parameters do not have a `@NotModified` annotation:

* `Object` because it is deeply immutable,
* `E` because it is of an unbound generic type, it has the same methods available as `Object`,
* `Consumer` because it is a functional type, with only one method, which is always `@NotModified`.

The rules for not having to write `@NotModified` will be detailed later, but this example pretty much covers all the bases.

=== Containers

Loosely speaking, a container is a type to which you can safely pass on your objects, it will not modify them.
This is the formal rule:

****
*Definition*: a type is a *container* when none of the parameters of the non-private methods and constructors of the type are modifying.
****

Whatever else the container does, storing the parameters in fields or not, it will not change your objects.
You obviously remain free to change them, and the container will keep on holding the changed object, not some copy.

Containers are complementary to immutable objects, and we will find that many immutable objects are containers, while some containers can be modified to become immutable.
There are two archetypes for containers: collections and builders.

The code analyser will annotate a type that is both level 1 immutable, and a container, with `@E1Container`.
This occurs frequently enough to justify a separate annotation.
The simple but useful utility type `Pair` trivially satisfies both requirements:

.A pair of objects
[source,java]
----
@E1Container
public class Pair<K,V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
    public K getK() {
        return k;
    }
    public V getV() {
        return v;
    }
}
----

While it is clearly level 1 immutable, it will remain to be seen if it satisfies all criteria for intuitive immutability.
However, it is more visible as a container: a type you use and trust to hold objects.

=== Linking, intuitively

Let us now elaborate on how we will compute modifications, in a path towards level 2 immutability.
Consider the following example:

.Example 6, field linked to constructor parameter
[source,java]
----
class WithSet<X> {
    private final Set<X> set;

    public WithSet(Set<X> xs) {
        this.set = xs;
    }
    public void add(X x) {
        set.add(x);
    }
}
----

After construction, an instance of `WithSet` contains a reference to the set that was passed as an argument to its constructor.
We say the field `set` links to the parameter `xs` of the constructor.
In this example, this is an expensive way of saying that there is an assignment from one to the other.
However, linking can become more complicated.

The code analyser will add modification annotations as follows:

.Example 7, field linked to constructor parameter, with annotations
[source,java]
----
class WithSet<X> {
    @Modified
    private final Set<X> set;

    public WithSet(@Modified Set<X> xs) {
        this.set = xs;
    }

    @Modified
    public void add(X x) {
        set.add(x);
    }
}
----

As noted above, the parameter `x` of `WithSet.add` is trivially `@NotModified`  because unbound parameter types have no modifying methods that can be called on them.

Linking looks at the underlying object, and not at the variable.
Consider the following alternative `add` method:

.Example 8, alternative `add` method
[source,java]
----
@Modified
public void add(X x) {
    Set<X> theSet = this.set;
    X theX = x;
    theSet.add(theX);
}
----

Nothing has changed, obviously.

****
Intuitively, linking means that modifying the source object implies that the linked object may be modified too.
Linking does not work on objects that cannot be modified, like primitives or deeply immutable objects such as `java.lang.String`.
****

We will discuss linking more formally later.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that the object represented by both is the same.

=== Independence

The opposite of linking is independence.
While the code analyser will not annotate linking, it will annotate independence with `@Independent` on methods and constructors, and to parameters in one specific case.

****
*Definition*: A non-private method returning a real value (not `void`, not `this`) is *independent* when the object returned does not link to any of the fields of the class.
****

The definition for independence on a constructor is very similar:

****
*Definition: A constructor is *independent* when the fields of the resulting instance do not link to the parameters of the constructor.
****

Finally, there is a definition for cases where method results are transported via parameters rather than the return type, as is often the case when using the vertx.io framework, for example:

****
*Definition*: if a method does not return a real value (it is `void`, or it returns `this`), and it has consumer parameters, then it is *independent* when the objects linking to the consumers do not link to the fields of the class or other parameters of the method.
****

It follows immediately that:

- empty constructors of top-level types and static sub-types (but not necessarily sub types-that are not static!) are always independent; no need to annotate
- methods that return primitives or deeply immutable objects are independent, since these objects cannot be modified

=== Level 2 immutability

First, what do we want intuitively?
A useful form of immutability, less strong than deeply immutable, but better than level 1 immutability for quite some situations.
We propose the following:

****
After construction, an immutable type holds a number of objects; the type will not change their content, nor will it exchange them for other objects, or allow others to do so.
The type is not responsible for what others do to the content of the objects it has been given.
****

Technically, level 2 immutability is much harder to define than level 1 immutability.
We identify three rules, one of which must be observed at all times:

****
*Definition*: the *first rule of level 2 immutability* is that all fields must be `@NotModified`.
****

By decomposing all definitions, we observe that requiring all fields to be `@NotModified` is equivalent to requiring that all non-private fields have the `final` modifier, and that methods that are not part of the construction phase, are `@NotModified`.

Clearly, level 2 immutable types will be level 1 immutable as well, given that `@NotModified` implies `@Final` on fields.
Our friend the `Pair` satisfies this first rule:

[source,java]
----
@E1Container
public class Pair<K,V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Note that since `K` and `V` are unbound types, it is not possible to modify their content, since there are no modifying methods one can call on unbound types.
This example doesn't even have non-constructor methods.

How does it fit the intuitive rule for immutability?
The type `Pair` holds two objects.
The type does not change their content, nor will it exchange these two objects for others, or allow others to do so.
It is clear the users of `Pair` may be able to change the content of the objects they put in the `Pair`.
Summarizing: `Pair` fits the intuitive definition without any problem.

Here is an example which shows the necessity of the first rule more explicitly:

[source,java]
----
@Mutable
class Point {
    @Variable
    private double x;
    @Variable
    private double y;

    public double getX() {
        return x;
    }
    public void setX(double x) {
        this.x = x;
    }
    public double getY() {
        return y;
    }
    public void setY(double y) {
        this.y = y;
    }
}

class Line {
    @Final
    private Point point1;
    @Final
    private Point point2;

    public Line(Point point1, Point point2) {
        this.point1 = point1;
        this.point2 = point2;
    }

    @NotModified
    public Point middle() {
        return new Point((point1.getX() + point2.getX())/2.0,
             (point1.getY()+point2.getY())/2.0);
    }

    @Modified
    public void translateHorizontally(double x) {
        point1.setX(point1.getX() + x);
        point2.setX(point2.getX() + x);
    }
}
----

The fields `point1` and `point2` are effectively final.
Without the translation method, the fields would be `@NotModified` as well.
The translation method modifies their content, rendering the type not level 2 immutable.

Assuming a type's goal is to store a number of objects, it is easy to see that a level 1 immutable type cannot hold additional, modifiable state.
It follows that every method call on the container object with the same arguments will render the same result.
(Note that this can be bypassed in Java by using _static_ state, i.e., state specific to the type rather than the object.
Let us ignore that for now.)

In order to hold an arbitrary (or even modestly large) amount of objects, a type has to have 'support data': think an array, a tree structure, buckets for a hash table, etc.
The difference between effectively final fields and the rest of the definition of level 2 immutability is essentially about expressing the immutability of the support data.
After construction, a level 2 immutable type will still hold a fixed number of objects, and the type will not change their content, nor exchange them for other objects, nor allow others to exchange them.

We will introduce two additional rules to the definition of level 2 immutability.
They will only have to be satisfied by _some_ fields; requiring them for all fields results in too strong a definition, and we have seen higher up that there are situations where the first rule is sufficient.
The fields we target with those additional rules are the fields containing the support data.
For now, we try to catch the support data with the following, most likely imperfect rule:

****
If a type _A_ is the type of a field, and type _B_, which is held by _A_, appears as type of parameter or as return type in non-private methods (directly, or held by a different type _C_), then we need the level 2 immutability rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.

A type _B_ is held by the type _A_ if _B_ is the type of a field in _A_, directly or via generics, and potentially transitively.
****

Many examples will follow, but it should be clear from the description that types that appear both in fields and in non-private methods, do not need to satisfy rules 2 and 3. This is the case for `Pair`.

We now write rules 2 and 3 as:

****
*Rule 2 of level 2 immutability*: a field is either private, or level 2 immutable itself.
This rule applies to all fields of types of support data types.

*Rule 3 of level 2 immutability*: all constructors and non-private methods are `@Independent`.
The independence applies to all support data types.
****

Rule 2 is there to ensure that the content of the object cannot be modified by means of access to the non-private fields.
Rule 3 ensures that the content of the object cannot be modified externally.

The first rule can be reached _eventually_ if there is one or more methods that effect a transition from the mutable to the immutable state.
This typically means that all methods that assign or modify fields become off-limits after calling this marker method.
Eventuality for rules 2 and 3 seems too far-fetched.
More on this topic in the section on eventual immutability.

Let us go to examples immediately.

.Example with array, v1
[source,java]
----
class ArrayContainer1<T> {
    private final T[] data;
    public ArrayContainer1(T[] ts) {
        this.data = ts;
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

After creation, changes to the source array `ts` are effectively changes to the data array `data`.
This construct fails rule 3, independence.
Here the array of type `T[]` is the support data that holds `T`, which also appears in the return type of the `stream` method, held by `Stream`.

.Example with array, v2, still not OK
[source,java]
----
class ArrayContainer2<T> {
    public final T[] data;
    public ArrayContainer2(T[] ts) {
        this.data = new T[ts.length];
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

Users of this type can modify the content of the array using direct field access!
This construct fails rule 2, which applies for the same reasons as in the previous example.

.Example with array, v3, safe
[source,java]
----
class ArrayContainer3<T> {
    private final T[] data; // <1>
    public ArrayContainer3(T[] ts) {
        this.data = new T[ts.length]; // <2>
        System.arraycopy(ts, 0, data, 0, ts.length);
    }
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----
<1> The array is private, and therefore protected from modification.
<2> The array has been copied, and therefore is independent of the one passed in the parameter.

The independence rule enforces the type to have its own structure rather than someone else's.
Here's the same group of example, now with JDK Collections:

.Example with collection, v1
[source,java]
----
class SetBasedContainer1<T> {
    private final Set<T> data;
    public SetBasedContainer1(Set<T> ts) {
        this.data = ts; // <1>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> After creation, changes to the source set are effectively changes to the data.

.Example with collection, v2, still not OK
[source,java]
----
class SetBasedContainer2<T> {
    public final Set<T> data; // <1>
    public SetBasedContainer2(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> Users of this type can modify the content of the set after creation!

.Example with set, v3, safe
[source,java]
----
class SetBasedContainer3<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> The set is private, and therefore protected from external modification.
<2> The set has been copied, and therefore is independent of the one passed in the parameter.

.Example with set, v4, safe
[source,java]
----
class SetBasedContainer4<T> {
    public final ImmutableSet<T> data; // <1>
    public SetBasedContainer4(Set<T> ts) {
        this.data = ImmutableSet.copyOf(ts); // <2>
    }
    public Stream<T> stream() {
        return data.stream();
    }
}
----
<1> the data is public, but the `ImmutableSet` is `@E2Immutable` itself.
<2> Independence guaranteed.

The independence rule 3 is there to ensure that the type does not expose its support data through parameters and return types:

.Example with set, v5, unsafe
[source,java]
----
class SetBasedContainer5<T> {
    private final Set<T> data; // <1>
    public SetBasedContainer5(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }
    public Set<T> getSet() {
        return data; // <3>
    }
}
----
<1> No exposure via the field
<2> No exposure via the parameter of the constructor
<3> ... but exposure via the getter.
We could as well have made the field `public final`.

==== Examples

This is a `@Container`, the field is `@Final`, but the field is not `@NotModified`:

[source,java]
----
class Example2 {
    @Final
    @Modified
    public final Set<T> set = new HashSet<>();

    @Modified
    public void add(T t) { set.add(t); }

    @NotModified
    public Stream<T> stream() { return set.stream(); }
}
----

==== Case Lazy

`Lazy` implements a lazily-initialized immutable field, of unbound generic type `T`.
As such, it is eventually an `@E1Container`.

[source,java]
----
@E1Container(after = "get")
public class Lazy<T> {
    private final Supplier<T> supplier;
    private volatile T t;

    public Lazy(Supplier<T> supplier) {
        this.supplier = supplier;
    }

    @Modified
    @Mark("get")
    public T get() {
        T localT = t;
        if (localT != null) return localT;

        synchronized (this) {
            if (t == null) {
                t = Objects.requireNonNull(supplier.get());
            }
            return t;
        }
    }
}
----

After calling the marker method `get()`, `t` cannot be assigned anymore.
Because it is of an unbound type, the field `t` is `@NotModified`.
Because it is a functional type, `supplier` is `@NotModified`.
The type is also clearly a container.
Tte type violates the independence rule, so it is not a `@E2Container`.

==== Case E2ImmuAnnotationExpressions

Code can be summarized as:

[source,java]
----
public class E2ImmuAnnotationExpressions {

    @NotModified
    private final TypeStore typeStore;

    public E2ImmuAnnotationExpressions(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
    }

    public final Lazy<AnnotationExpression> beforeImmutableMark =
      new Lazy<>(() -> create(BeforeImmutableMark.class));
    // ... like beforeImmutableMark there's many more

    @NotModified
    private AnnotationExpression create(Class<?> clazz) {
      ... // reads from the typeStore
    }

    @NotModified
    @NotNull
    public TypeInfo getFullyQualified(@NotNull String fqn) {
        return Objects.requireNonNull(typeStore.get(fqn));
    }
}
----

The `TypeStore` is eventually an `@E2Container`, once all types have been added.
The types in the store are of class `TypeInfo`.
They are independent of the `typeStore`, so rule 3 is satisfied both for constructor and `getFullyQualified` method.

The type `Lazy` is eventually an `@E1Container`, which makes it irrelevant what the nature of `AnnotationExpression` is.

We can therefore conclude that `E2ImmuAnnotationExpressions` as depicted here is eventually an `@E2Container`.

Let's now remove the `Lazy` intermediate, by changing the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions2 {

    @NotModified
    private final TypeStore typeStore;

    public final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions2(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }
    ...
}
----

Because `Lazy` has gone, we would have an `@E1Immutable` restriction on `AnnotationExpression`
to maintain `@E2Immutable`.
Similarly, if we change the code to:

[source,java]
----
public class E2ImmuAnnotationExpressions3 {

    @NotModified
    private final TypeStore typeStore;

    private final AnnotationExpression beforeImmutableMark;

    public E2ImmuAnnotationExpressions3(@NotNull TypeStore typeStore) {
        this.typeStore = typeStore;
        this.beforeImmutableMark = create(BeforeImmutableMark.class);
    }

    public AnnotationExpression getBeforeImmutableMark() {
        return this.beforeImmutableMark;
    }

    ...
}
----

We again have an independence rule to contend with, which demands that `AnnotationExpression` is at least `@E1Container`
if we want to maintain `@E2Immutable`.

It is important to realize that `@E1Immutable` is not _less desirable_ than `@E2Immutable`.
The former exists merely for simpler constructs than the latter.
Where there is a mixture of fields with constructs which require support data, and fields which don't, intermediates such as `Lazy` may be necessary for the overall `@E2Immutable` to be reached.

In other words, the analyser will compute the level of immutability achieved.
If the analyser finds level 1, and the programmer expects level 2, an error will be raised.

Current attitude: the definitions work well and are correct in many cases.
We will have them implemented, and may get to better insights later.
One doubt remains: can we automatically deduce whether we need level 1 or level 2?

One potential rule emerges:

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods, then we need level 2 immutability in rules 2 and 3 for that particular field.
Otherwise, level 1 immutability is sufficient.
****

****
Rule?
If a type _A_ appears in a field, and type _B_, which is held by _A_, appears in public methods (directly, or held in a different way), then we need level 1 immutability in rules 2 and 3 for that particular field.
Otherwise, we skip rules 2 and 3 for the field.
****

This rule definitely works for types which hold collections to which individual entries can be added.
Consider the simplified example of the `TypeStore`:

[source,java]
----
class TypeStore {
    private final Trie<TypeInfo> trie = new Trie<>();
    ...
    public void add(TypeInfo typeInfo) {
        ....
        this.trie.add(typeInfo);
    }
}
----

The `TypeStore` has a field of type `Trie` (_A_), which holds elements of type `TypeInfo` (_B_);
`TypeInfo` also occurs in the non-private methods.


`Lazy` in itself is an eventual `@E1Container`.
The type `E2ImmuAnnotationExpressions` holds a type, _A_, `Lazy<AnnotationExpression>`, which holds `AnnotationExpression`.
Now `AnnotationExpression` does not occur in any of the methods of `E2ImmuAnnotationExpressions`, but we trivially can make it so by introducing:

[source,java]
----
public AnnotationExpression getBeforeImmutableMark() {
  return this.beforeImmutableMark.get();
}
----

or by making the `create()` method public.

The rule will need to apply to rules 2 and 3 of the level 2 immutability definition; but, we can apply the rule on a field-by-field basis.
We definitely need to allow for creativity; the programmer should be able to overrule.

==== Combination example

First consider

[source,java]
----
@E2Container
class TypeStore {
    public final TypeInfo object;
    public final TypeInfo string;

    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
        object = get("java.lang.Object");
        string = get("java.lang.String");
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The trie holds `TypeInfo` objects.
Rules 2 and 3 will apply to fields and methods of the type `Trie`, not to fields and methods of the type `TypeInfo`.

This type can be level 2 immutable when

. it is `@E1Immutable`.
This is fine: all fields are `final`, and there are no modifying methods.

. the non-private fields are of type `TypeInfo`, which is directly returned by one of the methods.
There is no additional restriction on them.

. The `TypeInfo` object returned by the `get` method is not subject to independence requirements.
The `trie` field must be independent of the `allTypes` parameter because the trie holds `TypeInfo` objects.
Given that they are completely separate data structures, this should be no problem.

It is important to observe that we need not have any restriction on `TypeInfo`, nor on `Trie`!

Now, adding a method

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return trie;
}
----

would force the `Trie` type to be `@E1Immutable` as well for independence to be achieved, and the `@E2Immutable` status to be kept.
Alternatively, we could change the method to:

[source,java]
----
public Trie<TypeInfo> getTrie() {
    return new Trie(trie.elements());
}
----

in order to return a copy.

[source,java]
----
@E2Container
class TypeStore {
    public final Lazy<TypeInfo> object =
        new Lazy<>(() -> get("java.lang.Object"));
    public final Lazy<TypeInfo> string =
        new Lazy<>(() -> get("java.lang.String"));
    private final Trie<TypeInfo> trie = new Trie<>();

    public TypeStore(Collection<TypeInfo> allTypes) {
        this.trie.addAll(allTypes);
    }
    ...
    @NotModified
    public TypeInfo get(String fqn) {
        ...
    }
}
----

The two public fields are of type `Lazy`, which holds `TypeInfo`, and `TypeInfo` is present in one public method.
As a consequence, `Lazy` must be at least `@E1Immutable`, but that is fine.
In this second example, `Lazy` acts as a data structure.

The following example shows that `Stream<M>` should trigger the rules of `@E2Immutable`:

[source,java]
----
class ImmutableMSet {
    private Set<M> ms;
    public ImmutableMSet(Set<M> ms) {
        this.ms = new HashSet<>(ms);
    }
    public Stream<M> stream() {
        return ms.stream();
    }
}
----

=== Realize that

this version of the level 2 immutability definition is more like an _as immutable as it 's going to get_ definition.
It does accord with the intuitive definition.
The number (level 1, level 2) has less to do with the effective depth.

=== Additional requirements

. Having `@Immutable` objects in an `@E1Immutable` object such as `Pair` makes the object effectively or eventually `@Immutable`.

. Having deeply immutable objects in an `@E2Immutable` object makes the object deeply immutable.

We may need better terminology, however, deeply immutable is not relevant to what we're doing.

=== To check

Is linking using this new definition of `@E2Immutable` sufficient?

Rules center around

. direct assignment
. assignment to sub-field
. method result, with various limitations when a type is immutable

How do these limitations work?
For deeply immutable objects, this is trivial: there's no point in linking because no modifications can be made.
For other objects, the level of immutability will have an effect.

Let type `M` be `@Mutable`.
Then `SetOnce<M>` is `@E1Immutable` but not deeply immutable.

In the following example, the rules for `@E2Immutable` are not triggered, because `M` remains hidden.
It is therefore immaterial what type `SetOnce` is:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public SetOnce<M> getM() {
        return m1;
    }
}
----

It is therefore "equivalent" to:

[source,java]
----
class CopyOfM {
    private M m;
    public CopyOfM(M m) {
        this.m = m;
    }
    public M getM() {
        return m;
    }
}
----

Once you give it the `m` object, it'll keep it.
You can change the content of `m`, but that's immaterial.

This will trigger the `@E2Immutable` rules:

[source,java]
----
class CopyOfSetOnce {
    private SetOnce<M> m1;
    public CopyOfSetOnce(SetOnce<M> m1) {
        this.m1 = m1;
    }
    public M getM() {
        return m1.get();
    }
}
----

Because the argument is `@E1Immutable` we will always have the same `m` in the getter!
Here _as immutable as it gets_ is fine; level 1 immutability breaks the linking.

Changing the `SetOnce` for a `List`, which will need level 2:

[source,java]
----
class DirectAssignmentOfSet {
    private List<M> ms;
    public DirectAssignmentOfSet(List<M> ms) {
        this.ms = ms;
    }
    public M getFirst() {
        return ms.get(0);
    }
}
----

Clearly the field `ms` is linked to the parameter of the constructor.
This link can only be broken with level 1 immutability, otherwise, the user can change the result of `getFirst` by modifying the list after constructing an instance of the type.
The level 2 extensions do not seem to be necessary in this example: as long as we can ensure that the list does not change, we're fine.
Level 1 will ensure that no modifying objects can be called.
Recursively, this implementation of `List` may be modifiable from the outside.
We conclude we need level 2 extensions in the independence computation.
