:source-language: java

=== Patterns

One of the ultimate goals of having a code analyser is to be able to improve the code.
Because multiple people contribute to the same code base over a large span of time, different coding habits result in functionally equivalent, but visually different code.
These visual differences may make it more difficult to spot errors: if a coder usually writes out loops instead of using streams, they find it more difficult (it will take fractionally more time) to grasp the meaning of a construct.
The exact opposite will happen a lot as well: younger coders who grew up with Java 8 will find older pre-Java 5 code unpleasant to look at.

Here are some more of these taste differences:

* verbose versus compact code
* use of iterators or `while` constructs where `for`-loops will work
* unnecessary `else` statements when there is a `return` statement in the `if` part
* unnecessary re-assignment to variables

If the code analyser is able to make a compact internal representation, it can

* _write out the same code in many equivalent ways_.
* Conversely, it can _spot functionally identical code_ which looks very different in two or more places.
* The internal representation is also _less language dependent_, which facilitates language converters.
* it can evaluate the internal representation in case of constants, which catches a great many trivial bugs in the code, which in turn speeds up development

For internal purposes, it is important to transform non-modifying code into functional statements (what we will call here _inlining_).
The `@E2Immutable` and `@NotModified` annotations are crucial to increase the chances of being able to inline code.

==== Alternative value

The following abstract construct

.Example 1
[source]
----
Object a = expensiveComputation(b);
if(someCondition(a)) {
  a = alternativeValue(c);
}
----

is very often seen, for example in

.Example 2
[source]
----
Value v = map.get(key);
if(v == null) {
  v = defaultValue;
}
----

Assuming the `expensiveComputation` is not modifying, this piece of code translates into the functional

.Example 3
[source]
----
Value v = condition(expensiveComputation(b)) ? expensiveComputation(b) : alternative(c);
----

which obviously is not workable at execution time because of the repetition of the expensive computation.
Note that we have switched around the order, and take the positive side of the condition for the existing value.
Much better is to involve an additional temporary variable:

.Example 4
[source]
----
Value inMap = map.get(key);
Value v = condition(inMap) ? inMap : alternative(c);
----

If we recognize this pattern, and internally assign a special type of value to it, we can eliminate the temporary variable.
This increases the amount of code that can be used for inlining.

The value will be represented by a Python-like ternary operator

.Syntax of AlternativeAssignmentValue
[source]
----
x if someCondition(x) else y
----

The main differentiator is that `x` will be evaluated once.

==== Joining return statements

Consider the following pieces of code

.Example 1
[source]
----
if(s == null) return -1;
return s.length;
----

.Example 2
[source]
----
if(s == null) {
    return -1;
} else {
    return s.length;
}
----

.Example 3
[source]
----
if(s == null) {
    LOGGER.debug("The string s was null!");
    return -1;
} else {
    return s.length;
}
----

.Example 4
[source]
----
return s == null ? -1: s.length;
----

For the purpose of the _single return value_ of the method, they are all functionally identical.
There are good reasons to internally transform the code towards Example 4. The single criterion is that `s` is not modified between the condition and the return statement.
When the code between condition and return statements is not modifying at all, it can be replaced by an inline operation.
In Example 3 we see a `debug` statement which makes no modifications; it can be discarded functionally.
However, the code in the following example cannot be replaced by the inline conditional, because `addToSet(s)` is modifying:

.Example 5
[source]
----
if(s == null) {
    return -1;
} else {
    addToSet(s);
    return s.length;
}
----

The pattern can be extended to multiple exits:

.Example6
[source]
----
if(condition1) {
  if(condition2) {
    return a;
  }
  return b;
}
return c;
----

which will end up being written as

.Example 7
[source]
----
return condition1 ? (condition2 ? a : b) : c;
----

However, quite often there are gaps in conditions with respect to return statements, as in

.Example 8
[source]
----
if(condition1) {
  if(condition2) {
    addToSet(a);
  } else {
    return b;
  }
}
return c;
----

which makes it a lot less clear-cut to extract a single return value.
The code is functionally identical to

.Example 9
[source]
----
if(condition1 && condition2) addToSet(a);
return condition1 && !condition2 ? b : c;
----

==== Trivial joining of return statements

.Example 1
[source]
----
if(conditionA) return x;
if(conditionB) return x;
----

will be combined into

.Result of joining in Example 1
[source]
----
if(conditionA || conditionB) return x;
----

==== Reuse of local computation

Closely related to the two patterns above is a reused computation:

.Example 1
[source]
----
Value v = someComputation(p);
someCondition ? otherComputation(v) : thirdComputation(v)
----

Clearly if `someComputation` has no side effects, it can be substituted into the second expression.
(This second expression could be anything, as long as `v` appears multiple times, and it is not modifying either.) Again we are interested in removing the local variable so that we can get rid of the variable assignment and can inline the second expression.

What is the point?
Before you know it, we're simply re-writing the method, and we could as well do that.
The primary reason is standardization of code.

* We're potentially eliminating or anonymizing a variable
* We put the computation next to the place where it is used

.Example 2
[source]
----
Set<String> set = map.get(value);
if(set == null) return 0;
doSomeOtherThingNotRelatedToSet();
LOGGER.log("Set is {}", set);
return set.isEmpty() ? 0: countOccurrences(set, "b");
----

is functionally equivalent to

.Result of transforming Example 2
[source]
----
doSomeOtherThingNotRelatedToSet();
return map.get(value) == null || map.get(value).isEmpty() ? 0 : countOccurrences(map.get(value), "b");
----

or

.Result of transforming Example 2, special syntax
[source]
----
doSomeOtherThingNotRelatedToSet();
return {
  Set<String> set = map.get(value);
  set == null || set.isEmpty() ? 0 : countOccurrences(set, "b");
}
----

The obvious generalisation here is the _independent_ computation of multiple values to be used:

.Independent computations
[source]
----
{
  Value v1 = someComputation(...)
  Value v2 = someOtherComputationIndependentOfV1(...)
  expressionWithV1AndV2MultipleTimesUsed()
}
----

Standardization is again the greatest motivator: the analyser will determine an order of computation.
It should be able to detect this independence, and thanks to the `@NotModified` annotations it knows when methods are modifying or not.

==== Example

[source]
----
Objects.requireNonNull(t); // <1>
Node<T> node = nodeMap.get(t); // <2>
if (node == null) {
  node = new Node<>(t);
  nodeMap.put(t, node);
}
return node;
----
<1> preconditions
<2> reuse of local computation

Should we rewrite this as

[source]
----
return { // <1>
  Objects.requireNonNull(t); // <2>
  Node<T> node = nodeMap.get(t); // <3>
  node != null ? node : return { // <4>
    Node<T> newNode = new Node<>(t); // <5>
    nodeMap.put(t, newNode); // <6>
    newNode
  }
}
----
<1> start of block
<2> precondition
<3> local computation to be reused
<4> start of modifying block
<5> local computation to be reused
<6> modifying method, not influencing the result

==== Emerging pattern 1: non-modifying block with single return

One type of frequently occurring block has the following properties:

. incoming parameters
. preconditions on the incoming parameters
. a number of independent, non-conditional non-modifying computations whose results can be reused.
We compute the computations lazily in the return expression
. a return expression based on the results of the parameters and independent computations.

The required _independence_ means that the computations can be executed in any order.
Computations like those in Pattern 2 (locally modifying fluent chain) fit in step 3.

==== Emerging pattern 2: locally modifying fluent chain

. incoming parameters
. preconditions on the incoming parameters
. primary object is either one of the parameters, or a new object
. chain of fluent methods called, last one decides result

If the fluent methods are modifying, the primary object must be a new object, and modifications must be limited to this new object.
As a consequence, the end result is a "closed loop", independent method.
Functions called in the fluent methods have no modifying effect on the local chain, but may cause side effects.

There are many classic loops that can be transformed into streams:

[source]
----
T result = null;
for(T t : ts) {
  if(predicate(t)) {
    result = t;
    break;
  }
}
----

translates into:

[source]
----
T result = ts.stream().filter(predicate).findFirst().orElse(null);
----

Here is a second one:

[source]
----
StringBuilder sb = new StringBuilder();
for(int i=0; i<10; i++) {
  System.out.println("count "+i);
  sb.append(i);
}
String s = sb.build();
----

can be rewritten as:

[source]
----
StringBuilder sb = new StringBuilder();
IntStream.range(0, n).peek(i -> System.out.println("count "+i).forEach(sb::append);
return sb.toString();
----
which translates into an expression fitting in the pattern:

[source]
----
return IntStream.range(0, n)
  .peek(i -> System.out.println("count "+i)
  .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)
  .toString();
----
using mutable streams. Note that the analyser ignores modifications on `System.out` because of the way we have annotated `java.lang.System`.

