== Immutability patterns

In the `StateData` class, part of the statement analysis data, I found myself using the following construct:

.Common construct in statement analyser
[source,java]
----
private final SetOnce<Expression> precondition = new SetOnce<>();
private Expression currentDelayedPrecondition;

public void setPrecondition(Expression expression, boolean expressionIsDelayed) {
    if (expressionIsDelayed) {
        currentDelayedPrecondition = expression;
    } else if (!precondition.isSet() || !expression.equals(precondition.get())) {
        precondition.set(expression);
    }
}

public Expression getPrecondition() {
    return precondition.getOrElse(currentDelayedPrecondition);
}

public boolean preconditionIsDelayed() {
    return !precondition.isSet();
}

public boolean preconditionIsSet() {
    return precondition.isSet();
}

public boolean preconditionIsEmpty() {
    return currentDelayedPrecondition == null && !precondition.isSet();
}
----

Where `SetOnce` allows you to write exactly once, and `FirstThen` provides a single initial state, followed by a transition to the final state, in this situation the field is truly variable until it becomes final.
I use the term "delayed" to indicate that a firm decision on this value has been delayed to a next iteration of the analyser; in a more generic setting, "variable" is probably better.

The same semantics can be found in the utility class `EventuallyFinal`:
.EventuallyFinal.java

[source,java]
----
@E2Container(after = "isFinal")
public class EventuallyFinal<T> {
    private T value;
    private boolean isFinal;

    public T getValue() {
        return value;
    }

    @Mark("isFinal")
    public void setFinalValue(T value) {
        if (this.isFinal && !Objects.equals(value, this.value)) {
            throw new UnsupportedOperationException("Trying to overwrite different final value");
        }
        this.isFinal = true;
    }

    @Only(before = "isFinal")
    public void setVariableValue(T value) {
        if (this.isFinal) throw new UnsupportedOperationException("Value is already final");
        this.value = value;
    }

    @TestMark("isFinal")
    public boolean isFinal() {
        return isFinal;
    }

    @TestMark(value = "isFinal", before = true)
    public boolean isVariable() {
        return !isFinal;
    }
}
----

The advantage to using this utility class are twofold: it has a slightly smaller memory footprint, and the {e2immu} analyser recognises it as a construct for eventual immutability.
