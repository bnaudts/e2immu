=== List of annotations

For each of the annotations, we answer a couple of standard questions:

Basic:: is this an annotation you definitely should understand?
Immu:: is this annotation part of the immutability concept of the analyzer?
Contract:: will you manually insert this annotation often in interfaces?
Type:: does the annotation occur on types?
Field:: does the annotation occur on (static) fields?
Method:: does the annotation occur on methods and constructors?
Parameter:: does the annotation occur on parameters?

This classification helps to see the wood for the trees in the long list.
We explain the green and red mode in #TODO#.

[#beforeMark-annotation]
==== @BeforeMark

|===
| Basic {n} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {y} | Param {y}
|===

[#constant-annotation]
==== @Constant

|===
| Basic {n} | Immu {n}| Contract {n}| Type {n} | Field {y} | Method {y} | Param {n}
|===

Summary:: The analyser emits this annotation when a field has a constant final value, or a method returns a constant value.
Its primary purpose is to help debug the analyser.
Mode:: This annotation has no opposite.

[#container-annotation]
==== @Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {n} | Method {n} | Param {n}
|===

[#dependent-annotation]
==== @Dependent

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: Annotation used to indicate that the type's fields link to the method's parameter or return value, or the constructor's parameters.
This annotation is only present when there are support data fields.
Additionally, on methods, the analyser only computes the annotation when the method is {nm}.

Mode:: Use this annotation in the red mode.
Its opposite is {independent}.

[#e1container-annotation]
==== @E1Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation is a short-hand for the combination of {e1immutable} and {container}.
Mode:: This annotation sits in between {mutableModifiesArguments}, {container} and {e2container}.

Example:: In the following example, the field `j` remains variable until the user of the class calls `setPositiveJ`.

.Example of eventual @E1Container
[source,java]
----
@E1Container(after = "mark")
class ExampleManualEventuallyE1Container {

    @Final
    private int i;

    @Final(after = "mark")
    private int j;

    public ExampleManualEventuallyE1Container(int i) {
        this.i = i;
    }

    @NotModified
    public int getI() {
        return i;
    }

    @NotModified
    public int getJ() {
        return j;
    }

    @Modified
    @Mark("mark")
    public void setPositiveJ(int j) {
        if (j <= 0) throw new UnsupportedOperationException();
        if (this.j > 0) throw new UnsupportedOperationException("Already set");

        this.j = j;
    }

    @Modified
    @Only(before = "mark")
    public void setNegativeJ(int j) {
        if (j > 0) throw new UnsupportedOperationException();
        if (this.j > 0) throw new UnsupportedOperationException("Already set");
        this.j = j;
    }
}
----

[#e1immutable-annotation]
==== @E1Immutable

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation indicates that a type is level 1 immutable, effectively or eventually, meaning all fields are effectively or eventually final.
Mode:: This annotation sits in between {mutableModifiesArguments} and {e2immutable}.

[#e2container-annotation]
==== @E2Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation is a short-hand for the combination of {e2immutable} and {container}.
Mode:: This annotation is the default in the red mode.

[#e2immutable-annotation]
==== @E2Immutable

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation indicates that a type is level 2 immutable, effectively or eventually.

Mode:: This annotation is the default in the red mode.
Details:: Level 2 immutability adds extra restrictions on top of level 1 immutability:

. all fields must be not modified;
. all fields of support data types must be either private, or level 2 immutable themselves;
. all non-private methods and constructors must be marked {independent}, i.e.,

.. in the case of constructors, the parameters must not link to the fields of support data types;
.. in the case of methods, neither the return value nor the parameters must link to the fields of support data types.
A consequence of requirement of not modified fields, is that non-private methods cannot be modifying.

[#extensionClass-annotation]
==== @ExtensionClass

|===
| Basic {y} | Immu {n}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

[#final-annotation]
==== @Final

|===
| Basic {y} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that a field is effectively or eventually final.
Fields that have the Java modifier `final` possess the annotation, but the analyser does not write it out to avoid clutter.

Mode:: Use this annotation to contract in the green mode, with the opposite, {variable}, being the default.
In the red mode, {final} is the default.

Parameters::
The `after="mark"` parameter indicates that the field is eventually final, after the marking method.

Details:: A field is effectively final when no method, transitively reachable from a non-private non-constructor method, assigns to the field.
A field is eventually final if the above definition holds when one excludes all the methods that are pre-marking, i.e., that hold an annotation `@Only(before="mark")` or `@Mark("mark")`.

Example::
Please find an example of an eventually final field in the example of <<e1container-annotation>>.

.Example for @Variable, @Final
[source,java]
----
@Container
class ExampleManualVariableFinal {

    @Final
    private int i;

    @Variable
    private int j;

    public final int k; // <1>

    public ExampleManualVariableFinal(int p, int q) {
        setI(p);
        this.k = q;
    }

    @NotModified
    public int getI() {
        return i;
    }

    @Modified // <2>
    private void setI(int i) {
        this.i = i;
    }

    @NotModified
    public int getJ() {
        return j;
    }

    @Modified
    public void setJ(int j) {
        this.j = j;
    }
}
----
<.> This field is effectively final, but there is no annotation because of the `final` modifier.
<.> Note that only the constructor accesses this method.

==== @Fluent

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: This annotation indicates that a method returns `this`.
Mode:: There is no opposite for this annotation.
Details:: Fluent methods do not return a real value.
This is of consequence in the definition of independence for methods, as dependence on `this` is ignored.

==== @Identity

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: This annotation indicates that a method returns its first parameter.
Mode:: There is no opposite for this annotation.
Details:: Apart for all the obvious consequences, this annotation has an explicit effect on the linking of variables: a method marked {identity} only links to the first parameter.

==== @IgnoreModifications

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: Helper annotation to mark that modifications on a field are to be ignored, because they fall outside the scope of the application.
Mode:: There is no opposite for this annotation.
It can only be used for contracting, the analyser cannot generate it.
Example:: The only current use is on `System.out` and `System.err`.
The `print` method family is obviously modifying to these fields, however, we judge it to be outside the scope of the application.

==== @Independent

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: Annotation used to indicate that a method or constructor avoids linking the fields of the type to the return value and parameters.
This annotation is only present when there are support data fields.
Additionally, on methods, the analyser only computes the annotation when the method is {nm}.

Mode:: Use this annotation in the green mode.
Its opposite is {dependent}.

* #TODO# check definition for methods, parameters dependent as well?
* #TODO# why do we ignore dependence on this?

==== @Linked

|===
| Basic {n} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: Annotation to help debug the dependence system.
Mode:: There is no opposite.

==== @Mark

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

==== @Modified

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation which indicates that content modifications take place.
Mode:: It is the default in the green mode, when {nm} is not present.

==== @MutableModifiesArguments

|===
| Basic {y} | Immu {y}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary::
This annotation appears on types which are not a container and not level 1 immutable: at least one method will modify its parameters, and at least one field will be variable.

Mode:: It is the default in the green mode when none of {container}, {e1immutable}, {e1container}, {e2immutable}, {e2container} is present.
Use it for contracting in the red mode.

==== @NotModified

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation which indicates that no content modifications take place.

Mode:: It is the default in the red mode, when {modified} is not present.

==== @NotModified1

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: The {nm1} annotation is a dynamic type annotation which exists for functional interface types only.
It indicates that the single abstract method of the interface does not modify its arguments.

Mode:: It exists only in the green mode; there is no opposite.
It can only be used for contracting, the analyser cannot generate it.

This annotation is a dynamic type annotation on functional types in fields, methods and parameters.
The analyser can compute it in certain circumstances; in other cases, the user can show intent by requesting this property.

Note that because suppliers have no parameters, only modifications to the closure apply.
Functional interfaces are always normally {nm}: there are no modifying methods on them apart from the abstract method.

==== @NotNull

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation to indicate that a field, parameter, or result of a method can never be `null`.
Mode:: Use this annotation for contracting in the green mode.
It is the opposite of {nullable}.

==== @NotNull1

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @NotNull2

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @Nullable

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation indicates that the field, parameter, or result of a method can be `null`.

Mode:: This is the default in the green mode, when {nn} is not present.
Use it to contract in the red mode.

==== @Only

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

==== @Precondition

|===
| Basic {n} | Immu {n} | Contract {n}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: The analyser emits this annotation to describe any preconditions to a method, i.e., boolean expressions of the parameters or fields which cause an exception.
Mode:: This annotation cannot be used for contracting.

==== @Singleton

|===
| Basic {y} | Immu {n}| Contract {n} | Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that the class is a singleton: only one instance can exist.
Mode:: There is no opposite for this annotation.

==== @Size

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: The annotation indicates that the type, typically a container, has a `size` method which gives an indication of the amount of elements it holds.
It can be used to request minimal size, and to indicate that resulting objects have the same size as incoming objects.
Mode:: There is no opposite for this annotation.

Details:: A type becomes _sizable_ when it has at least one non-modifying method returning an `int`, or a `long`, annotated with `@Size`.
It is this method that will return the size of the type.
In practice, we're looking at the `size()` method of the collection classes:

[source,java]
----
@Size
int size();
----

Non-modifying methods that return a boolean can have their value explained:

[source,java]
----
@Size(equals = 0) // or @Size, given that equals=0 is the default
boolean isEmpty();

@Size(min = 1)
boolean isNotEmpty();
----

Non-modifying methods that return a sizable object can have their value explained as well:

[source,java]
----
@Size(equals = 2)
Set<Integer> returnSetOf2(int i1, int i2) { return Set.of(i1, i2); }
----

In modifying methods, the annotation describes how the size of the object in scope changes:

[source,java]
----
@Size(equals = 0)
void clear(); // empties the collection

@Size(min = 1)
boolean add(T t); // after adding, there will be at least one element in the collection
----

As a second option in modifying methods, we can transfer the size restriction of a parameter to the object itself:

[source,java]
----
boolean addAll(@Size(copyMin = true) Collection<? extends E> collection);
----

This indicates that after a call to `addAll`, the minimum size of the object combines with the current minimum.
In other words, if the size of the argument is `size >= 2`, then the current object will also have `size >= 2` assuming it started with a `size >= i` with `0 \<= i \<= 2`.
The analyser allows only one `copyMin` or `copyEquals` annotation per (modifying) method.
If a modifying method has a `copyMin` or `copyEquals` annotation on a parameter, then the potential `@Size` annotation on the method will be interpreted as size information on the return value.

A parameter annotated with `@Size(min = n)` or `@Size(equals = n)` sets a size requirement, regardless the type of method:

[source,java]
----
@Identity
static <T> Collection<T> requireNotEmpty(@Size(min = 1) Collection<T> ts) {
    if(ts.isEmpty()) throw new UnsupportedOperationException();
    return ts;
}
----

The analyser can infer `@Size` annotations on fields and return values of non-modifying methods.
It can also infer `@Size` restriction on parameters (like the one in the above example).
The analyser switches from 'restriction mode' into 'size computation mode' as soon as one modifying method has been applied to the sizable object.

==== @SupportData

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: This annotation is present to highlight fields which need to satisfy rules 2 and 3 of level 2 immutability.
Mode:: There is no opposite for this annotation.
The analyser generally computes it, but the user can override these decisions in contract mode, using `AnnotationType.CONTRACT` to enforce presence and `AnnotationType.CONTRACT_ABSENT`
to enforce absence.

Details:: The analyser marks a field as {supportData} only when

. the type declaring the field is {e1immutable}, and
. the field classifies as support data, and
. it is {nm}, and
. at least one of {e2immutable}'s rule 2 and rule 3 is not satisfied in relation to this field.

==== @UtilityClass

|===
| Basic {y} | Immu {n}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that the type is a utility class: it is eventually level 2 immutable, it cannot be instantiated, and only has static methods.
Mode:: There is no opposite for this annotation.
Details::
The level 2 immutability ensures that the (static) fields are sufficiently immutable.
The fact that it cannot be instantiated is verified by

. the fact that all constructors should be private;
. there should be at least one private constructor;
. no method or field can use the constructors instantiate objects of this type.

==== @Variable

|===
| Basic {y} | Immu {y}| Contract {n} | Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that a field is not effectively or eventually final, i.e., it is assigned to in methods accessible from non-private non-constructor methods in the type.
Mode:: Use this annotation when contracting in the red mode.
It is the opposite of {final}.
Example:: Please refer to the example of <<final-annotation>>.