=== List of annotations

For each of the annotations, we answer a couple of standard questions:

Basic:: is this an annotation you definitely should understand?
Immu:: is this annotation part of the immutability concept of the analyzer?
Contract:: will you manually insert this annotation often in interfaces?
Type:: does the annotation occur on types?
Field:: does the annotation occur on (static) fields?
Method:: does the annotation occur on methods and constructors?
Parameter:: does the annotation occur on parameters?

This classification helps to see the wood for the trees in the long list.
We explain the green and red mode in #TODO#.

==== @BeforeMark

|===
| Basic {n} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @Constant

|===
| Basic {n} | Immu {n}| Contract {n}| Type {n} | Field {y} | Method {y} | Param {n}
|===

Summary:: The analyser emits this annotation when a field has a constant final value, or a method returns a constant value.
Its primary purpose is to help debug the analyser.
Mode:: This annotation has no opposite.

==== @Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {n} | Method {n} | Param {n}
|===

==== @Dependent

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: Annotation used to indicate that the type's fields link to the method's parameter or return value, or the constructor's parameters.
This annotation is only present when there are support data fields.
Additionally, on methods, the analyser only computes the annotation when the method is {nm}.

Mode:: Use this annotation in the red mode.
Its opposite is {independent}.

==== @E1Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

==== @E1Immutable

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

==== @E2Container

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

==== @E2Immutable

|===
| Basic {y} | Immu {y}| Contract {y}| Type {y} | Field {y} | Method {y} | Param {y}
|===

==== @Exposed

|===
| Basic {n} | Immu {y} | Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @ExtensionClass

|===
| Basic {y} | Immu {n}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

==== @Final

|===
| Basic {y} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {n} | Param {n}
|===

==== @Fluent

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

==== @Identity

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Note that {identity} has an effect on linking of variables: a method marked {identity} only links to the first parameter.

==== @IgnoreModifications

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {n} | Param {n}
|===

==== @Independent

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: Annotation used to indicate that a method or constructor avoids linking the fields of the type to the return value and parameters.
This annotation is only present when there are support data fields.
Additionally, on methods, the analyser only computes the annotation when the method is {nm}.

Mode:: Use this annotation in the green mode.
Its opposite is {dependent}.

==== @Linked

|===
| Basic {n} | Immu {y}| Contract {n}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: Annotation to help debug the dependence system.
Mode:: There is no opposite.

==== @Mark

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

==== @Modified

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation which indicates that content modifications take place.
Mode:: It is the default in the green mode, when {nm} is not present.

==== @MutableModifiesArguments

|===
| Basic {y} | Immu {y}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary::
This annotation appears on types which are not a container and not level 1 immutable: at least one method will modify its parameters, and at least one field will be variable.

Mode:: It is the default in the green mode when none of {container}, {e1immutable}, {e1container}, {e2immutable}, {e2container} is present.
Use it for contracting in the red mode.

==== @NotModified

|===
| Basic {y} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation which indicates that no content modifications take place.

Mode:: It is the default in the red mode, when {modified} is not present.

==== @NotModified1

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: The {nm1} annotation is a dynamic type annotation which exists for functional interface types only.
It indicates that the single abstract method of the interface does not modify its arguments.

Mode:: It exists only in the green mode; there is no opposite.

This annotation is a dynamic type annotation on functional types in fields, methods and parameters.
The analyser can compute it in certain circumstances; in other cases, the user can show intent by requesting this property.

Note that because suppliers have no parameters, only modifications to the closure apply.
Functional interfaces are always normally {nm}: there are no modifying methods on them apart from the abstract method.

==== @NotNull

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: Core annotation to indicate that a field, parameter, or result of a method can never be `null`.
Mode:: Use this annotation for contracting in the green mode.
It is the opposite of {nullable}.

==== @NotNull1

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @NotNull2

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

==== @Nullable

|===
| Basic {y} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: This annotation indicates that the field, parameter, or result of a method can be `null`.

Mode:: This is the default in the green mode, when {nn} is not present.
Use it to contract in the red mode.

==== @Only

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {n} | Method {y} | Param {n}
|===

==== @Precondition

|===
| Basic {n} | Immu {n} | Contract {n}| Type {n} | Field {n} | Method {y} | Param {n}
|===

Summary:: The analyser emits this annotation to describe any preconditions to a method, i.e., boolean expressions of the parameters or fields which cause an exception.
Mode:: This annotation cannot be used for contracting.

==== @Singleton

|===
| Basic {y} | Immu {n}| Contract {n} | Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that the class is a singleton: only one instance can exist.
Mode:: There is no opposite for this annotation.

==== @Size

|===
| Basic {n} | Immu {n}| Contract {y}| Type {n} | Field {y} | Method {y} | Param {y}
|===

Summary:: The annotation indicates that the type, typically a container, has a `size` method which gives an indication of the amount of elements it holds.
It can be used to request minimal size, and to indicate that resulting objects have the same size as incoming objects.
Mode:: There is no opposite for this annotation.

==== @SupportData

|===
| Basic {n} | Immu {y}| Contract {y}| Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: This annotation is present to highlight fields which need to satisfy rules 2 and 3 of level 2 immutability.
Mode:: There is no opposite for this annotation.
The analyser generally computes it, but the user can override these decisions in contract mode, using `AnnotationType.CONTRACT` to enforce presence and `AnnotationType.CONTRACT_ABSENT`
to enforce absence.

Details:: The analyser marks a field as {supportData} only when

. the type declaring the field is {e1immutable}, and
. the field classifies as support data, and
. it is {nm}, and
. at least one of {e2immutable}'s rule 2 and rule 3 is not satisfied in relation to this field.

==== @UtilityClass

|===
| Basic {y} | Immu {n}| Contract {n}| Type {y} | Field {n} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that the type is a utility class: it is eventually level 2 immutable, it cannot be instantiated, and only has static methods.
Mode:: There is no opposite for this annotation.
Details::
The level 2 immutability ensures that the (static) fields are sufficiently immutable.
The fact that it cannot be instantiated is verified by

. the fact that all constructors should be private;
. there should be at least one private constructor;
. no method or field can use the constructors instantiate objects of this type.

==== @Variable

|===
| Basic {y} | Immu {y}| Contract {n} | Type {n} | Field {y} | Method {n} | Param {n}
|===

Summary:: This annotation indicates that a field is not effectively or eventually final, i.e., it is assigned to in methods accessible from non-private non-constructor methods in the type.
Mode:: Use this annotation when contracting in the red mode.
It is the opposite of {final}.