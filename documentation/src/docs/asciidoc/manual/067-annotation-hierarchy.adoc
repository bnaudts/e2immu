[#annotation-hierarchy]
=== Annotation hierarchy

The purpose of "opposite" annotations is to be able to work in a "mode" that suits the code:

Green mode:: in the green mode, the default is mutable, and immutable is special.

Red mode:: in the red mode, the default is immutable, and any form of mutability has to be marked.

This can save a lot of time when marking libraries.

Because the analyser also deals with nullability and a whole host of other annotations, the user can create custom modes.

We aim to restrict the amount of annotations per object as much as possible.
However, the analyser will emit at least one annotation per declaration, so that the highlighter can color properly.

==== On types

Implications and equivalences:

* {e2container} is equivalent to {e2immutable} {container}.
* {e2immutable} implies {e1immutable}
* {e1container} is equivalent to {e1immutable} {container}

Opposites:

* a type is either {e1immutable} (green), {container} (green) or {mutableModifiesArguments} (red)

When a type is {mutableModifiesArguments}, there will be {variable} fields and {modified} parameters.
Types without fields are {e2immutable} by definition.

==== On fields

Implications:

* {nm} implies {final}
* {variable} implies {modified}
* {supportData} implies {nm} (but failing rules 2 and 3 of {e2immutable})

Note that {variable} fields can be {nn}!
This obviously requires a not-null initialiser to be present; all other assignments must be not-null as well.
The opposite, a {final} field that is {nullable}, is not that useful.
It seems difficult to forbid, though, so we do not issue a formal implication.

Opposites:

* a field is either {final} (green) or {variable} (red)
* a field is either {nm} or (green) {modified} (red)
* a field is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

From types, following the definitions, we obtain:

* if a type is {e2immutable} (green), all its fields are {nm} (green)
* if a type is {e1immutable} (green), all its fields are {final} (green)
* if a type is {mutableModifiesArguments} (red), at least one of its field is {variable} (red)

==== On constructors

Non-trivial constructors have the {modified} property.
When there is support data, a constructor is either {independent} (green) or {dependent} (red).
A constructor without annotations therefore implies either that the type is not {e1immutable}, or that the constructor is not assigning to support data fields.

==== On methods

Opposites:

* a method is either {nm} (green) or {modified} (red)
* a method is either {independent} (green) or {dependent} (red).
This property is only relevant when there is support data, and the method is {nm}
* a method is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

Furthermore,

* if a type is {e2immutable} (green), all its methods are {nm} (green).

==== On parameters

Opposites:

* a parameter is either {nm} (green) or {modified} (red)
* a parameter is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

Furthermore,

* if a type is {container}, the parameters of all the methods and constructors are {nm} (green)
* if a type is {mutableModifiesArguments} (red), at least one of its field is {modified} (red)
* a parameter of primitive, unbound type parameter, or functional type, is always {nm} (green)

==== Nullability

By convention,

* {nn1} implies {nn}
* {nn2} implies {nn}, {nn1}
* etc.

This way of working makes most sense in an immutable setting.

==== Eventually and effectively immutable

Field types and method return types can be eventually or effectively immutable when their formal type is not level 1 or level 2 immutable, but the dynamic or computed type is.
In the latter case, static analysis shows that all assignments to the field, or all return statements, result in an immutable object.
In the former case, object flow computation proves that the mark has been passed for this object to have become immutable.

When a type is level 1 or level 2 eventually immutable, and the object flow computation proves that all assignments or return statements yield an object which is in a state _before_ the mark, the analyser will emit {beforeMark}.

Fields take the annotation of the eventual state, with the qualification of `after="..."`:

[options=header]
|===
| property | not present | eventually | effectively
| finality of field | {variable} | `@Final(after="mark")` | {final}
| modification of field | {modified} | `@NotModified(after="mark")` | {nm}
|===
