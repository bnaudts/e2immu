[#annotation-hierarchy]
=== Annotation hierarchy

The purpose of "opposite" annotations is to be able to work in a "mode" that suits the code:

Green mode:: in the green mode, the default is mutable, and immutable is special.

Red mode:: in the red mode, the default is immutable, and any form of mutability has to be marked.

This can save a lot of time when marking libraries.

Because the analyser also deals with nullability and a whole host of other annotations, the user can create custom modes.

We aim to restrict the amount of annotations per object as much as possible.
However, the analyser will emit at least one annotation per declaration, so that the highlighter can color properly.
An exception to this rule are the implicit annotations, marked below.

The analyser takes the implications from type to field, method, and parameter, account when annotating by hand.

==== On types

Note that:

* {e2container} is a shorthand for the combination of {e2immutable} and {container};
* {e1container} is a shorthand for the combination of {e1immutable} and {container};
* {e2immutable} requires {e1immutable};
* a type is {mutableModifiesArguments} (red) if and only if it is not {e1immutable} (green) and not {container} (green);
* when a type is {mutableModifiesArguments}, there will be at least one field marked {variable}, and at least one parameter marked {modified};
* by definition, types without fields are {e2immutable};
* all primitive types are implicitly {e2container}; the analyser will not mark them.

==== On fields

The definitions imply the following dependencies between annotations on fields:

* {nm} requires {final}, so the combination of {nm} and {variable} is not possible;
* {supportData} requires {nm} in a type that is {e1immutable}; it fails rules 2 and 3 of {e2immutable}.

Note that {variable} fields can be {nn}!
This obviously requires a not-null initialiser to be present; all other assignments must be not-null as well.
The opposite, a {final} field that is {nullable}, is not that useful.
It seems difficult to forbid, though, so we do not issue a formal implication.

Opposites:

* a field is either {final} (green) or {variable} (red)
* a field is either {nm} or (green) {modified} (red)
* a field is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

From types, following the definitions, we obtain:

* if a type is effectively {e2immutable} (green), all its fields are {nm} (green);
* if a type is effectively {e1immutable} (green), all its fields are {final} (green);
* if a type is {mutableModifiesArguments} (red), at least one of its field is {variable} (red).

Note that:

* fields of a primitive type are always {nn}, but this is not marked.
* as soon as fields of a primitive type are {final}, they are {nm}.
We mark them {final}.

==== On constructors

Non-trivial constructors have the {modified} property.
When there is support data, a constructor is either {independent} (green) or {dependent} (red).
A constructor without annotations therefore implies either that the type is not {e1immutable}, or that the constructor is not assigning to support data fields.

==== On methods

Opposites:

* a method is either {nm} (green) or {modified} (red)
* a method is either {independent} (green) or {dependent} (red).
This property is only relevant when there is support data, and the method is {nm}
* a method is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

Furthermore,

* if a type is effectively {e2immutable} (green), all its methods are {nm} (green).

Note that:

* quite trivially, `void` methods have no annotations relating to a return element
* methods returning a primitive type are {nn}, but this is not marked

==== On parameters

Opposites:

* a parameter is either {nm} (green) or {modified} (red)
* a parameter is either {nn} (or {nn1}, or {nn2}) (green), or {nullable} (red)

Implications:

* if a type is {container}, the parameters of all the methods and constructors are {nm} (green);
* a parameter of primitive type, unbound parameter type, functional type, or {e2immutable} type, is always {nm} (green);

Note that:

* if a type is {mutableModifiesArguments} (red), at least one of its parameters is {modified} (red), which will be marked;
* quite trivially, parameters of a primitive type are always {nn}  and {nm}, but we will not mark parameters of a primitive type.

==== Nullability

By convention,

* {nn1} implies {nn}
* {nn2} implies {nn}, {nn1}
* etc.

This way of working makes most sense in an immutable setting.

==== Eventually and effectively immutable

Field types and method return types can be eventually or effectively immutable when their formal type is not level 1 or level 2 immutable, but the dynamic or computed type is.
In the latter case, static analysis shows that all assignments to the field, or all return statements, result in an immutable object.
In the former case, object flow computation proves that the mark has been passed for this object to have become immutable.

When a type is level 1 or level 2 eventually immutable, and the object flow computation proves that all assignments or return statements yield an object which is in a state _before_ the mark, the analyser will emit {beforeMark}.

Fields take the annotation of the eventual state, with the qualification of `after="..."`:

[options=header]
|===
| property | not present | eventually | effectively
| finality of field | {variable} | `@Final(after="mark")` | {final}
| modification of field | {modified} | `@NotModified(after="mark")` | {nm}
|===
