=== Statement analysis

There is one `StatementAnalysis` object per statement, so a method consists of a chain of statements.

=== Variables

Types of variables:

* fields, in 4 flavours: effectively final, variable, undecided in the first iteration(s), and acting as local variables in synchronized blocks
* parameters, non-assignable
* local variables
* `this`, `super`
* dependent variables, like the cells in an array

For each variable, we store its value, a map of properties, and an object flow.

Eventual destinations of properties, values, object flows:

|===
| fields | `FieldAnalysis`
| parameters | `ParameterAnalysis`
| `this`, `super` | `TypeAnalysis`
| return value of method | `MethodAnalysis`, `singleValue`
|===

During statement analysis, the maps in `StatementAnalysis` hold values and properties for all types of variables.
These maps are incremental: once the analyser writes a value, it cannot remove the key anymore; it can only increase this value.


==== Variable fields

Variable fields interact with synchronisation.
A time increase is equivalent to an opportunity for another thread to update the content of variable fields.

The analyser can determine if a method increases time when called.
Calls to non-private methods always increase time because the user can override them.
Certain statements increase time (`try-catch`, `synchronized`).
The method resolver determines if a method increases time or not.

The statement analyser keeps track of time.
Determining time obviously depends on the methods being called, but because the method resolver determines if a method increases time, this happens in a deterministic way in the first iteration of the analyser.

==== Different levels

Because of the write-once policy, we require five different levels to write information about a variable.

Level 0:: a level containing a direct link to the latest information of the previous or parent statement.
This link tries to save memory when a variable is not touched in the current statement.

Level 1:: the level of the creation of local variables and return variables.
A field which is read for the first time is introduced at this level.

Level 2:: the level of creation of loop variables local to the statement and its block.

Level 3:: the level of the primary expression of the statement.
It includes assignments, which store the new value.

Level 4:: the level of synthesis of the sub-blocks.

Information is always copied up the levels, never down.

==== Data stored for a variable

The `VariableInfo` objects hold the following data:

Variable:: the variable being stored.
Always present from the start.
Assignment ID:: A marker for when this particular `VariableInfo` object is created.
It contains the statement index, and the level in the container, separated by a colon.
This value is present from the creation of the `VariableInfo` object, even though it can vary across `VariableInfo` objects for the same variable.
Value:: starts off with `NO_VALUE` (not assigned), and becomes immutable when it receives a value.
Linked variables:: start off with `null`, and becomes immutable when it receives a value.
Bar one exception, the linked variables come with the assignment of a value, potentially in a later iteration.
The linked variables of a variable field change when the analyser creates a new local copy for reading, i.e., outside an assignment.
Properties:: a properties map, with `Level.DELAY` being the default value.
Statement time:: a constant `NOT_A_VARIABLE_FIELD` for all non-variable fields.
For fields, starts off with `VARIABLE_FIELD_DELAYED` (not assigned) until we know if the field is variable or not.
Then, for variable fields, it stores the statement time of the latest assignment.
Object flow:: generally also set during an assignment.
The value `NO_FLOW` is used when no value as been set.

All these fields are immutable once they have been set, except the `properties` map, which is incremental.
The `READ` and `ASSIGNED` properties have the following special behaviour: ... #TODO#

==== Tests: Basics_0

[source,java]
----
private final String effectivelyFinal = "abc";
public String getEffectivelyFinal() {
    return effectivelyFinal;
}
----

Analysers:

* Statement analyser, iteration 0, statement 0, return statement.
The field `effectivelyFinal` does not yet exist in the list of variables; the change data yields a `FieldReference` pointing to a value of `NO_VALUE`, and a marker that the variable is read in this statement.

* Method analyser: #TODO#

* Field analyser, iteration 0: it is immediately clear that the field is explicitly final, and that the initialiser is level 2 immutable.
Therefore, an effectively final value can be assigned: `"abc"`.
Everything can be concluded.

* Statement analyser, iteration 1: at initialisation, the variable is created, and the effectively final value is filled.
The main evaluation can therefore return a value.
The return variable can also be set.

* Method analyser: can conclude all except for the approved pre-conditions, which will remain unresolved?

==== Tests: Basics_1

[source,java]
----
public final Set<String> f1;

public Basics_1(Set<String> p0, Set<String> p1, String p2) {
    Set<String> s1 = p0;
    this.f1 = s1;
}

public Set<String> getF1() { return f1; }
----

Iteration 0, statement analyser for the constructor:

* statement 0: at initialisation, `this` and the three parameters are created as variables, in the `INITIAL` phase.
The local variable `s1` is created, and assigned to the first parameter.
Both exist in `EVAL` phase, one with an assignment id, the other with a read id.
* statement 1: a field reference is created, and assigned the value `p0`.
The field is linked to this parameter.

Iteration 0, statement analyser for the getter:
* statement 0: the field does not yet exist in the list of variables.
It is marked as read during evaluation, and will be created during the initialisation step of the next iteration.
The return variable has been created at initialisation, but for now has no value.

Iteration 0, field analyser:

* the field is marked as effectively final.
* because there is no /


Iteration 1, statement analyser for getter:
* the field `f1` has the value `instance type Set<String>`, not linked locally.
* the return variable points to the field `f1`.

IMPORTANT:: We could also return the value of `f1` in the return statement, but at the moment we don't think it matters that much.

Iteration 1, field analyser:
Modification is determined, as is nullability.

Iteration 2: parameter analyser: the `@NotNull` of the field travels to the parameter.

