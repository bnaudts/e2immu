=== Statement analysis

There is one `StatementAnalysis` object per statement, so a method consists of a chain of statements.

=== Variables

Types of variables:

* fields, in 4 flavours: effectively final, variable, undecided in the first iteration(s), and acting as local variables in synchronized blocks
* parameters, non-assignable
* local variables
* `this`, `super`
* dependent variables, like the cells in an array

For each variable, we store its value, a map of properties, and an object flow.

Eventual destinations of properties, values, object flows:

|===
| fields | `FieldAnalysis`
| parameters | `ParameterAnalysis`
| `this`, `super` | `TypeAnalysis`
| return value of method | `MethodAnalysis`, `singleValue`
|===

During statement analysis, the maps in `StatementAnalysis` hold values and properties for all types of variables.
These maps are incremental: once the analyser writes a value, it cannot remove the key anymore; it can only increase this value.


==== Variable fields

Variable fields interact with synchronisation.
A time increase is equivalent to an opportunity for another thread to update the content of variable fields.

The analyser can determine if a method increases time when called.
Calls to non-private methods always increase time because the user can override them.
Certain statements increase time (`try-catch`, `synchronized`).
The method resolver determines if a method increases time or not.

The statement analyser keeps track of time.
Determining time obviously depends on the methods being called, but because the method resolver determines if a method increases time, this happens in a deterministic way in the first iteration of the analyser.

==== Different levels

Because of the write-once policy, we require five different levels to write information about a variable.

Level 0:: a level containing a direct link to the latest information of the previous or parent statement.
This link tries to save memory when a variable is not touched in the current statement.

Level 1:: the level of the creation of local variables and return variables.
A field which is read for the first time is introduced at this level.

Level 2:: the level of creation of loop variables local to the statement and its block.

Level 3:: the level of the primary expression of the statement.
It includes assignments, which store the new value.

Level 4:: the level of synthesis of the sub-blocks.

Information is always copied up the levels, never down.

==== Data stored for a variable

The `VariableInfo` objects hold the following data:

Variable:: the variable being stored.
Always present from the start.
Assignment ID:: A marker for when this particular `VariableInfo` object is created.
It contains the statement index, and the level in the container, separated by a colon.
This value is present from the creation of the `VariableInfo` object, even though it can vary across `VariableInfo` objects for the same variable.
Value:: starts off with `NO_VALUE` (not assigned), and becomes immutable when it receives a value.
Linked variables:: start off with `null`, and becomes immutable when it receives a value.
Bar one exception, the linked variables come with the assignment of a value, potentially in a later iteration.
The linked variables of a variable field change when the analyser creates a new local copy for reading, i.e., outside an assignment.
Properties:: a properties map, with `Level.DELAY` being the default value.
Statement time:: a constant `NOT_A_VARIABLE_FIELD` for all non-variable fields.
For fields, starts off with `VARIABLE_FIELD_DELAYED` (not assigned) until we know if the field is variable or not.
Then, for variable fields, it stores the statement time of the latest assignment.
Object flow:: generally also set during an assignment.
The value `NO_FLOW` is used when no value as been set.

All these fields are immutable once they have been set, except the `properties` map, which is incremental.
The `READ` and `ASSIGNED` properties have the following special behaviour: ... #TODO#
