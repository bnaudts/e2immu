== The analyser

=== Inspection

=== Analysis

==== Code structure

`PrimaryTypeAnalyser`:

* starts from a `SortedType`, which contains one `PrimaryType` and a list of `WithInspectionAndAnalysis` (methods, fields, sub-types)
* creates and calls `TypeAnalyser`, `MethodAnalyser`, `FieldAnalyser`, and assigns `TypeAnalysis`, `MethodAnalysis`, `FieldAnalysis`
to `TypeInfo.typeAnalysis`, `MethodInfo.methodAnalysis`, `FieldInfo.fieldAnalysis`.

* the `TypeAnalyser` creates, fills, and returns the `TypeAnalysis` object
* the `FieldAnalyser` creates, fills, and returns the `FieldAnalysis` object
* the `MethodAnalyser` creates, fills, and returns the `MethodAnalysis` object, but it also creates:

** `ParameterAnalyser` objects, which fill, create and return `ParameterAnalysis` objects
** `BlockAnalyser` objects, which fill, create and return `StatementAnalysis` objects.
Each `StatementAnalysis` object corresponds recursively to a `Statement` in the `methodBody` block.


`TypeResolution` contains:

* the list of circular dependencies
* the set of implicitly immutable data types for this type

The `TypeAnalysis` object holds:


* a map of constant object flows
* a map of approved preconditions, ready for {mark} and {only}
* annotations and properties via the parent `Analysis` object

`FieldResolution` contains:

* a flag marking if the type is implicitly immutable


The `FieldAnalysis` object holds:

* the object flow of the field
* an effectively final value, which is an instance of `FinalFieldValue` unless we know better; it is not set when the field is {variable}
* a list of variables linked to the field (other fields, parameters)
* a set of internal object flows
* an error map for marking illegal assignments
* an error flag
* annotations and properties via the parent `Analysis` object

`MethodResolution` contains:

* a set of methods of the same type that this method (transitively) calls
* a flag noting whether it is part of construction
* a flag whether it creates an object of itself
* a flag indicating that it only calls static methods


The `MethodAnalysis` object holds:

* a single return value, if available
* summary information about `This` (mostly modification, we can maybe reduce this to single boolean?)
* a list of `StatementAnalysis` objects holding return value information.
#NOTE# we can also store them in the method analyser, there may not be a need to hold on to them.
* a map of variables linked to fields and parameters
* a set of variables linked to the return value(s) of the method
* the joint precondition
* the precondition part for {mark} and {only}
* information about possible {mark} and {only} annotations (can maybe moved directly into the annotations)
* a set of internal object flows
* the object flow of the method
* a fair number of error flags


The `StatementAnalysis` object holds:

* information about the statement: `Statement` reference, parent, next, list of blocks, indices and index
* a flag indicating if the statement (or block represented by the initial statement of the block) ecapes
* a flag indicating that the next statement is never reached
* an error flag
* a precondition represented by this statement
* the state of the method after evaluating this statement
* the precondition of the method after evaluating this statement
* if the statement has an expression part, the value of the expression
* replacement information
* a flag indicating if the method flow reaches the statement
* all variables referenced so far, and their properties (fully incremental)
* dependency information so far

Evaluation of expressions requires an `EvaluationContext` object which moves from statement to statement, applying resulting changes into the `StatementAnalysis` object after each evaluation.
Some of these changes then trickle down to the method analyser which updates the `MethodAnalysis` object.

==== Circular dependencies

The analyser approaches primary types independently, albeit in a carefully computed order of dependency between them.
When it detects a circular dependency between two or more primary types, it issues a warning to indicate that a different, less powerful modification detection algorithm kicks in.
We consider circular dependencies bad programming practice; generally, interfaces can be introduced to remedy this.
The manual modification annotations on the interface method effectively substitute for the assumptions that the less powerful modification algorithm makes.

Inside a primary type, the analyser deals with circular dependencies between the sub-types, the methods and the fields by running multiple iterations.
The main reason it has to do this is that all fields are visible to all sub-types, even if they are marked `private`.

The processing list determines the order in which the analyser processes fields, methods and sub-types.

==== Nested classes

{final}: across all methods in the primary type

Parent or enclosing type when non-static must be have the property as well: {e1immutable}, {e2immutable}, {container}, {independent}.

What to do with abstract superclasses?
They cause a problem because of the abstract methods, which can have any modification status.
#TODO# think and implement.

Eventual?
#TODO# think and implement.

==== Modification of a field

The code executes the following steps:

. Wait until {final} or {variable} has been established.
If {variable}, then the field becomes {modified}.
. If the field is of a functional interface type, the field is {nm} unless we can establish that there is an initializer or unambiguous constructor assignment with an explicit declaration (method reference, lambda, anonymous class implementation).
. As a short-cut, determine that the field is {nm} if its type is level 2 immutable.
Whilst not technically necessary, this short-cut may resolve situations more quickly.
. Wait until the field summaries in methods have been set.
This typically takes exactly one iteration, because a method which reads a field is later in the processing list.
. Wait until modification information is available for those methods which read the field.
Importantly, we consider the methods (and SAM declarations of fields) of all types in the primary type.
. Determine modification based on the modification information in the field summaries.

==== Modification of a method

The code executes the following steps:

. If the method's field summaries contains an assignment to any field, inside the primary type, then the method is {modified}.
. Wait until linking information (and hence modification information on fields) becomes available.
. If any of the field summaries contains a marker for a modified field, then the method becomes {modified}.
The analyser provides these marks when, amongst others, it sees a modifying method call on the field, or the field is an argument to a modifying parameter.
. Next, check the modification status of `this` in `thisSummary`, when the analyser has observed a local method call.
The method is {modified} when the analyser has observed a modification to any of the `this` objects (`super`, ...).
. Then, check the marker for circular method calls or undeclared functional interfaces.
In this situation, the modification status of the method depends on the presence of other modifying methods, non-private fields, on dependent methods.
. Finally, check the marker to copy the modification status from another method.
The analyser issues this marker when the method passes on a functional interface argument to the other method.

==== Condition and state

A method can have restrictions on the parameter and field values called _preconditions_.
In general, these restrictions end up as a boolean expression in `MethodAnalysis.precondition`.
The exception to this rule are the not-null and size restrictions on parameters, which become properties during evaluation, and are written out as separate annotations.

Preconditions that participate in {mark} and {only} are stored in `MethodAnalysis.preconditionForMarkAndOnly`.
They are computed from normal preconditions.

As the analyser progresses through the blocks and statements, it keeps track of:

* the current _condition_, which is the boolean conjunction of all conditions in ever deeper `if` statements, (negated in the `else` block);
* the current _state_, which is the boolean conjunction of all restrictions on variables.

In the condition, top-level disjunctions indicate independent statements, while in the state, top-level conjunctions indicate independent statements:

[source,java]
----
void method1(String a, String b) {
    if(a == null || b == null) {
        // condition and state are: a == null || b == null;
        throw new NullPointerException();
    }
    // state is: a != null && b != null; empty condition
    ...
}
----

In Java, because of short-circuiting, this is functionally identical to the 'independent' form:

[source,java]
----
void method2(String a, String b) {
    if(a == null) {
        // condition and state are: a == null
        throw new NullPointerException();
    }
    // state is: a != null; empty condition
    if(b == null) {
        // condition is: b == null; state is: a != null && b == null
        throw new NullPointerException();
    }
    // state is: a != null && b != null; empty condition
    ...
}
----

Condition and state travel deeper inside the blocks:

[source,java]
----
void method3(String a, String b) {
    if(a == null) {
        // condition and state are: a == null
        if(b == null) {
            // condition and state are: a == null && b == null
            throw new UnsupportedOperationException();
        }
        // condition is: a == null; state is: a == null && b != null
        return;
    }
    // state is: a != null; empty condition
    ...
}
----

Both in `method1` and `method2`, the escape via a runtime exception introduces {nn} annotations on the parameters.
The analyser employs dedicated logic to ensure that in a second pass, it does not flag the condition in the `if` statement as a constant value.
In `method3`, the conjunction in the condition after two successive `if` statements does not allow for individual not-null restrictions.
The result is a precondition, annotated as `@Precondition("(not (null == a) or not (null == b))")`.
Note that, perhaps counter-intuitively, if we were to replace the `return` statement with a `throws` statement, it would have `a == null` as condition, and not `a == null && b != null`.

The rules for adding and removing to condition and state are:

. start the method with the state equal to the preconditions, if applicable;
. when entering a conditional block, start a new `ConditionManager` with the statement's expression added to the current condition and state;
. when a conditional block does not return, add the boolean complement to the state;
. in case of assignments or modifying methods, clear the state (partially);
. the state of parameters and effectively final fields travels up from inside blocks, but only if these blocks are unconditional.
This is most notably the case for a `synchronized` block.

==== Computation of @Mark, @Only

The presence of eventual properties (level 1 immutable, level 2 immutable, content not null, ...) follows from the computation of the {only} and {mark} annotations.
Here, we document how the analyser computes them.

The analyser associates eventuality with a precondition on a field (or technically, on one or more fields); it labels the precondition with a mark string.
Methods that guard against the precondition are _before_ the mark, methods that guard against the boolean complement are _after_ the mark.
We define a guard here as the throwing of a run-time exception when the field's value does not satisfy the condition.

Each method holds information about such a precondition in `SetOnce<MarkAndOnly> markAndOnly`.
The `MethodAnalyser` computes the information in `computeOnlyMarkPrepWork` and `computeOnlyMarkAnnotate`.

Then, the `TypeAnalyser` combines the information of the methods in `analyseOnlyMarkEventuallyE1Immutable`; the end result of the whole computation resides in `SetOnceMap<String, Value> approvedPreconditions` in `TypeAnalysis`.
The keys are the different preconditions that have been approved for eventuality computation, the values are the associated mark strings consisting of the variable names of the fields in the precondition.
Note: the current implementation relies on the precondition to be lifted using an assignment rather than a content change; the code resides in the level 1 immutability check.
As a consequence, it is currently not possible to use the size of a collection, for example, as a precondition.

The eventual annotation will receive a comma-separated list with all the marks in `approvedPreconditions`.

==== Statement analyser

Steps:

. Create local variable (`for(T t: ts)`, assignment statement)
. evaluate initialisers (classic `for`, `try` with resources, normal assignment statements).
The results of the initialisers need to be known to the evaluation context, but cannot be permanent yet.
. evaluate updates (classic `for`).
The results of the updaters need to be known to the evaluation context, but cannot be permanent yet.
. evaluate main expression (many statements).
The results need to be known to the evaluation context.
. specific `return` statement code, update method-level data;
. specific `if`, `switch` code to check evaluations to constant
. primary block, recursive call; merge back by calling `lift`
. sub-blocks, recursive calls; merge back by calling `lift`
. determine state after this statement
. finally, make the results of the evaluation(s) permanent by calling `finalise`

==== Computation of @Size

The type analyser holds `fieldHoldingSize`, and a link to the variables that determine the size: `sizeCopyVariables`.
It computes the former by looking at the return value of the <<size-annotation>> marker method.
It determines the latter by going over the constructors collecting `sizeVariables` linked to the `fieldHoldingSize`.

The statement analyser holds multiple properties for each variable:

. `SIZE`, which holds the current size of a @Size-able object;
. `SIZE_RESTRICTION`, which will end up on a parameter
. `SIZE_OUT`, which also ends up on a parameter
. `SIZE_COPY`, determined by the fact that the parameter ends up in the type's `variablesDeterminingSizeCopy`.

The field analyser holds `SIZE` but is not concerned with size restrictions or output-size.

The method analyser sets `SIZE_COPY`  when the single return value has non-empty `sizeCopyVariables`, copied from the `VariableInfo` object.
It sets `SIZE` from the `SIZE` property of the single return value.

