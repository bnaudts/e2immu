== The analyser

=== Inspection

=== Analysis

==== Circular dependencies

The analyser approaches primary types independently, albeit in a carefully computed order of dependency between them.
When it detects a circular dependency between two or more primary types, it issues a warning to indicate that a different, less powerful modification detection algorithm kicks in.
We consider circular dependencies bad programming practice; generally, interfaces can be introduced to remedy this.
The manual modification annotations on the interface method effectively substitute for the assumptions that the less powerful modification algorithm makes.

Inside a primary type, the analyser deals with circular dependencies between the sub-types, the methods and the fields by running multiple iterations.
The main reason it has to do this is that all fields are visible to all sub-types, even if they are marked `private`.

The processing list determines the order in which the analyser processes fields, methods and sub-types.

==== Modification of a field

The code executes the following steps:

. Wait until {final} or {variable} has been established.
If {variable}, then the field becomes {modified}.
. If the field is of a functional interface type, the field is {nm} unless we can establish that there is an initializer or unambiguous constructor assignment with an explicit declaration (method reference, lambda, anonymous class implementation).
. As a short-cut, determine that the field is {nm} if its type is level 2 immutable.
Whilst not technically necessary, this short-cut may resolve situations more quickly.
. Wait until the field summaries in methods have been set.
This typically takes exactly one iteration, because a method which reads a field is later in the processing list.
. Wait until modification information is available for those methods which read the field.
Importantly, we consider the methods (and SAM declarations of fields) of all types in the primary type.
. Determine modification based on the modification information in the field summaries.

==== Modification of a method

The code executes the following steps:

. If the method's field summaries contains an assignment to any field, inside the primary type, then the method is {modified}.
. Wait until linking information (and hence modification information on fields) becomes available.
. If any of the field summaries contains a marker for a modified field, then the method becomes {modified}.
The analyser provides these marks when, amongst others, it sees a modifying method call on the field, or the field is an argument to a modifying parameter.
. Next, check the modification status of `this` in `thisSummary`, when the analyser has observed a local method call.
The method is {modified} when the analyser has observed a modification to any of the `this` objects (`super`, ...).
. Then, check the marker for circular method calls or undeclared functional interfaces.
In this situation, the modification status of the method depends on the presence of other modifying methods, non-private fields, on dependent methods.
. Finally, check the marker to copy the modification status from another method.
The analyser issues this marker when the method passes on a functional interface argument to the other method.

==== Condition and state

A method can have restrictions on the parameter and field values called _preconditions_.
In general, these restrictions end up as a boolean expression in `MethodAnalysis.precondition`.
The exception to this rule are the not-null and size restrictions on parameters, which become properties during evaluation, and are written out as separate annotations.

Preconditions that participate in {mark} and {only} are stored in `MethodAnalysis.preconditionForMarkAndOnly`.
They are computed from normal preconditions.

As the analyser progresses through the blocks and statements, it keeps track of:

* the current _condition_, which is the boolean conjunction of all conditions in ever deeper `if` statements, (negated in the `else` block);
* the current _state_, which is the boolean conjunction of all restrictions on variables.

In the condition, top-level disjunctions indicate independent statements, while in the state, top-level conjunctions indicate independent statements:

[source,java]
----
void method1(String a, String b) {
    if(a == null || b == null) {
        // condition and state are: a == null || b == null;
        throw new NullPointerException();
    }
    // state is: a != null && b != null; empty condition
    ...
}
----

In Java, because of short-circuiting, this is functionally identical to the 'independent' form:

[source,java]
----
void method2(String a, String b) {
    if(a == null) {
        // condition and state are: a == null
        throw new NullPointerException();
    }
    // state is: a != null; empty condition
    if(b == null) {
        // condition is: b == null; state is: a != null && b == null
        throw new NullPointerException();
    }
    // state is: a != null && b != null; empty condition
    ...
}
----

Condition and state travel deeper inside the blocks:

[source,java]
----
void method3(String a, String b) {
    if(a == null) {
        // condition and state are: a == null
        if(b == null) {
            // condition and state are: a == null && b == null
            throw new UnsupportedOperationException();
        }
        // condition is: a == null; state is: a == null && b != null
        return;
    }
    // state is: a != null; empty condition
    ...
}
----

Both in `method1` and `method2`, the escape via a runtime exception introduces {nn} annotations on the parameters.
The analyser employs dedicated logic to ensure that in a second pass, it does not flag the condition in the `if` statement as a constant value.
In `method3`, the conjunction in the condition after two successive `if` statements does not allow for individual not-null restrictions.
The result is a precondition, annotated as `@Precondition("(not (null == a) or not (null == b))")`.
Note that, perhaps counter-intuitively, if we were to replace the `return` statement with a `throws` statement, it would have `a == null` as condition, and not `a == null && b != null`.

The rules for adding and removing to condition and state are:

. start the method with the state equal to the preconditions, if applicable;
. when entering a conditional block, start a new `ConditionManager` with the statement's expression added to the current condition and state;
. when a conditional block does not return, add the boolean complement to the state;
. in case of assignments or modifying methods, clear the state (partially);
. the state of parameters and effectively final fields travels up from inside blocks, but only if these blocks are unconditional.
This is most notably the case for a `synchronized` block.

==== Computation of @Mark, @Only

The presence of eventual properties (level 1 immutable, level 2 immutable, content not null, ...) follows from the computation of the {only} and {mark} annotations.
Here, we document how the analyser computes them.

The analyser associates eventuality with a precondition on a field (or technically, on one or more fields); it labels the precondition with a mark string.
Methods that guard against the precondition are _before_ the mark, methods that guard against the boolean complement are _after_ the mark.
We define a guard here as the throwing of a run-time exception when the field's value does not satisfy the condition.

Each method holds information about such a precondition in `SetOnce<MarkAndOnly> markAndOnly`.
The `MethodAnalyser` computes the information in `computeOnlyMarkPrepWork` and `computeOnlyMarkAnnotate`.

Then, the `TypeAnalyser` combines the information of the methods in `analyseOnlyMarkEventuallyE1Immutable`; the end result of the whole computation resides in `SetOnceMap<String, Value> approvedPreconditions` in `TypeAnalysis`.
The keys are the different preconditions that have been approved for eventuality computation, the values are the associated mark strings consisting of the variable names of the fields in the precondition.
Note: the current implementation relies on the precondition to be lifted using an assignment rather than a content change; the code resides in the level 1 immutability check.
As a consequence, it is currently not possible to use the size of a collection, for example, as a precondition.

The eventual annotation will receive a comma-separated list with all the marks in `approvedPreconditions`.