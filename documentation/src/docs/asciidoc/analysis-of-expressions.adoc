
== Towards code standardisation

=== Analysis of expressions


Currently

*  read, read multiple times, to determine `@Final`, and to make substitutions possible in the case of single reads outside iterations. Allows us to move statements around to get local variable definitions as close as possible to where they are used.
*  compute whether an expression can return null or not (`notNullAnalysis`),
with goals of at least
   **   determine if a `return` statement is `@NotNull` or not
   **   determine if a variable assignment can have the `check not null` variable property
   **   issue warnings if such an expression is used in locations where null is not allowed (`if`, `for`, ...); the reverse is to enforce a `@NotNull` on a method if the expression is a method call
* inherit annotations
   **   `@NullNotAllowed` to a parameter or field when passing a variable as parameter to a method that has this annotation
   **   `@NotModified` helps to avoid a `content modified` property
*  deal with `if` statements and the ternary operator, for `check not null` variable properties = explicit null checks
*  implicit null check: using a parameter or field in a context where null will cause exceptions will imply a `@NullNotAllowed` on the parameter (and *TODO a @NotNull on the field*). The reverse is to issue a warning.

Is there anything else? Otherwise our current system which is not fully recursive, is sufficiently strong.

==== Logic analysis

Assign a value to a variable rather than the boolean null-not null; the primary goal here is *dead code analysis* (will never reach this statement, because this expression is always false). The good thing about logic analysis is that we can standardize (= make equivalent) different ways of exiting a method

[source]
----
if(expression) return true;
return false;
----
is obviously equivalent to `return expression`. Much more complicated situations can arise.

Logic analysis requires the evaluation of expressions if we already know values. It should also work with abstract values, e.g.

[source]
----
boolean c = !d;
----
Anywhere `c` is used, the value `!d` can be substituted. 


Implementation wise, the `notNullAnalysis` method returns four-way values: definitely not null, definitely not not null, undecided, and ignore (which **is not used**). 


==== Collections

In the context of collections, the following 4 notions are important

-  is empty (boolean)
-  size
-  contains (boolean)
-  method makes a change (the boolean returned on add)

To help standardization of expressions, 
```
if(c.contains(a)) X; else Y;
``` 
could be said to be in standard form.

On each method that returns a boolean, we could annotate, if it is a `@ContextFunction`, whether it is of the contains-type. If it has side effects, we can annotate if it is of the changes-type.
Or, we can assume this, and add a *reverse* annotation that indicates that the logic has been reversed.


==== `@Reverse` Rules on boolean methods

On boolean `@PureSupplier`: add `@Reverse` if the method returs `false`.

On boolean `@PureFunction`: best to have a good look and see if this 
pure function is not delegating to one of the arguments. If it is, the
semantics of the delegation method apply. Otherwise, this function does some logic computation. Try to follow the logic of the first argument.

On boolean `@ContextSupplier`: add `@Reverse` if the semantics are
opposite to that of `isNotEmpty`.

On boolean `@ContextFunction`: add `@Reverse` if the semantics are opposite to that of `contains`.

On boolean side effect methods: add `@Reverse` if the semantics are 
opposite to that of `changes`.

==== `@Size` annotation on `int` suppliers

Working with numbers in the context of collections, chances are that non-zero numbers are to do with the size of the collection. Knowing this is relevant because of alternative forms of iterations, which loop with counters; also, when dealing with arrays rather that collection objects.

==== Generic form

Consider

[source]
----
if(!c.contains(a)) { c.add(a); X }
----

which is too verbose, and should be replaced by 

[source]
----
if(c.add(a)) X;
----

in the context of a *set*.

In the context of a conditional method

[source]
----
boolean m1(C c, A a);
----

the situation

[source]
----
boolean m2(C c, A a) {
    if(m1(c, a)) {
        X;
        return true;
    }
    Y;
    return false;
}
if(m2(c, a)) Z; else T;
----

is the same as

[source]
----
if(m1(c, a)) {
    X; Z;
} else {
    Y; T;
}
----

These are examples of analysing equivalence beyond method boundaries.

==== Variable value

Map of `Variable` to `Value` can contain
-  variable value, as in: a = b
-  constants, as in a = 3
-  later: method value, as in a = c(d, e)
-  expression as in a = b - 1, a = b == null, ... The expression contains constants

Given that we know properties about variable value b (such as not null, not modified), it may be convenient to store them along the variable. 
On the other hand, evaluation is always done in the evaluation context, where we store these properties.