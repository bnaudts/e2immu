[#linking-discussions]
=== Linking discussions

In the expression `t = supplier.get()`, should `t` be linked to `supplier`?
Turning the question into this example, it seems obvious that the answer is _yes_:

[source]
----
private Set<String> set;

public void evaluateIfNeeded(Supplier<Set<String>> supplier) {
    if(set == null) {
        set = supplier.get();
    }
}
----

It is perfectly possible for the `supplier` to expose a set from the outside.

The same holds for consumers:

[source]
----
private Set<String> set;

public void expose(Consumer<Set<String>> consumer) {
    consumer.accept(set);
}
----

The `accept` method cannot be marked <<independent-annotation>>!

Look at the following situation.
Do we need to add an <<output-annotation>> annotation to the `generator` parameter?

[source]
----
@NotNull
@Independent
@NotModified
<T> T[] toArray(IntFunction<T[]> generator);
----

The API docs state that the method

> Returns an array containing all of the elements in this collection, using the provided generator function to > allocate the returned array.

In that light, the result is normally returned by the method, even though it is generated by the parameter.
For now I'd say _no_.

=== Competing definitions of a container

Definition 1:: A class becomes a container when the parameters of all non-private methods and constructors can be marked <<notmodified-annotation>>, or are of a type that is not content-modifiable (<<effectivelyimmutable-annotation>>, primitive).

Definition 2:: A class will be labelled <<container-annotation>>
if and only if all the fields linked to any parameter of a non-private method or constructor of the class, can be marked <<notmodified-annotation>>.

In the first definition, no non-private method may modify its parameters (unless it is explicitly marked an output parameter).
Either these parameters are linked to fields, or not.

If a field is linked to any such parameter, this field may not be content modified either, by any method in the class.
This is the case because otherwise, via linking, the parameter's content would be modified.

So definition 1 is stronger than definition 2, because it does not allow for content modifications on fields that are not linked to a field.
At the same time, definition 1 is more intuitive.

=== Startup procedure

Reiterating the order of importance of analysing types:

. source code; parsed by the analyser
. annotated sources; parsed by the analyser
. `annotation.xml` files in classpath, combined with `.class` files; parsed by our ASM7 `.class` parser on demand

On top of that, we need to add primitives and some bootstrapping types such as `AnnotationType` which is used `e2immu` annotations, which are themselves used on types in `java.lang`.

The analyser's parser is implemented in such a way that it needs to have inspected dependent types.
The methods can refer from one class inspected first to another class inspected later.
For that purpose, we have a resolution phase, and an `ExpressionWithMethodReferenceResolution`.
But we have currently no such mechanism for fields, which bugs us already in the case of AnnotationType.

However, as with inheritance and interfaces, the both parsers need to have seen the dependent type first.
The `.class` parser can do this recursively without problems.
The analyser can use the class parser to first make an ordering of the sources.

Summarizing, the flow of one run of the analyser is as follows:

. Ensure that the user's project has already been compiled: we have `.class` files available for every `.java` and every `.annotated_api`
file.
. Initialize primitives, their boxed versions, and `java.lang.String`, `java.lang.Object`.
Initialize `AnnotationType`, an enum used in all our annotations
. Set up a `ClassPath` so that the class parser can work in the background; we need jars with `.class` files (all dependencies) and as many `annotation.xml` files as needed, potentially packaged in separate jars.
. Using the class parser, all `.class` files corresponding to `.java` and `.annotated_api` files in the project are inspected, and a parsing order is determined.
Because of the on-demand nature of the class parser, quite a few library types (not in either groups) are inspected already; results go directly into the global type context.
. Using the analyser, all annotated API sources available on the classpath, are parsed.
The resulting types are kept in the global type context.
Types for which we have a `.java` source file (as seen in the parsing order), are ignored.
. Using the analyser, finally all sources are parsed in the computed parsing order
. Upon request from the user, all `e2immu` annotations of types encountered are uploaded to the annotation server
. Upon request from the user, all `e2immu` annotations in the sources and/or in the annotated API sources, are dumped to
`annotation.xml` files
. Upon request from the user, annotated API files are created

The `e2immu` annotations will have to be in the classpath (ideally by including `e2immu-annot` in the dependencies) as soon as the first annotations are being seen.

=== Annotations to be written out

Let us first consider those written to `annotations.xml`; they are meant to be used in libraries.
Questions and answers are:

- should all of them be of annotation type `CONTRACT`?
No, we'll write them as they come; we'll read them as `CONTRACT`
- should we remove the ones that are `VERIFY_ABSENT`?
Yes

=== Translating Jetbrains annotations to e2immu

`@Contract` on method:

- `mutates="this"` is absence of <<notmodified-annotation>>

`@NotNull` on method and fields is exactly the same as our `@NotNull`.
On parameters, we call it `@NullNotAllowed` for now.

`@Unmodifiable` on any type use of a map or collection means (1) that calling the modification methods has either no effect, or throws an exception, and (2) that there is no means of modifying the references in the container.
Our <<e2immutable-annotation>> annotation is more general.
Seen on fields.