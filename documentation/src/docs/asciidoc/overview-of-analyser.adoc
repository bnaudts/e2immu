=== Overview of the analyser

==== Restrictions

In top-level types, we restrict non-private fields to be @Final.
In nested types,

* we do not want any modifications from the nested class to the enclosing class, or to sibling nested classes.
In our view, nested types are helper types to their enclosing type(s), hierarchically viewed.
This amounts to blocking assignments to fields of the enclosing or sibling class, and calling methods of the enclosing or sibling class that are not @NotModified.
* only in private nested classes are fields allowed to be non-private and non-final at the same time (free variables).
In non-private nested classes, like in top-level types, non-private fields must be @Final.
The reason for this restriction is that we want the methods of an independent type to be the only way of modifying its state; without this rule, methods of the enclosing type would be able to make modifications as well.
* whether the nested class is static or not, is not material here.
* because the `private` modifier to fields does not shield a nested type's field from its enclosing type, assignments must be looked at in the context of the enclosing type.

How to analyse?

* if the nested class is private and static, we either have @E1Immutable fields, or fields accessible from the enclosing type.
The enclosing type either assigns to them, or does not.
** if they are @E1Immutable (it does not assign to them), the situation is equivalent to two completely separate types, independently analysed.
** if the enclosing type assigns to the fields, it is as if these fields are "free variables" for the enclosing type.
We've up to now resisted this (non-private means final!).
For nested classes at least the scope is limited.
From the point of view of the nested class, @E1Immutable is unreachable, @Container is still possible.
* if the nested type is static, but not private, it is reachable from the outside world; we must treat it as a separate type.
* if the nested type is private, but not static,
** if the fields of the nested type are @E1Immutable, and we remember that a subtype cannot change
** otherwise, apart from a scope needed to assign to free variables, the situation is not very different from the static one

==== Order

The type analyser TA's `analyse` method is given a natural order in which to analyse methods and fields.
#TODO and subtypes#

The TA runs iterations of its own analysis, the method analyser MA and field analyser FA in this particular order, until on new decisions have been made anymore.

Only then the TA's `check` method is run, which recursively calls TA, MA and FA check methods.
They verify the annotations.
The method analyser's checks on parameters are inside the parameter analyser, which has no real analysis function.

The MA internally employs a _statement analyser_ SA, which results in a list of statements computed every single pass.
Also created locally is an instance of the class `VariableProperties` implementing the `EvaluationContext` interface.

Definitive analysis results are stored in the `MethodAnalysis`, `FieldAnalysis`, `TypeAnalysis` and `ParameterAnalysis` objects of the respective nodes.
It is important to note that definitive results cannot be overwritten -- they are all implemented using `SetOnce` or `SetOnceMap`.

Iterations of the field and method analysers incrementally set definitive results, until none can made anymore.
It is perfectly possible to delay decisions, but delaying should not be done more than necessary.

==== Decisions about fields

Many decisions about fields can only be made after aggregating data over all the methods where the field was present.

By studying `fieldsLinkedToFieldsAndVariables` at method level,

==== Decisions about a method

===== At end of MA cycle, based on local variable information

The variable properties are computed over again, and values set here need recomputing every cycle.
Nevertheless, some decisions need to be made _with a reference to local variables_.

Analysing the dependency graph of linked variables, the dependencies of a field on parameters are set in `fieldsLinkedToFieldsAndVariables`; the method's `variablesLinkedToFieldsAndParameters` is filled up for local variables.

The variables linked to the method result `variablesLinkedToMethodResult` and the method's `@Linked` annotation are set after a separate analysis of all return statement's `linkedVariables` data, additional input being
- for local variables: `variablesLinkedToFieldsAndParameters`
- for fields: `variablesLinkedToMe`

===== At end of MA cycle, without consulting local variable info

The `sideEffect` value resulting in `@StaticSideEffectsOnly` is analysed by summarizing over all statements at the end of a MA cycle.

The `@Independent` of a constructor or method is computed when decisions about fields linked to parameters are known.
By definition, the annotation is present on a constructor if and only if none of the fields are linked to the parameters of this constructor, as described in `variablesLinkedToMe`.
For ordinary methods, the annotation is the exact opposite of the internal `@Linked` annotation which indicates that the return value of a method is linked to parameters or fields.

By looking at the return statements only at the end of a MA cycle, a summary for return aspect of the method is made when all data is available.
This is the case for the `@Identity`, `@Fluent`, `@NotNull` annotations.

===== Content modification and linked variables

In a method, when a modifying method is called on a local variable that is linked to a parameter, the parameter cannot get the `@NotModified` annotation.
This goes further: when a field's content is modified in another method, but the field is linked to a parameter of this method, this parameter cannot get the annotation.

When going over the variables, if we encounter a
- local variable or

===== Summary 

Field modification (assignments made to fields) is set as
* statement analyser, analysis of assignments, set `MODIFIED`
* --> MA from `MODIFIED` property we set `fieldModifications`

The `fieldRead` marker at the end of method analysis is set for all fields read in a method; this will be needed for content modification (variables will not be set when the field does not appear in the method).

Variable linking is computed as follows:

* statement analyser, analysis of assignments
* --> dependency graph in `variableProperties`
* --> MA: local var, field links in `establishLinks`
* --> (wait cycle for field analysis)
* --> MA: local var, field.`variablesLinkedToMe` in `updateVariablesLinkedToMethodResult`
* --> MA: `@Linked`, variables linked to method result
* --> MA: `@Independent`

In FA: `variablesLinkedToMe` and the field's `@Linked` is set based on `fieldModifications` and `fieldsLinkedToFieldsAndVariables`.

Content modification is computed as:

* statement analyser: `CONTENT_MODIFIED` property is set for all variables
* --> MA, `summarizeModification` for linked variables (linked according to the dependency graph) is computed based on the `CONTENT_MODIFIED` property, and set in `directContentModification` for fields and `@NotModified` for parameters.
Decisions can be delayed when the `@NotModified` status of fields has not been computed yet
* --> FA: based on `directContentModifications` and `fieldRead`, `@NotModified` for fields can be set

=== New text

==== Value booleans

Constant:: a value is constant when it represents a Java literal constant.
This includes `null` and `.class`.
HasConstantProperties:: the properties of the value hav been fully computed, they do not depend on other objects
Unknown:: the unknown property of a value specifies that operators cannot be computed on it.
There are a number of situations:
+
* a `VariableValue` of a non-final field cannot participate in conditionals.
#TODO# it can participate in some, but not in most:
+
----
if(field == 3) { assert field == 3; } // this assertion should fail
----
+
but if we know that such a field is @NotNull because ALL of its assignments are @NotNull, then
+
----
if(field != null) {
----
+
should render an error for contstant evaluation.

* it is of type `UnknownPrimitiveValue`, `CombinedValue`.
#TODO# why is CombinedValue unknown?

As soon as one operand is unknown, operators preserve this property.

==== Values with constant properties

Constants:: This group consists of primitive values, StringValue, ClassValue, NullValue.
The assignment properties are constant as well:

* IMMUTABLE, CONTAINER are all at highest level
* NOT_NULL all true except obviously for NullValue
* SIZE, NOT_MODIFIED are not relevant
* CONSTANT true by definition

Property-wise similar to constants are the operator values: AndValue, BitwiseAndValue, DivideValue, EqualsValue, GreaterThanZeroValue, InstanceOfValue, NegatedValue, OrValue, ProductValue, RemainderValue, SumValue.

ConstrainedNumericValue:: a numeric value between lower and upper bounds.
Used to indicate that the size of a collection is at least 1, for example.

Then there are some marker values:

No value:: temporary value to indicate that certain evaluations have not been concluded yet
Unknown primitive:: unknown value with the properties of a non-null primitive value.
Used as the end result of many operators when one of the operands is unknown.
TypeValue:: is not null, but is nothing else.

==== Values with computed properties

Instance:: only ever the result of a new object expression.
It has all the properties of the type that has been created.
It is never evaluated inside a context.
By definition, it cannot be null.

MethodValue:: the result of a method call, unless
+
--
* it is @Identity, in which case the value of the first parameter is returned
* it is @Fluent, in which case the object or scope of the method call is returned
* it has a single return value of a type different from `MethodValue`.
The typical example is a constant.

The method value has all the properties of its associated method, unless it is @Identity or @Fluent, in which case a method value is not present.
Note that if methods return constants, it is the constant that is returned.
--

ThisValue:: representing the current object.
Like `Instance`, it has all the properties of the type that has been created.
It is never evaluated inside a context.
#TODO# By definition, it cannot be null.

VariableValue::
Value used during statement analysis.
The correct type for fields as well: values are taken from field analysis, then put into variable properties.
The statement analyser accumulates properties in the evaluation context.

VariableValueCopy:: reference to a variable, but with a fixed set of properties.
Is used as the summary of statement analysis: value of return statements, value of fields.

CombinedValue:: when a value is a combination of other values.
Properties are computed over the combination, using the correct operator (best, worst, ...)

ConditionalValue:: value is the combination of the left or the right value, implemented using a combined value.
ArrayValue:: array contents implemented using a combined value.

==== Statement specific analysis values

* escapes? throw statement, propagated upwards
* never continues? return statement or throws, propagated upwards
* error?
* return value

==== Variable properties

The statement analyser accumulates values for properties of variables while iterating over all the statements.

Properties that are specific to the statement analyser:

* NOT_YET_READ_AFTER_ASSIGNMENT: for useless assignment errors
* LAST_ASSIGNMENT_GUARANTEED_TO_BE_REACHED: needed for summarizing properties and assignments up one level; based on presence of `break`, `continue` and
`return` statements
* ASSIGNED_IN_LOOP: values not to be taken too literally

The following list are the assignment properties.
When encountering a return statement with a value different from NO_VALUE, the statement analyser freezes the value and its properties in a value or `VariableValueCopy`, and stores it in the statement:

* IMMUTABLE, CONTAINER: purely based on the annotations of the values (dynamic type property)
* NOT_NULL, SIZE: dynamic type property + occurrence in conditions (if-statement, switch)

Context properties, on all variables:

* READ: 1 = read once, 3 = read multiple times
* ASSIGNED: 1 = once, 3 = multiple times
* METHOD_DELAY: -1 = no method calls, 0 = has method calls, with delay 1 = no delay.
Only when this value is 1, do we know that all information is in.
The following three properties then should have no DELAY values anymore:

** IN_NOT_NULL_CONTEXT: highest @NotNull value encountered in parameters and scope, some statements
** IN_SIZE_CONTEXT: highest @Size value encountered in formal parameters
** CONTENT_MODIFIED: lowest @NotModified encountered in formal parameters

==== Method analyser

Preparation of method analysis:

* details about statements in `numberedStatements`; the return statements are in `returnStatements`; the local methods in `localMethodsCalled`
* summary information at inspection level: methods of own class reached, part of construction

Results of method analysis:

* summary of return values = a single value, and a number of properties
** value is either a single return value if there is only one return statement, otherwise it is a method value.
** The properties of the method value are the actual properties stored in the method analysis; INDEPENDENT, NOT_MODIFIED, IDENTITY, FLUENT, LINKED, CONSTANT, and all the properties that come with field assignments (ASSIGNED ~ single or multiple return values, SIZE, IMMUTABLE, CONTAINER, NOT_NULL)

* summary of activity on `this`.
Properties that are important are: READ, METHOD_DELAY

* summary of field assignment values and related properties
** for each field, we will store a value which is either the "common assignment" or single assignment
** with each value come the properties of that assignment: SIZE, IMMUTABLE, CONTAINER, NOT_NULL

* summary of field usage properties: READ, ASSIGNED, CONTENT_MODIFIED, IN_NOT_NULL_CONTEXT, IN_SIZE_CONTEXT
** CONTENT_MODIFIED is summarized using the link information, specific code
** the other 3 are simply copied into the field's properties at method level


* link information: fields linked to fields and variables, variables linked to fields and parameters, variables linked to the method result.
Note again that links are based on modification information, not equality!
* errors thrown
** complain about missing `static` modifier
** parameter assignments
** unused local variables
** useless assignments
** assigning to fields outside type
** calling modifying methods outside the type
* others:
** does the method create an object of itself?

==== Field analyser

Properties specific to fields are:

* FINAL, and its final value

Shared with the return value of methods:

* LINKED as a debug property to check how modifications travel
* CONSTANT
* NOT_NULL
* SIZE
* IMMUTABLE
* CONTAINER
* NOT_MODIFIED

In the field analyser, the minimum is computed over the assignments of the following properties:
CONTAINER, IMMUTABLE, SIZE (which works fine with >=, but not with two different = mixed), NOT_NULL

For NOT_MODIFIED: we use READ to see if we need to look at this method-field combination.
If READ, then NOT_MODIFIED in DELAY means waiting.

=== Delays

Statement analyser will delay evaluation using NO_VALUE; also requires all method info to be present (METHOD_DELAY).

Properties that do not have a delay: READ, ASSIGNED, METHOD_DELAY

Method properties that rely on METHOD_DELAY before they are fixed: NOT_MODIFIED, SIZE, NOT_NULL

=== Levels

Levels can be improved (value increased) but not decreased in the same map.

[options=header]
|===
| value | READ      | SIZE              | NOT_NULL | IMMUTABLE | METHOD_DELAY    | FINAL
| -1 | absent       |  absent  | delay    | delay | no methods      | delay
| 0  | not read^*^     | >= 0 (no info)       | false    | not E1 | methods, delay  | not final
| 1  | read once    | = 0 (empty)  | @NotNull | E1 | delays solved   | final
| 2  |              | >= 1  (not empty)              | NN, not NN1^*^ | E1, not E2 |    |
| 3  | read multiple times | = 1       | @NotNull1 | E2 | |
| 4  |              | >= 2               | | | |
| 5  |              | = 2              | | | |
|===

The ones with an asterisk ^*^ are optional, and unlikely to be set by the analyser.

