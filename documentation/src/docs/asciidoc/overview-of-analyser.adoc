=== Overview of the analyser

==== Restrictions

In top-level types, we restrict non-private fields to be @Final.
In nested types,

* we do not want any modifications from the nested class to the enclosing class, or to sibling nested classes.
In our view, nested types are helper types to their enclosing type(s), hierarchically viewed.
This amounts to blocking assignments to fields of the enclosing or sibling class, and calling methods of the enclosing or sibling class that are not @NotModified.
* only in private nested classes are fields allowed to be non-private and non-final at the same time (free variables).
In non-private nested classes, like in top-level types, non-private fields must be @Final.
The reason for this restriction is that we want the methods of an independent type to be the only way of modifying its state; without this rule, methods of the enclosing type would be able to make modifications as well.
* whether the nested class is static or not, is not material here.
* because the `private` modifier to fields does not shield a nested type's field from its enclosing type, assignments must be looked at in the context of the enclosing type.

How to analyse?

* if the nested class is private and static, we either have @E1Immutable fields, or fields accessible from the enclosing type.
The enclosing type either assigns to them, or does not.
** if they are @E1Immutable (it does not assign to them), the situation is equivalent to two completely separate types, independently analysed.
** if the enclosing type assigns to the fields, it is as if these fields are "free variables" for the enclosing type.
We've up to now resisted this (non-private means final!).
For nested classes at least the scope is limited.
From the point of view of the nested class, @E1Immutable is unreachable, @Container is still possible.
* if the nested type is static, but not private, it is reachable from the outside world; we must treat it as a separate type.
* if the nested type is private, but not static,
** if the fields of the nested type are @E1Immutable, and we remember that a subtype cannot change
** otherwise, apart from a scope needed to assign to free variables, the situation is not very different from the static one

==== Order

The type analyser TA's `analyse` method is given a natural order in which to analyse methods and fields.
#TODO and subtypes#

The TA runs iterations of its own analysis, the method analyser MA and field analyser FA in this particular order, until on new decisions have been made anymore.

Only then the TA's `check` method is run, which recursively calls TA, MA and FA check methods.
They verify the annotations.
The method analyser's checks on parameters are inside the parameter analyser, which has no real analysis function.

The MA internally employs a _statement analyser_ SA, which results in a list of statements computed every single pass.
Also created locally is an instance of the class `VariableProperties` implementing the `EvaluationContext` interface.

Definitive analysis results are stored in the `MethodAnalysis`, `FieldAnalysis`, `TypeAnalysis` and `ParameterAnalysis` objects of the respective nodes.
It is important to note that definitive results cannot be overwritten -- they are all implemented using `SetOnce` or `SetOnceMap`.

Iterations of the field and method analysers incrementally set definitive results, until none can made anymore.
It is perfectly possible to delay decisions, but delaying should not be done more than necessary.

==== Decisions about fields

Many decisions about fields can only be made after aggregating data over all the methods where the field was present.

By studying `fieldsLinkedToFieldsAndVariables` at method level,

==== Decisions about a method

===== At end of MA cycle, based on local variable information

The variable properties are computed over again, and values set here need recomputing every cycle.
Nevertheless, some decisions need to be made _with a reference to local variables_.

Analysing the dependency graph of linked variables, the dependencies of a field on parameters are set in `fieldsLinkedToFieldsAndVariables`; the method's `variablesLinkedToFieldsAndParameters` is filled up for local variables.

The variables linked to the method result `variablesLinkedToMethodResult` and the method's `@Linked` annotation are set after a separate analysis of all return statement's `linkedVariables` data, additional input being
- for local variables: `variablesLinkedToFieldsAndParameters`
- for fields: `variablesLinkedToMe`

===== At end of MA cycle, without consulting local variable info

The `sideEffect` value resulting in `@StaticSideEffectsOnly` is analysed by summarizing over all statements at the end of a MA cycle.

The `@Independent` of a constructor or method is computed when decisions about fields linked to parameters are known.
By definition, the annotation is present on a constructor if and only if none of the fields are linked to the parameters of this constructor, as described in `variablesLinkedToMe`.
For ordinary methods, the annotation is the exact opposite of the internal `@Linked` annotation which indicates that the return value of a method is linked to parameters or fields.

By looking at the return statements only at the end of a MA cycle, a summary for return aspect of the method is made when all data is available.
This is the case for the `@Identity`, `@Fluent`, `@NotNull` annotations.

===== Content modification and linked variables

In a method, when a modifying method is called on a local variable that is linked to a parameter, the parameter cannot get the `@NotModified` annotation.
This goes further: when a field's content is modified in another method, but the field is linked to a parameter of this method, this parameter cannot get the annotation.

When going over the variables, if we encounter a
- local variable or

===== Summary 

Field modification (assignments made to fields) is set as
* statement analyser, analysis of assignments, set `MODIFIED`
* --> MA from `MODIFIED` property we set `fieldModifications`

The `fieldRead` marker at the end of method analysis is set for all fields read in a method; this will be needed for content modification (variables will not be set when the field does not appear in the method).

Variable linking is computed as follows:

* statement analyser, analysis of assignments
* --> dependency graph in `variableProperties`
* --> MA: local var, field links in `establishLinks`
* --> (wait cycle for field analysis)
* --> MA: local var, field.`variablesLinkedToMe` in `updateVariablesLinkedToMethodResult`
* --> MA: `@Linked`, variables linked to method result
* --> MA: `@Independent`

In FA: `variablesLinkedToMe` and the field's `@Linked` is set based on `fieldModifications` and `fieldsLinkedToFieldsAndVariables`.

Content modification is computed as:

* statement analyser: `CONTENT_MODIFIED` property is set for all variables
* --> MA, `summarizeModification` for linked variables (linked according to the dependency graph) is computed based on the `CONTENT_MODIFIED` property, and set in `directContentModification` for fields and `@NotModified` for parameters.
Decisions can be delayed when the `@NotModified` status of fields has not been computed yet
* --> FA: based on `directContentModifications` and `fieldRead`, `@NotModified` for fields can be set

=== New text

==== Value booleans

Constant:: a value is constant when it represents a Java literal constant.
This includes `null` and `.class`.
HasConstantProperties:: the properties of the value hav been fully computed, they do not depend on other objects
Unknown:: the unknown property of a value specifies that operators cannot be computed on it.
There are a number of situations:
+
* a `VariableValue` of a non-final field cannot participate in conditionals.
#TODO# it can participate in some, but not in most:
+
----
if(field == 3) { assert field == 3; } // this assertion should fail
----
+
but if we know that such a field is @NotNull because ALL of its assignments are @NotNull, then
+
----
if(field != null) {
----
+
should render an error for contstant evaluation.

* it is of type `UnknownPrimitiveValue`, `CombinedValue`.
#TODO# why is CombinedValue unknown?

As soon as one operand is unknown, operators preserve this property.

==== Values with constant properties

Constants:: This group consists of primitive values, StringValue, ClassValue, NullValue.
The assignment properties are constant as well:

* IMMUTABLE, CONTAINER are all at highest level
* NOT_NULL all true except obviously for NullValue
* SIZE, NOT_MODIFIED are not relevant
* CONSTANT true by definition

Property-wise similar to constants are the operator values: AndValue, BitwiseAndValue, DivideValue, EqualsValue, GreaterThanZeroValue, InstanceOfValue, NegatedValue, OrValue, ProductValue, RemainderValue, SumValue.

ConstrainedNumericValue:: a numeric value between lower and upper bounds.
Used to indicate that the size of a collection is at least 1, for example.

Then there are some marker values:

No value:: temporary value to indicate that certain evaluations have not been concluded yet
Unknown primitive:: unknown value with the properties of a non-null primitive value.
Used as the end result of many operators when one of the operands is unknown.
TypeValue:: is not null, but is nothing else.

==== Values with computed properties

Instance:: only ever the result of a new object expression.
It has all the properties of the type that has been created.
It is never evaluated inside a context.
By definition, it cannot be null.

MethodValue:: the result of a method call, unless
+
--
* it is @Identity, in which case the value of the first parameter is returned
* it is @Fluent, in which case the object or scope of the method call is returned
* it has a single return value of a type different from `MethodValue`.
The typical example is a constant.

The method value has all the properties of its associated method, unless it is @Identity or @Fluent, in which case a method value is not present.
Note that if methods return constants, it is the constant that is returned.
--

ThisValue:: representing the current object.
Like `Instance`, it has all the properties of the type that has been created.
It is never evaluated inside a context.
#TODO# By definition, it cannot be null.

VariableValue::
Value used during statement analysis.
The correct type for fields as well: values are taken from field analysis, then put into variable properties.
The statement analyser accumulates properties in the evaluation context.

VariableValueCopy:: reference to a variable, but with a fixed set of properties.
Is used as the summary of statement analysis: value of return statements, value of fields.

CombinedValue:: when a value is a combination of other values.
Properties are computed over the combination, using the correct operator (best, worst, ...)

ConditionalValue:: value is the combination of the left or the right value, implemented using a combined value.
ArrayValue:: array contents implemented using a combined value.

==== Statement specific analysis values

* escapes? throw statement, propagated upwards
* never continues? return statement or throws, propagated upwards
* error?
* return value

==== Variable properties

The statement analyser accumulates values for properties of variables while iterating over all the statements.

Properties that are specific to the statement analyser:

* NOT_YET_READ_AFTER_ASSIGNMENT: for useless assignment errors
* LAST_ASSIGNMENT_GUARANTEED_TO_BE_REACHED: needed for summarizing properties and assignments up one level; based on presence of `break`, `continue` and
`return` statements
* ASSIGNED_IN_LOOP: values not to be taken too literally

The following list are the assignment properties.
When encountering a return statement with a value different from NO_VALUE, the statement analyser freezes the value and its properties in a value or `VariableValuePlaceholder`, and stores it in the statement:

* `IMMUTABLE`, `CONTAINER`: purely based on the annotations of the values (dynamic type property)
* `NOT_NULL`, `SIZE`: dynamic type property + occurrence in conditions (if-statement, switch)

Context properties, on all variables:

* READ: 1 = read once, 3 = read multiple times
* ASSIGNED: 1 = once, 3 = multiple times
* METHOD_DELAY: -1 = no method calls, 0 = has method calls, with delay 1 = no delay.
Only when this value is 1, do we know that all information is in.
The following three properties then should have no DELAY values anymore:

** `NOT_NULL`: highest `@NotNull` value encountered in parameters and scope, some statements
** `SIZE`: highest `@Size` value encountered in formal parameters
** `NOT_MODIFIED`: lowest `@NotModified` encountered in formal parameters

==== Method delay

On scope, based on the SideEffect computation, which has a delay.
On parameters, based on the `NOT_NULL`, `SIZE`, `NOT_MODIFIED` properties.
This means that these values must be present, and not delayed.
In the case of methods that have not been defined, this is not a problem, given that the default value is `FALSE`.

==== Link computer

The link computer works at the method level.
The order of operation is:

. Copy `READ`, `ASSIGNED` and `METHOD_CALLED` into field summaries, and summary of `this`.
This only happens in the first round.
. Ensure that, once different from `NO_VALUE`, the field summary contains the value of assigned fields.
It is important to note that we do not copy the properties
`IMMUTABLE`, `CONTAINER`, `NOT_NULL`, and `SIZE`.
The field analyser will obtain them from the assigned value.

. Establish links between variables.
This algorithm kicks in when the best case and worst case dependency graphs between variables collide, and no variables have remained unevaluated (`NO_VALUE`).
It sets `variablesLinkedToFieldsAndParameters`, and the field summaries' `linkedVariables` set.

. Compute content modification based on the established links.
The algorithm runs over clusters of linked variables, where the fields and parameters are of interest.
Per cluster, it computes a single `NOT_MODIFIED` value, which is delayed when `METHOD_DELAY` is explicitly on (`Level.FALSE`).
In the case of fields, a delay can be overridden when the field is not `READ` in the method.

. update the variables linked to the method result, and set the `LINKED` property.
The algorithm iterates over all `linkedVariables` in the `methodAnalysis.returnStatementSummaries`, and delays when these have not been set yet.
Inside the set of linked variables, it relies on `variablesLinkedToMe` for fields, and `variablesLinkedToFieldsAndParameters` for local variables.
Especially the former may contribute to delaying.

. check for parameter assignments, by studying the `ASSIGNED` property on parameters occurring in the evaluation context.

==== Method analyser

Preparation of method analysis:

* details about statements in `numberedStatements`; information about return statements will be stored in `methodAnalysis.returnStatementSummaries`
* summary information at inspection level: methods of own class reached, part of construction

Results of method analysis:

* summary of return values = a single value, and a number of properties
** value is either a single return value if there is only one return statement, otherwise it is a method value.
** The properties of the method value are the actual properties stored in the method analysis; INDEPENDENT, NOT_MODIFIED, IDENTITY, FLUENT, LINKED, CONSTANT, and all the properties that come with field assignments (ASSIGNED ~ single or multiple return values, SIZE, IMMUTABLE, CONTAINER, NOT_NULL)


* summary of field assignment values and related properties
** for each field, we will store a value which is either the "common assignment" or single assignment
** with each value come the properties of that assignment: `SIZE`, `IMMUTABLE`, `CONTAINER`, `NOT_NULL`

* summary of field usage properties: READ, ASSIGNED, METHOD_CALLED, NOT_MODIFIED, NOT_NULL, SIZE
** We summarize `NOT_MODIFIED` using the link information, specific code
** the first 3 (`READ`, `ASSIGNED`, `METHOD_CALLED`) are simply copied into the field's properties at method level
** The properties `NOT_NULL` and `SIZE`  occur both in a context and in an assignment.

* link information: fields linked to fields and variables, variables linked to fields and parameters, variables linked to the method result.
Note again that links are based on modification information, not equality!
* errors thrown
** complain about missing `static` modifier
** parameter assignments
** unused local variables
** useless assignments
** assigning to fields outside type
** calling modifying methods outside the type
* others:
** does the method create an object of itself?

Order of operation:

. compute `@Independent`, as soon as `ComputeLinking` has filled up `variablesLinkedToFieldsAndParameters`.
The latter is an indication that `variablesLinkedToMethodResult` is available, as are the `linkedVariables` in all the `fieldSummaries`.
. compute `IMMUTABLE`, `CONTAINER`, `NOT_NULL`, `SIZE`, `IDENTITY`, `FLUENT` and their corresponding annotations, based on the `returnStatementSummaries`.
The algorithm computes the lowest available value.
If this value turns out to be `DELAY`, then it delays the computation.
This means that the statement analyser must write out the values for each of these at some point!
The algorithm writes the results in the `methodAnalysis` 's properties map.
. compute `singleReturnValue` and `@Constant`, based on the `returnStatementSummaries`.
. compute `@NotModified`.
The algorithm first checks for assignments using `fieldSummaries`, `ASSIGNMENT` property.
That hurdle passed, it must wait for `variablesLinkedToFieldsAndParameters`.
Once available, it first considers the `NOT_MODIFIED` property of fields.
If any field's content has been modified, the result is false.
To determine the result, it studies the `NOT_MODIFIED` property of `this`, on combination with the `METHODS_CALLED` property.
The combination of the two properties allows us to make the distinction between no method calls, and a delay on method calls.
. call the parameter analyser

==== Parameter analyser

The parameter analyser is a bit of an appendage to the method analyser.
However, it is important it does not delay the properties `NOT_NULL`, `NOT_MODIFIED`, `SIZE` unnecessarily.
The link computer takes care of the property `NOT_MODIFIED`.

==== Field analyser

Order of operation:

. evaluate initialiser if present
. determine `@Final`, based on `methodAnalysis.fieldSummaries`, `ASSIGNED` property, unless explicitly final
. if `@Final` determined, determine the final value, based on `methodAnalysis.fieldSummaries`, `ASSIGNED` and `value`.
Store in `fieldAnalysis.effectivelyFinalValue`.
Compute `@Constant`.
. if `@Final` determined, compute `@Size`, `@NotNull`, `@E2Immutable` and `@Container` based on the same properties in `methodAnalysis.fieldSummaries` and the properties of the initialiser.
The same code handles all four properties in turn.
The algorithm computes the minimum value over the assignments and initialiser of the corresponding property in the field summary.
In the case of `@Size`, incompatible equals restrictions may cause an error.
. compute `@NotModified` based on the `READ` and `NOT_MODIFIED` properties.
We delay when `READ` is available, but `NOT_MODIFIED` is not.
. compute `@Linked` and store the result in `fieldAnalysis.variablesLinkedToMe`.
The algorithm computes the union of all `fieldSummaries.linkedVariables` sets.
. check for errors: unused fields, based on absense of `READ`, and non-final non-private fields

Summarizing, the field analyses delays on

. `ASSIGNED` in `fieldSummaries`, which is available after the first round of method analysis
. `value` in `fieldSummaries`, which may take multiple iterations
. `NOT_MODIFIED` after `READ` is available in the second round.
. `linkedVariables` in `fieldSummaries`, which should take as long as `value`

=== Delays

Statement analyser will delay evaluation using `NO_VALUE`.

Properties that do not have a conventional delay: `READ`, `ASSIGNED`, `METHOD_CALLED`.

The property `METHOD_DELAY` is a special one, in the sense that it tracks delays of properties of method called.
The method's `fieldSummmaries` properties that rely on `METHOD_DELAY` before they are fixed, are the context properties: `NOT_MODIFIED`, `SIZE`, `NOT_NULL`.

=== Levels

Levels can be improved (value increased) but not decreased in the same map.

[options=header]
|===
| property | -1 | 0 | 1 | 2 | 3 | 4 | 5

| READ | absent | not read^*^ | read once | | read multiple times | |
| ASSIGNED | absent | not assigned^*^ | assigned once | | assigned multiple times |  |
| METHOD_DELAY | no methods | methods, no delay | methods, delay | | | |
| METHOD_CALLED | absent | | method calls | | | |
| NOT_MODIFIED | delay | modifications | not modified | | | |
| FINAL | delay | not final | final | | | |
| IMMUTABLE | delay | not E1 | E1Immutable, delay E2 | E1, not E2 | E2Immutable | |
| SIZE | delay | >= 0 (no info) | = 0 (empty) | >= 1 (not empty) | = 1 | >= 2 | = 2
| NOT_NULL | delay | false | @NotNull, delay NN1 | NN, not NN1 | @NotNull1, delay NN2 | NN1, not NN2 | @NotNull2
|===

The ones with an asterisk ^*^ are optional, and unlikely to be set by the analyser.

=== Indirect access to fields

In the methods of type `T`, accessing field `f` is generally done using scope `this`.
However, it is also possible to access `f` through a different variable of type `T`:

[source,java]
----
class T {
    Set<String> set;
    public void add(T t, String s) {
        set.add(s); // <1>
        t.set.add(s); // <2>
    }
}
----
<1> normal access to the field `set`
<2> indirect access to the field `set`.
This statement causes a `NOT_NULL==Level.TRUE` on `t`, but adds a `NOT_MODIFIED==Level.FALSE` to `set`.

The method `copyContextProperties` in `ComputeLinking` takes care of `SIZE`, `NOT_NULL`.
The method `copyFieldAssignmentValue` in the same type handles the assignment properties and value.

=== Opposite annotations

[options=header]
|===

| defensive | offensive  | Notes

| @NotNull  | @Nullable | at level 0; no information about one level deeper
| @NotNull1 | - | opposite not obvious to implement
| @NotNull2 | - | opposite not obvious to implement
| @NotModified | @Modified | content modification of parameters, methods and fields
| @Independent | @Dependent | output is dependent
| @Final | @Variable | field is variable
| @Container | @ModifiesArguments | As soon as one parameter has @Modified
| @E1Immutable | @Mutable | Some fields are not final
| @E2Immutable | @ExternallyMutable | All fields are final, but the objects can be modified from the outside
|===

In defensive mode, objects are

* @Modified unless specified @NotModified (MODIFIED=#1# default)
* @Dependent unless specified @Independent (INDEPENDENT=0 default)
* @Variable unless specified @Final (FINAL=0 default)
* @Nullable unless specified @NotNull, @NotNull1, @NotNull2 (NOT_NULL=0 default)
* @ModifiesArguments unless @Container (CONTAINER=0 default)
* @Mutable unless specified @E1Immutable or @E2Immutable (IMMUTABLE=0 default)

In offensive mode, objects are

* @NotModified unless explicitly @Modified (MODIFIED=#0#)
* @Independent unless explicitly @Dependent (INDEPENDENT=1)
* @Final unless explicitly @Variable (FINAL=1 default)
* @NotNull unless explicitly @Nullable (NOT_NULL=1)
* @Container unless explicitly @ModifiesArguments (CONTAINER=1)
* @E1Immutable unless explicitly @Mutable (IMMUTABLE=1)

=== New text on values and properties

==== Values with constant properties

Constants:: This group consists of primitive values, StringValue, ClassValue, NullValue
Operator values:: AndValue, BitwiseAndValue, DivideValue, EqualsValue, GreaterThanZeroValue, InstanceOfValue, NegatedValue, OrValue, ProductValue, RemainderValue, SumValue.
ConstrainedNumericValue:: a numeric value between lower and upper bounds.
Used to indicate that the size of a collection is at least 1, for example.
No value:: temporary value to indicate that certain evaluations have not been concluded yet
Unknown primitive:: unknown value with the properties of a non-null primitive value.
Used as the end result of many operators when one of the operands is unknown.
TypeValue:: is not null, but is nothing else.

==== Values referring to language constructs

MethodValue:: the outcome of a method call.
Returns property values directly from ``methodAnalysis``' properties, except when there are `@Size(copy = true)` or `@Size(copyMin = true)` annotations on one of the parameters, in which case the computation is delegated to the parameter value.

Instance:: the outcome of a constructor call.
Not null and not modified by definition.
Dynamic type properties `CONTAINER` and `IMMUTABLE` are read from the type.
Size property as in `MethodValue`.

ConditionalValue::
Value representing an inline conditional operation.
Uses a `CombinedValue` helper internally.

ArrayValue:: a value representing all the values of a literal array assignment construct.
Is not null by default, but can have higher `NOT_NULL` values depending on the content.
Defines `SIZE` as the number of values.
Computes no other properties.
The current implementation uses `CombinedValue` as a helper for the `NOT_NULL` computation.

==== Values referring to variables

VariableValue:: the value indicating that the values of all properties are to be found in the evaluation context

FinalFieldValue:: the value representing a field with an effectively final value.
It contains a frozen property-value map, taken from the value (possibly a `CombinedValue` helper) at construction time.
Each time the statement analyser registers a field, it takes the values from this map and places them in the property-value map `AboutVariable`.

VariableValuePlaceholder:: a value representing a variable in the `returnStatementSummaries`.
Its properties will never be read.
This value type exists to ensure that downstream code in the method analyser and link computer will never read the properties, because a variable value in a return statement is a frequent occurrence.

==== Transfer values

Transfer values objects exist to move information from statements via methods down to fields.
They are very similar to a value (they hold properties, linked variables).
Where they differ is that they can contain another value.

We identify two types:

`returnStatementSummaries`:: each return statement in a method will hold such a transfer value.
The method analyser summarizes the following properties in the transfer value property-value map to `methodAnalysis`:
`IMMUTABLE`, `CONTAINER`, `NOT_NULL`, `SIZE`, `IDENTITY`, `FLUENT`.
Only when the transfer value's `value` object is constant, will the method analyser copy it into the single return value of the method.
The alternative is a `MethodValue` object.

`fieldSummaries`:: represents a field referred to in a method.
From `properties`, the field analyser reads `READ`, `ASSIGNED`, `METHOD_DELAY_RESOLVED` and `MODIFIED`.
From the `value`, the field analyser reads `NOT_NULL`, `IMMUTABLE`, `SIZE`, `CONTAINER`.
Importantly, the analyser also reads `NOT_NULL` and `SIZE` from the properties in case there is no assignment.
In this case, the two properties act as restrictions.
The field analyser uses the `linkedVariables` to compute the `@Linked` annotation.

==== Properties of variables

There are two broad classes of properties: those associated with values, and those associated with variables.
The ones associated with variables do not have a corresponding annotation.
Their use is internal, either for marking when certain values have arrived, or for marking actions on the variables.
The variable's property-value map in the evaluation contexts will be the only place that contains their values, with the exception of

* `METHOD_DELAY_RESOLVED`, `READ`, `ASSIGNED` also occur in `fieldSummaries`
* `METHOD_CALLED`, `METHOD_DELAY` also occur in `ForwardEvaluationInfo`

The property `LAST_ASSIGNMENT_GUARANTEED_TO_BE_REACHED` is specific to `VariableProperties`.
The properties `NOT_YET_READ_AFTER_ASSIGNMENT`, `ASSIGNED_IN_LOOP` are specific to `VariableProperties` and the statement analyser.

The properties `METHOD_CALLED`, `READ` and `ASSIGNED` travel from the statement analyser, via link computation and the method analyser, down to the field analyser.

The property `METHOD_DELAY` is specific to the statement analyser, link computation, and a number of expressions.
The property `METHOD_DELAY_RESOLVED` is specific to link computation and the field analyser.

==== Properties of values

The properties of values correspond to annotations.
The properties of values can appear in the variable's property-value map:

* `NOT_NULL` and `SIZE` can become restrictions on a parameter or field represented by a `VariableValue`
* `MODIFIED` also acts as a marker on those variables appearing as the scope of a modifying method, or the argument modified by a method.

Dynamic type properties normally associated with assignments, like `IMMUTABLE` and `CONTAINER`, should not appear in the variable's property-value map.
They should always be read from the value.

The properties `FLUENT` and `IDENTITY` are associated with a method, and cannot appear in the context of a variable.
