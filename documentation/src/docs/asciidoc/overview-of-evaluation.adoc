=== Overview of evaluation

Evaluation occurs multiple times, until there are no changes anymore.

During each evaluation, unless a constant value has been established already, the _current value_ of a variable starts with

- `NO_VALUE` for fields and local variables
- `VariableValue` for parameters

Local variables immediately graduate to real values, or a `VariableValue` if an initialiser is present.
Given that the Java compiler will complain about missing initialisers, we do not need to worry about this.

Fields either:

- have an initialiser, and are final, in which case there is a concrete current value set as soon as the field has been analysed
- are assigned a value, exactly once, somewhere reachable from each of the constructors, which means they are effectively final
- are not effectively final, so there is nothing we can say about them; the value becomes `VariableValue`.

Until a field is declared effectively final, or not, its current value starts with `NO_VALUE`.

Method calls can potentially return constant values.
Until it has been established that there is not a single return statement, `NO_VALUE` is returned.

=== Overview of analysis

The analyser produces and validates annotations.
At the same time, it emits errors for some common programming errors.

The evaluation context keeps a map of properties of variables during the sequential evaluation of the statements of a method.
It is a hierarchical structure, as local variables can be created at many levels.
It also must contain the fields that are being referred to, since fields can be assigned to multiple times in a method, or can appear in null checks.

This map is re-created at each round of evaluation.
It important to have a mechanism to avoid drawing conclusions from iterative steps, as detailed in the following example:

[source]
----
public String method(String input) {
  if(input == null) throw new NullPointerException();
  ...
}
----

As a result of the first iteration, the analyser will decide that the parameter `input` receives the <<nullnotallowed-annotation>> annotation.
If we were to add the is-not-null property to the evaluation context at the second iteration, the conclusion will be that `input == null` results in a constant `false`, which would result in the analyser issuing an error for a redundant `if` statement.
Similarly, the code needs to avoid issuing the same error as iterations go.

==== Linking of variables

Definition: content modification propagates in variables that are linked.
Linking is not relevant for primitives and effectively immutable objects, because their content cannot be modified.
Independence is the exact opposite of linking.
There are two types of linkage: normal links, which are the result of potentially complex assignments, and direct assignments.
Method return values can also be directly assigned to a variable, or linked to multiple variables.

Direct assignments occur in the following situations:

. local variable = some variable.
Anywhere in a method.
. field = some variable.
This typically occurs once in a constructor, but in theory it can occur multiple times and anywhere in a constructor or method reachable from constructors only.
. some variable = identity method(some variable, ....)
. return some variable.

An example of a indirect assignment link is a method call like `field = object.method(p1, p2)` which links `field` to `object`, `p1` and `p2` unless there is an <<independent-annotation>> annotation on the method.
In absence of this annotation, the method can either return `object`, `p1` or `p2` directly, or some new intermediary composed of all three.
Modifications to `p1` or `p2`, or other method calls on `object`, then have the potential to be modifications to `field`.
If any is primitive or effectively immutable, say `p2`, then `field` will not be linked this variable.

The evaluation properties hold two dependency graphs, one for links and one for direct assignments, during each evaluation of a method body.
The transitive closure of dependencies can be evaluated after each evaluation phase.

Is it possible that we need information from the "outside" before we can build the dependency graphs?

. it is possible that the linking properties of a method have not been analysed yet.
This should not occur too often, as we already analyse all methods within a type in the best dependency order, and each type according to dependencies.
However, should a method linking return `NO_VALUE`, we can delay writing the final results.
We will use `variablesLinkedToMethodResult` as a marker, setting an empty set for methods that do not return a result.
. during the evaluation of a assignments, links are computed in the `Value` classes `Instance` (constructors) and `MethodValue` #TODO#.
Both make use of `variablesLinkedToMethodResult` and `variableAssignedToMethodResult`.
. exposing a variable as a argument to a method may cause a link to a field to be formed, but not to our local variables, nor to the other arguments.
+
[source]
----
class Test {
  final Set<String> set; // linked to input via s1
  Test(Set<String> input) {
    copy(input);
  }
  void copy(Set<String> s1) {
    set = s1;
  }
}
----
+
This link can be read from the method's `fieldsLinkedToFieldsAndVariables` map.

==== Overall flow

The type analyser controls the iterations, and cycles through the sorted list of fields and methods.
It is responsible for setting up the evaluation context for each analysis of field or method.

The statement analyser builds the linkage dependency graphs.

The method analyser will complete the linking step once `variablesLinkedToMethodResult` and `variableAssignedToMethodResult` and `fieldsLinkedToFieldsAndVariables` have been written, by writing the `linksComputed` boolean.
It can only delay this step if the evaluation context has recorded some delay because of a method call to an as yet un-analysed method.
As soon as linkage has been completed, the next iteration of the statement analyser will actively detect parameter annotations.
It will then trigger analysis in the field analyser as soon as `fieldAssignments` and `fieldRead` are filled for all fields.

==== Annotations on fields

In this section we first detail how each we compute each of the annotations on fields.

@Constant::
This annotation only makes sense when the field also has the annotation <<final-annotation>>.
The field analyser will set it when the initialiser or computed value for the field can be evaluated to a constant.

@Final::
The annotation follows automatically when the field is explicitly final, i.e., when it has the `final` modifier.
When not explicitly final, the field becomes effectively final when the `methodAnalysis.fieldAssignments` map has been set for the field for none of the methods that are either non-private, or called from outside a constructor.

@Linked::
This annotation indicates that the field has been assigned to another field or parameter, so that content modifications in this link target reflect in the field.
The annotation corresponds to the `fieldAnalysis.variablesLinkedToMe` set, which can be computed once all `methodAnalysis.fieldAssignments` booleans have been determined for the field, and, when positive, also the `methodAnalysis.fieldsLinkedToFieldsAndVariables` sets have been filled in.

@NotModified::
The field analyser sets the annotation directly based on the `methodAnalysis.contentModifications` field of the method analyser: none of the methods which read the field (as indicated by `methodAnalysis.fieldRead`) should have `contentModifications` set to true.
This implies that all linking should have been computed before `fieldRead` can be set to true.

@NotNull::
The computation consists of checking the not null property of the all assignments to the field, in the initialiser, and all the methods.
It uses the `methodAnalysis.fieldAssignments` booleans as a precondition to check that all `methodAnalysis.fieldAssignmentValues` are valid.
This implies that all linking should have been computed before `fieldAssignments` can be set to true.

==== Annotations on parameters

@NotModified for parameters::
The method analyser potentially sets this annotation directly from the variable properties at the end of each expression evaluation, for all linked variables at the same time.
The equivalent for fields is to set the `methodAnalysis.contentModifications` boolean.
The method analyser activates this code by setting `linksComputed` to true.

@NullNotAllowed for parameters::
When, implicitly or explicitly, passing a `null` value to a parameter would result in an exception, the <<nullnotallowed-annotation>> will be added to the parameter The statement analyser makes this assessment in three locations in the statement analyser.
+
It first does this in the `doImplicitNullCheck` method, which detects if a variable, appearing in the scope side of an expression, has a `isNotNull` property.
If it does not have this property, then the implicit null check is present, and the annotation should be added to the parameter assignment-linked to the variable.
Once added, the code adds the `PERMANENTLY_NOT_NULL` property for the rest of the cycle.
+
Secondly, it looks at arguments to method calls which already have the <<nullnotallowed-annotation>> annotation.
If the argument is a variable assignment-linked to a parameter, then the parameter inherits the annotation.
+
Finally, the statement analyser looks at _escapes_ associated with _null conditionals_.
An escape is the termination of a block caused by explicitly throwing an exception.
A null conditional is a `Value` object added to the blocks of an _if-then-else_ statement, or the expressions of the inline conditional operator.
This value, in the case of _if-then-else_, is not a constant but generally an `EqualsValue` object optionally enclosed in a `NegatedValue` or `AndValue`.
The inline conditional operator returns a `ConditionalValue` object which also can act as a null conditional.
+
The method analyser activates this code by setting `linksComputed` to true.

==== Annotations on methods

@Constant::
Immediately after evaluating the main expression of a statement, the statement analyser looks at return statements.
If the evaluation renders a definite value (different from `NO_VALUE`), then it writes this value in `numberedStatement.returnValue`.
At the end of the method analysis, it counts the number of return statements in the method.
If there is only one, and it has a definite value (i.e., `numberedStatement.returnValue` is different from `NO_VALUE`), the code writes `methodAnalysis.singleReturnValue` to this value.
If the value turns out to be a constant, then the code appends a <<constant-annotation>> to the method.
In the case of multiple return statements, it writes an `Instance` value.
The method analysis `check` method validates if the annotation corresponds to this value.
Note that evaluation of the `MethodCall` and `MethodReference` expressions makes use of `methodAnalysis.singleReturnValue`.

@Fluent::
At the end of the method analysis, the code computes whether all return statements return `this`, or the result of another fluent call.
If this is the case, it directly writes a <<fluent-annotation>>.
If the method call has no annotation or negative marker yet, the code delays a decision.
If there is one example of a non-fluent statement, the code writes a negative marker.
The method analysis `check` method validates source code annotations against the presence of computed <<fluent-annotation>> annotations.

@Identity::
Similarly to the <<fluent-annotation>> computation, the method analyser computes whether all return statements return the value of the first parameter, or the result of a method call which has been assigned <<identity-annotation>> already.
If that method call has no annotation yet, the code delays a decision.
If all return statements are identity, the code writes the annotation.
As soon as one return statement is not fluent, the code writes a negative marker to indicate that the method is not identity.
The method analysis `check` method validates source code annotations against the presence of computed <<identity-annotation>> annotations.

@Independent::
As soon as linking has been computed, the method analyser declares non-constructors to be independent when they return primitives or effectively immutable objects, or when the <<linked-annotation>> has been determined to be absent.
It declares constructors independent when none of the fields are linked to the constructor.

@NotModified::
The method analyser computes this annotation in its `methodIsNotModified` method by combining the presence or absence of <<notmodified-annotation>> annotations on each of its parameters, with the `contentModifications` values for each of the fields read.
The code is only activated after linking has been computed.

@NotNull::
In the method analyser, the code for <<notnull-annotation>> behaves identically to that of <<fluent-annotation>> and <<identity-annotation>>, basing its decision on the `numberedStatement.returnsNotNull` boolean.
The statement analyser potentially writes this boolean immediately after having evaluated the main expression of the statement, based on the `isNotNull` property of the evaluation result.
The most interesting implementations of this property are in `VariableValue` and `MethodValue`.
Others are mostly trivial: constants are not null unless they are the `null` constant, operator values are generally not null, etc.

==== Errors

Now we explain how we determine the errors:

Unused local variable::
Based on `methodAnalysis.unusedLocalVariables`, we emit errors during method analysis checking.

Unused assignment:: It makes no sense to assign a value to a variable, and then assign another value before reading the former.
#TODO#

Missing static modifier:: Methods that do not touch instance variables, directly, or indirectly, should be marked `static`.
The `detectMissingStaticStatement` method in the method analyser issues this error if necessary.
It is based on the `methodAnalysis.fieldRead` and `methodAnalysis.fieldModifications` maps, the `methodAnalysis.thisRead` and `methodAnalysis.staticMethodCallsOnly` booleans, and obviously also on properties of the class structure such as the possibility of overriding the method

Condition in if-statement evaluates to constant::
The condition in an `if` statement should not be a constant.
Note that adding a <<nullnotallowed-annotation>> to a parameter because of an `if` statement, forces this parameter to be `PERMANENTLY_NOT_NULL` in the next generation.
To avoid raising this error (`p == null` will always evaluate to `false`), the error flag for this error `numberedStatement.errorValue` is set without raising the error.

Assignment of a parameter::
Intentionally we raise an error when the user assigns a value to a parameter in the method body.
The method analyser determines this straightforwardly, in `updateParameterAnnotationsFromMethodProperties`, by looking at the `ASSIGNED` property in the evaluation context.