=== Overview of evaluation

Evaluation occurs multiple times, until there are no changes anymore.

During each evaluation, unless a constant value has been established already, the _current value_ of a variable starts with

- `NO_VALUE` for fields and local variables
- `VariableValue` for parameters

Local variables immediately graduate to real values, or a `VariableValue` if an initialiser is present.
Given that the Java compiler will complain about missing initialisers, we do not need to worry about this.

Fields either:

- have an initialiser, and are final, in which case there is a concrete current value set as soon as the field has been analysed
- are assigned a value, exactly once, somewhere reachable from each of the constructors, which means they are effectively final
- are not effectively final, so there is nothing we can say about them; the value becomes `VariableValue`.

Until a field is declared effectively final, or not, its current value starts with `NO_VALUE`.

Method calls can potentially return constant values.
Until it has been established that there is not a single return statement, `NO_VALUE` is returned.

Statements with conditional blocks (_if_then_else_, _switch_, _try_catch_) force us to go more complicated than a sequential approach to variable values in a method.
This even applies to any sub-block: local variables may not exist outside of this sub-block, the sequential value outside this sub-block cannot point to a local variable that does not exist anymore.
Some rules:

* universal and pretty trivial rule: if the value is not read in any of the blocks of a statement, it can keep its current value
* unimportant rule: if a value is assigned the same constant (or @E1Immutable field value) in all the blocks, that could become its current value if we have some guarantee that at least one of the blocks is executed.
This seems like a borderline case, we may even have to issue an error if this occurs when we're considering more than one block.
* all assignments count for the @NotNull computation, and for the method's return value, regardless of which block they're in
* it is important to know which blocks are executed at least once

** _if_then_else_ statements have at least one block; similarly does a _switch_ with a default section
** _do_while_ does too, and _while(true)_ does as well; a bit of analysis can help for many loop statements
** _try_catch_ have one, and potentially two (the _finally_ block)
** _synchronized_ has one
** finally, we have the unconditional sub-block: simply starting _{ ... }_

keep in mind that the ‘current value’ of a field may not be worth much

- at least with our restrictions, it will be `private` (we block non-private non-E1Immutable fields
- but still, _unless we’re in construction phase_, other methods within the same class may concurrently set other values!
- should we forbid the use of fields where local variables will do the trick?
(No repeated assignments, no field assignments in loops unless there’s an escape (break, return)?

=== Overview of analysis

The analyser produces and validates annotations.
At the same time, it emits errors for some common programming errors.

The evaluation context keeps a map of properties of variables during the sequential evaluation of the statements of a method.
It is a hierarchical structure, as local variables can be created at many levels.
It also must contain the fields that are being referred to, since fields can be assigned to multiple times in a method, or can appear in null checks.

This map is re-created at each round of evaluation.
It important to have a mechanism to avoid drawing conclusions from iterative steps, as detailed in the following example:

[source]
----
public String method(String input) {
  if(input == null) throw new NullPointerException();
  ...
}
----

As a result of the first iteration, the analyser will decide that the parameter `input` receives the <<nullnotallowed-annotation>> annotation.
If we were to add the is-not-null property to the evaluation context at the second iteration, the conclusion will be that `input == null` results in a constant `false`, which would result in the analyser issuing an error for a redundant `if` statement.
Similarly, the code needs to avoid issuing the same error as iterations go.

==== Linking of variables

Definition: content modification propagates in variables that are linked.
Linking is not relevant for primitives and effectively immutable objects, because their content cannot be modified.
Independence is the exact opposite of linking.
There are two types of linkage: normal links, which are the result of potentially complex assignments, and direct assignments.
Method return values can also be directly assigned to a variable, or linked to multiple variables.

Direct assignments occur in the following situations:

. local variable = some variable.
Anywhere in a method.
. field = some variable.
This typically occurs once in a constructor, but in theory it can occur multiple times and anywhere in a constructor or method reachable from constructors only.
. some variable = identity method(some variable, ....)
. return some variable.

An example of a indirect assignment link is a method call like `field = object.method(p1, p2)` which links `field` to `object`, `p1` and `p2` unless there is an <<independent-annotation>> annotation on the method.
In absence of this annotation, the method can either return `object`, `p1` or `p2` directly, or some new intermediary composed of all three.
Modifications to `p1` or `p2`, or other method calls on `object`, then have the potential to be modifications to `field`.
If any is primitive or effectively immutable, say `p2`, then `field` will not be linked this variable.

The evaluation properties hold two dependency graphs, one for links and one for direct assignments, during each evaluation of a method body.
The transitive closure of dependencies can be evaluated after each evaluation phase.

Is it possible that we need information from the "outside" before we can build the dependency graphs?

. it is possible that the linking properties of a method have not been analysed yet.
This should not occur too often, as we already analyse all methods within a type in the best dependency order, and each type according to dependencies.
However, should a method linking return `NO_VALUE`, we can delay writing the final results.
We will use `variablesLinkedToMethodResult` as a marker, setting an empty set for methods that do not return a result.
. during the evaluation of a assignments, links are computed in the `Value` classes `Instance` (constructors) and `MethodValue` #TODO#.
Both make use of `variablesLinkedToMethodResult`.
. exposing a variable as a argument to a method may cause a link to a field to be formed, but not to our local variables, nor to the other arguments.
+
[source]
----
class Test {
  final Set<String> set; // linked to input via s1
  Test(Set<String> input) {
    copy(input);
  }
  void copy(Set<String> s1) {
    set = s1;
  }
}
----
+
This link can be read from the method's `fieldsLinkedToFieldsAndVariables` map.

==== Detail of MethodValue

Studying `a = b.method(c, d)`, we want to find out how and when `a` becomes linked to `b`, `c` or `d`.

. if `a` is primitive, or <<e2immutable-annotation>>, then `a` is completely independent of `b`, `c` and `d`, because there cannot be changes to `a` 's content.
. if the method has been marked <<independent-annotation>>, the object returned cannot be linked to the fields of `b`, nor the parameters `c` and `d`, by definition of the annotation.
. if `b` is <<e2immutable-annotation>>, it is impossible for `a` to be linked to `b`, but `a` can still be linked to `c` and or `d`.
The following example shows such a link in the `append` method:
+
[source]
----
@E2Immutable
class Append {
  @E2Immutable
  public final Set<String> strings;

  public Append(Set<String> input) {
    strings = ImmutableSet.copyOf(input);
  }

  @Identity // and @NotModified but not @Independent
  public Set<String> append(Set<String> input) {
    input.addAll(strings);
    return input;
  }
}
----

. if the method has been marked <<notmodified-annotation>>, the same situation _does not apply_.
Not modified means that here cannot be a link between `b` 's content, and that of `c` and `d`, because `b` 's content will not be modified.
However, the return value of the method can still be linked to `b` (as in `java.util.List.subList`) or `c` or `d`.

==== Overall flow

The type analyser controls the iterations, and cycles through the sorted list of fields and methods.
It is responsible for setting up the evaluation context for each analysis of field or method.

The statement analyser builds the linkage dependency graphs.

The method analyser will complete the linking step once `variablesLinkedToMethodResult` and `fieldsLinkedToFieldsAndVariables` have been written, by writing the `linksComputed` boolean.
It will do so when all values of fields and local variables have a definite value (different from `NO_VALUE`).
This will happen once all `fieldAssignmentValues` are known.

As soon as linkage has been completed, the next iteration of the statement analyser will actively detect parameter annotations.
It will then trigger analysis in the field analyser as soon as `fieldAssignments` and `fieldRead` are filled for all fields.

. <<nullnotallowed-annotation>> on parameters, once evaluations defined
. `fieldAssignments`, `fieldsRead`
. <<final-annotation>> on fields
. fieldAssignmentValues, once evaluations defined
. <<constant-annotation>> and <<notnull-annotation>> on fields, once relevant fieldAssignmentValues defined
. go back to 3 until all fields have a defined value
. `contentModifications`
. <<notmodified-annotation>> for parameters

==== Annotations on fields

In this section we first detail how each we compute each of the annotations on fields.

@Constant::
This annotation only makes sense when the field also has the annotation <<final-annotation>>.
The field analyser will set it when the initialiser or computed value for the field can be evaluated to a constant.
It can do so when all `methodAnalysis.fieldAssignmentValues` are valid.

@Final::
The annotation follows automatically when the field is explicitly final, i.e., when it has the `final` modifier.
When not explicitly final, the field becomes effectively final when the `methodAnalysis.fieldAssignments` map has been set for the field for none of the methods that are either non-private, or called from outside a constructor.

@Linked::
This annotation indicates that the field has been assigned to another field or parameter, so that content modifications in this link target reflect in the field.
The annotation corresponds to the `fieldAnalysis.variablesLinkedToMe` set, which can be computed once all `methodAnalysis.fieldAssignments` booleans have been determined for the field, and, when positive, also the `methodAnalysis.fieldsLinkedToFieldsAndVariables` sets have been filled in.

@NotModified::
The field analyser sets the annotation directly based on the `methodAnalysis.contentModifications` field of the method analyser: none of the methods which read the field (as indicated by `methodAnalysis.fieldRead`) should have `contentModifications` set to true.
This implies that all linking should have been computed before `fieldRead` can be set to true.

@NotNull::
The computation consists of checking the not null property of the all assignments to the field, in the initialiser, and all the methods.
It uses the `methodAnalysis.fieldAssignments` booleans as a precondition to check that all `methodAnalysis.fieldAssignmentValues` are valid.

==== Annotations on parameters

@NotModified for parameters::
The method analyser potentially sets this annotation directly from the variable properties at the end of each expression evaluation, for all linked variables at the same time.
The equivalent for fields is to set the `methodAnalysis.contentModifications` boolean.
The method analyser activates this code by setting `linksComputed` to true.

@NullNotAllowed for parameters::
When, implicitly or explicitly, passing a `null` value to a parameter would result in an exception, the <<nullnotallowed-annotation>> will be added to the parameter The statement analyser makes this assessment in three locations in the statement analyser.
+
It first does this in the `doImplicitNullCheck` method, which detects if a variable, appearing in the scope side of an expression, has a `isNotNull` property.
If it does not have this property, then the implicit null check is present, and the annotation should be added to the parameter assignment-linked to the variable.
Once added, the code adds the `PERMANENTLY_NOT_NULL` property for the rest of the cycle.
+
Secondly, it looks at arguments to method calls which already have the <<nullnotallowed-annotation>> annotation.
If the argument is a variable assignment-linked to a parameter, then the parameter inherits the annotation.
+
Finally, the statement analyser looks at _escapes_ associated with _null conditionals_.
An escape is the termination of a block caused by explicitly throwing an exception.
A null conditional is a `Value` object added to the blocks of an _if-then-else_ statement, or the expressions of the inline conditional operator.
This value, in the case of _if-then-else_, is not a constant but generally an `EqualsValue` object optionally enclosed in a `NegatedValue` or `AndValue`.
The inline conditional operator returns a `ConditionalValue` object which also can act as a null conditional.
+
The method analyser activates this code by setting `linksComputed` to true.

==== Annotations on methods

@Constant::
Immediately after evaluating the main expression of a statement, the statement analyser looks at return statements.
If the evaluation renders a definite value (different from `NO_VALUE`), then it writes this value in `numberedStatement.returnValue`.
At the end of the method analysis, it counts the number of return statements in the method.
If there is only one, and it has a definite value (i.e., `numberedStatement.returnValue` is different from `NO_VALUE`), the code writes `methodAnalysis.singleReturnValue` to this value.
If the value turns out to be a constant, then the code appends a <<constant-annotation>> to the method.
In the case of multiple return statements, it writes an `Instance` value.
The method analysis `check` method validates if the annotation corresponds to this value.
Note that evaluation of the `MethodCall` and `MethodReference` expressions makes use of `methodAnalysis.singleReturnValue`.

@Fluent::
At the end of the method analysis, the code computes whether all return statements return `this`, or the result of another fluent call.
If this is the case, it directly writes a <<fluent-annotation>>.
If the method call has no annotation or negative marker yet, the code delays a decision.
If there is one example of a non-fluent statement, the code writes a negative marker.
The method analysis `check` method validates source code annotations against the presence of computed <<fluent-annotation>> annotations.

@Identity::
Similarly to the <<fluent-annotation>> computation, the method analyser computes whether all return statements return the value of the first parameter, or the result of a method call which has been assigned <<identity-annotation>> already.
If that method call has no annotation yet, the code delays a decision.
If all return statements are identity, the code writes the annotation.
As soon as one return statement is not fluent, the code writes a negative marker to indicate that the method is not identity.
The method analysis `check` method validates source code annotations against the presence of computed <<identity-annotation>> annotations.

@Independent::
As soon as linking has been computed, the method analyser declares non-constructors to be independent when they return primitives or effectively immutable objects, or when the <<linked-annotation>> has been determined to be absent.
It declares constructors independent when none of the fields are linked to the constructor.

@NotModified::
The method analyser computes this annotation in its `methodIsNotModified` method by combining the presence or absence of <<notmodified-annotation>> annotations on each of its parameters, with the `contentModifications` values for each of the fields read.
The code is only activated after linking has been computed.

@NotNull::
In the method analyser, the code for <<notnull-annotation>> behaves identically to that of <<fluent-annotation>> and <<identity-annotation>>, basing its decision on the `numberedStatement.returnsNotNull` boolean.
The statement analyser potentially writes this boolean immediately after having evaluated the main expression of the statement, based on the `isNotNull` property of the evaluation result.
The most interesting implementations of this property are in `VariableValue` and `MethodValue`.
Others are mostly trivial: constants are not null unless they are the `null` constant, operator values are generally not null, etc.

==== Errors

Now we explain how we determine the errors:

Unused local variable::
Based on `methodAnalysis.unusedLocalVariables`, we emit errors during method analysis checking.

Unused assignment:: It makes no sense to assign a value to a variable, and then assign another value before reading the former.
#TODO#

Missing static modifier:: Methods that do not touch instance variables, directly, or indirectly, should be marked `static`.
The `detectMissingStaticStatement` method in the method analyser issues this error if necessary.
It is based on the `methodAnalysis.fieldRead` and `methodAnalysis.fieldModifications` maps, the `methodAnalysis.thisRead` and `methodAnalysis.staticMethodCallsOnly` booleans, and obviously also on properties of the class structure such as the possibility of overriding the method

Condition in if-statement evaluates to constant::
The condition in an `if` statement should not be a constant.
Note that adding a <<nullnotallowed-annotation>> to a parameter because of an `if` statement, forces this parameter to be `PERMANENTLY_NOT_NULL` in the next generation.
To avoid raising this error (`p == null` will always evaluate to `false`), the error flag for this error `numberedStatement.errorValue` is set without raising the error.

Assignment of a parameter::
Intentionally we raise an error when the user assigns a value to a parameter in the method body.
The method analyser determines this straightforwardly, in `updateParameterAnnotationsFromMethodProperties`, by looking at the `ASSIGNED` property in the evaluation context.

=== Evaluation trail

We need the concept of a _safe expression_, which is an expression that can be repeatedly evaluated, each time rendering identical results.
Rather than computing on expression level, we compute at value level (a method can return a constant, for example).
Which ones are safe?

* `Constant` expressions
* `VariableValues`, if the variable is either @E1Immutable, local and not assigned to, and not modified in between evaluations.
This applies to all `VariableValues` occurring in the value.
* `MethodValue` expressions, if the method is @E2Immutable and no parameter values are modified
* `Instance`?

#TODO:# does this equate to the SIDE EFFECT computation? Anything that has side effect NONE is safe

#TODO:# check that higher level immutability is not required

Then,

* the `singleResult` of a method, if it exists, is either a `Constant`, or an `Instance` object with a `notNull` variable set
* the result of an assignment to a variable is either
** a `Constant`
** an `Instance` object, as a result of a new object creation, or the single result of a method
** the method call itself, if the method is <<e2immutable-annotation>> and the parameters made no modifications
** a `VariableValue` if the assignment is the result has a non-safe method call somewhere in the structure
