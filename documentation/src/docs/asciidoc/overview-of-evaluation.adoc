=== Overview of evaluation

Evaluation occurs multiple times, until there are no changes anymore.

During each evaluation, unless a constant value has been established already, the _current value_ of a variable starts with

- `NO_VALUE` for fields and local variables
- `VariableValue` for parameters

Local variables immediately graduate to real values, or a `VariableValue` if an initialiser is present.
Given that the Java compiler will complain about missing initialisers, we do not need to worry about this.

Fields either:

- have an initialiser, and are final, in which case there is a concrete current value set as soon as the field has been analysed
- are assigned a value, exactly once, somewhere reachable from each of the constructors, which means they are effectively final
- are not effectively final, so there is nothing we can say about them; the value becomes `VariableValue`.

Until a field is declared effectively final, or not, its current value starts with `NO_VALUE`.

Method calls can potentially return constant values.
Until it has been established that there is not a single return statement, `NO_VALUE` is returned.

=== Overview of analysis

The analyser produces and validates annotations.
At the same time, it emits errors for some common programming errors.

The evaluation context keeps a map of properties of variables during the sequential evaluation of the statements of a method.
It is a hierarchical structure, as local variables can be created at many levels.
It also must contain the fields that are being referred to, since fields can be assigned to multiple times in a method, or can appear in null checks.

This map is re-created at each round of evaluation.
It important to have a mechanism to avoid drawing conclusions from iterative steps, as detailed in the following example:

[source]
----
public String method(String input) {
  if(input == null) throw new NullPointerException();
  ...
}
----

As a result of the first iteration, the analyser will decide that the parameter `input` receives the <<nullnotallowed-annotation>> annotation.
If we were to add the is-not-null property to the evaluation context at the second iteration, the conclusion will be that `input == null` results in a constant `false`, which would result in the analyser issuing an error for a redundant `if` statement.
Similarly, the code needs to avoid issuing the same error as iterations go.

==== Annotations

In this section we first detail how each we compute each of the annotations on fields.

@Constant on fields::
This annotation only makes sense when the field is also <<final-annotation>>.
The field analyser will set in when the initialiser or computed value for the field turns out to be a constant.

@Final on fields::
The annotation follows automatically when the field is explicitly final, i.e., when it has the `final` modifier.
When not explicitly final, the field becomes effectively final when the `methodAnalysis.fieldAssignments` map for the field has been set in any of the methods that are either non-private, or called from outside a constructor.

@Linked on fields::
This annotation indicates that the field has been assigned to another field or parameter, so that content modifications in this link target reflect in the field.
The annotation corresponds to the `fieldAnalysis.variablesLinkedToMe` set, which can be computed once all `methodAnalysis.fieldAssignments` booleans have been determined for the field, and, when positive, also the `methodAnalysis.fieldsLinkedToFieldsAndVariables` sets have been filled in.

@NotModified for fields::
The field analyser sets the annotation directly based on the `contentModifications` field of the method analyser: none of the methods which read the field (as indicated by `methodAnalyser.fieldRead`) should have `contentModifications` set to true.
This implies that all linking should have been computed before `read` can be set to true.

@NotNull for fields::
The computation consists of checking the not null property of the all assignments to the field, in the initialiser, and all the methods.
It uses the `methodAnalysis.fieldAssignments` booleans as a precondition to check that all `methodAnalysis.fieldAssignmentValues` are valid.
This implies that all linking should have been computed before `fieldAssignments` can be set to true.

==== Annotations on parameters

@NullNotAllowed for parameters::
When, implicitly or explicitly, passing a `null` value to a parameter would result in an exception, the <<nullnotallowed-annotation>> will be added to the parameter.
The statement analyser makes this assessment in three locations in the statement analyser.
+
It first does this in the `doImplicitNullCheck` method, which detects if a variable, appearing in the scope side of an expression, has a `isNotNull` property.
If it does not have this property, then the implicit null check is present, and the annotation should be added.
Once added, the code adds the `CHECK_NOT_NULL` property for the rest of the cycle.
+
Secondly, it looks at arguments to method calls which already have the <<nullnotallowed-annotation>> annotation.
If the argument is a parameter, then it inherits the annotation.
+
Finally, the statement analyser looks at _escapes_ associated with _null conditionals_.
An escape is the termination of a block caused by explicitly throwing an exception.
A null conditional is an `Value` object added to the blocks of an _if-then-else_ statement, or the expressions of the inline conditional operator.
This value, in the case of `if` and `else`, is not a constant but generally an `EqualsValue` object optionally enclosed in a `NegatedValue` or `AndValue`.
The inline conditional operator returns a `ConditionalValue` object which also can act as a null conditional.

==== Annotations on methods

@Constant for methods::
Immediately after evaluating the main expression of a statement, the statement analyser looks at return statements.
If the evaluation renders a definite value (different from `NO_VALUE`), then it writes this value in `numberedStatement.returnValue`.
At the end of the method analysis, it counts the number of return statements in the method.
If there is only one, and it has a definite value (i.e., `numberedStatement.returnValue` is different from `NO_VALUE`), the code writes `methodAnalysis.singleReturnValue` to this value.
If the value turns out to be a constant, then the code appends a <<constant-annotation>> to the method.
In the case of multiple return statements, it writes an `Instance` value.
The method analysis `check` method validates if the annotation corresponds to this value.
Note that evaluation of the `MethodCall` and `MethodReference` expressions makes use of `methodAnalysis.singleReturnValue`.

@Fluent for methods::
At the end of the method analysis, the code computes whether all return statements return `this`, or the result of another fluent call.
If this is the case, it directly writes a <<fluent-annotation>>.
If the method call has no annotation or negative marker yet, the code delays a decision.
If there is one example of a non-fluent statement, the code writes a negative marker.
The method analysis `check` method validates source code annotations against the presence of computed <<fluent-annotation>> annotations.

@Identity for methods::
Similarly to the <<fluent-annotation>> computation, the method analyser computes whether all return statements return the value of the first parameter, or the result of a method call which has been assigned <<identity-annotation>> already.
If that method call has no annotation yet, the code delays a decision.
If all return statements are identity, the code writes the annotation.
As soon as one return statement is not fluent, the code writes a negative marker to indicate that the method is not identity.
The method analysis `check` method validates source code annotations against the presence of computed <<identity-annotation>> annotations.


@NotNull for methods::
In the method analyser, the code for <<notnull-annotation>> behaves identically to that of <<fluent-annotation>> and <<identity-annotation>>, basing its decision on the `numberedStatement.returnsNotNull` boolean.
The statement analyser potentially writes this boolean immediately after having evaluated the main expression of the statement, based on the `isNotNull` property of the evaluation result.
The most interesting implementations of this property are in `VariableValue` and `MethodValue`.
Others are mostly trivial: constants are not null unless they are the `null` constant, operator values are generally not null, etc.

==== Errors

Now we explain how we determine the errors:

Unused local variable::
Finally, based on `methodAnalysis.unusedLocalVariables`, we emit errors during method analysis checking.

Unused assignment:: It makes no sense to assign a value to a variable, and then assign another value before reading the former.

Missing static modifier:: Methods that do not touch instance variables, directly, or indirectly, should be marked `static`.
The `detectNotModified` method in the method analyser starts by issuing this error if necessary.
It is based on the `methodAnalysis.fieldRead` and `methodAnalysis.fieldModifications` maps, the `methodAnalysis.thisRead` and `methodAnalysis.staticMethodCallsOnly` booleans, and obviously also on properties of the class structure such as the possibility of overriding the method

Condition in if-statement evaluates to constant::
The condition in an `if` statement should not be a constant.

Assignment of a parameter::
Intentionally we raise an error when the user assigns a value to a parameter in the method body.
The method analyser determines this straightforwardly, in `updateParameterAnnotationsFromMethodProperties`, by looking at the `ASSIGNED` property in the evaluation context.